Disassembly Listing for clock_big_7seg_red_v2
Generated From:
D:/GitHub/mcu/projects/clock_big_7seg_red_v2/dist/default/production/clock_big_7seg_red_v2.production.elf
12 juil. 2020 19:14:47

---  D:/GitHub/mcu/projects/clock_big_7seg_red_v2/main.c  -----------------------------------------------
1:             //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:             //&&&   Project     :   Clock with Big Red 7seg Display v2                  &&&
3:             //&&&   Author      :   Pierre Blaché                                       &&&
4:             //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:             //&&&   IDE         :   MPLABX v5.35                                        &&&
6:             //&&&   Compiler    :   XC8 v2.10                                           &&&
7:             //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:             //&&&   Version     :                                                       &&&
9:             //&&&   - 1.0    30 Apr 2020    Creation                                    &&&
10:            //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:            
12:            //------------------------- Remove useless warnings ---------------------------
13:            #pragma warning disable 520     // function is never called
14:            #pragma warning disable 759     // expression generates no code
15:            #pragma warning disable 1498    // pointer in expression may have no targets
16:            #pragma warning disable 1510    // non-reentrant function
17:            #pragma warning disable 2020    // IRQ N (...) in vector table @ 0xXX is unassigned
18:            
19:            //-------------------------------- includes -----------------------------------
20:            #include "config.h"             /* should be at the first place */
21:            #include "xc.h"
22:            #include "hardware_profile.h"
23:            
24:            #include "bcd.h"
25:            #include "console.h"
26:            #include "date_time.h"
27:            #include "delays.h"
28:            #include "i2c.h"
29:            #include "interrupts.h"
30:            #include "io.h"
31:            #include "log.h"
32:            #include "timer.h"
33:            #include "types.h"
34:            #include "uart.h"
35:            
36:            //-------------------------------- Defines ------------------------------------
37:            #define SEG_OFF         10
38:            #define DEBOUNCE_DELAY  100
39:            #define NOP10           {Nop(); Nop(); Nop(); Nop(); Nop(); \
40:                                     Nop(); Nop(); Nop(); Nop(); Nop();}
41:            UART_ID UART_ID_LOG = UART_ID_1;
42:            
43:            //---------------------------- Global variables -------------------------------
44:            bool_t time_has_changed_user = FALSE;
45:            bool_t time_has_changed_timer = FALSE;
46:            
47:            typedef union{
48:                struct{
49:                    unsigned a : 1;
50:                    unsigned b : 1;
51:                    unsigned c : 1;
52:                    unsigned d : 1;
53:                    unsigned e : 1;
54:                    unsigned f : 1;
55:                    unsigned g : 1;
56:                }s;
57:            }segments_t;
58:            
59:            segments_t min, min10, hrs, hrs10;
60:            
61:            //--------------------------------- Constants ---------------------------------
62:            const u8 dec_to_seg[11] = {
63:                0xBF, 
64:                0x86, 
65:                0xDB, 
66:                0xCF, 
67:                0xE6, 
68:                0xED, 
69:                0xFD, 
70:                0x87, 
71:                0xFF, 
72:                0xEF, 
73:                0xC0
74:            };   // 1 = On
75:            
76:            /* les afficheurs sont controllés par des NPN, il faut donc un '1' pour allumer */
77:            // #define UPDATE_MIN(x)   { \
78:            //     if (dec_to_seg[x] & 0x40) SEG_MIN_G = 1;\
79:            //     if (dec_to_seg[x] & 0x20) SEG_MIN_F = 1;\
80:            //     if (dec_to_seg[x] & 0x10) SEG_MIN_E = 1;\
81:            //     if (dec_to_seg[x] & 0x08) SEG_MIN_D = 1;\
82:            //     if (dec_to_seg[x] & 0x04) SEG_MIN_C = 1;\
83:            //     if (dec_to_seg[x] & 0x02) SEG_MIN_B = 1;\
84:            //     if (dec_to_seg[x] & 0x01) SEG_MIN_A = 1;\
85:            // }
86:            
87:            // #define UPDATE_MIN10(x)   { \
88:            //     if (dec_to_seg[x] & 0x40) SEG_MIN10_G = 1;\
89:            //     if (dec_to_seg[x] & 0x20) SEG_MIN10_F = 1;\
90:            //     if (dec_to_seg[x] & 0x10) SEG_MIN10_E = 1;\
91:            //     if (dec_to_seg[x] & 0x08) SEG_MIN10_D = 1;\
92:            //     if (dec_to_seg[x] & 0x04) SEG_MIN10_C = 1;\
93:            //     if (dec_to_seg[x] & 0x02) SEG_MIN10_B = 1;\
94:            //     if (dec_to_seg[x] & 0x01) SEG_MIN10_A = 1;\
95:            // }
96:            
97:            // #define UPDATE_HRS(x)   { \
98:            //     if (dec_to_seg[x] & 0x40) SEG_HRS_G = 1;\
99:            //     if (dec_to_seg[x] & 0x20) SEG_HRS_F = 1;\
100:           //     if (dec_to_seg[x] & 0x10) SEG_HRS_E = 1;\
101:           //     if (dec_to_seg[x] & 0x08) SEG_HRS_D = 1;\
102:           //     if (dec_to_seg[x] & 0x04) SEG_HRS_C = 1;\
103:           //     if (dec_to_seg[x] & 0x02) SEG_HRS_B = 1;\
104:           //     if (dec_to_seg[x] & 0x01) SEG_HRS_A = 1;\
105:           // }
106:           
107:           // #define UPDATE_HRS10(x)   { \
108:           //     if (dec_to_seg[x] & 0x40) SEG_HRS10_G = 1;\
109:           //     if (dec_to_seg[x] & 0x20) SEG_HRS10_F = 1;\
110:           //     if (dec_to_seg[x] & 0x10) SEG_HRS10_E = 1;\
111:           //     if (dec_to_seg[x] & 0x08) SEG_HRS10_D = 1;\
112:           //     if (dec_to_seg[x] & 0x04) SEG_HRS10_C = 1;\
113:           //     if (dec_to_seg[x] & 0x02) SEG_HRS10_B = 1;\
114:           //     if (dec_to_seg[x] & 0x01) SEG_HRS10_A = 1;\
115:           // }
116:           
117:           #define UPDATE_MIN(x)   { \
118:               if (dec_to_seg[x] & 0x40) min.s.g = 1;\
119:               if (dec_to_seg[x] & 0x20) min.s.f = 1;\
120:               if (dec_to_seg[x] & 0x10) min.s.e = 1;\
121:               if (dec_to_seg[x] & 0x08) min.s.d = 1;\
122:               if (dec_to_seg[x] & 0x04) min.s.c = 1;\
123:               if (dec_to_seg[x] & 0x02) min.s.b = 1;\
124:               if (dec_to_seg[x] & 0x01) min.s.a = 1;\
125:           }
126:           
127:           #define UPDATE_MIN10(x)   { \
128:               if (dec_to_seg[x] & 0x40) min10.s.g = 1;\
129:               if (dec_to_seg[x] & 0x20) min10.s.f = 1;\
130:               if (dec_to_seg[x] & 0x10) min10.s.e = 1;\
131:               if (dec_to_seg[x] & 0x08) min10.s.d = 1;\
132:               if (dec_to_seg[x] & 0x04) min10.s.c = 1;\
133:               if (dec_to_seg[x] & 0x02) min10.s.b = 1;\
134:               if (dec_to_seg[x] & 0x01) min10.s.a = 1;\
135:           }
136:           
137:           #define UPDATE_HRS(x)   { \
138:               if (dec_to_seg[x] & 0x40) hrs.s.g = 1;\
139:               if (dec_to_seg[x] & 0x20) hrs.s.f = 1;\
140:               if (dec_to_seg[x] & 0x10) hrs.s.e = 1;\
141:               if (dec_to_seg[x] & 0x08) hrs.s.d = 1;\
142:               if (dec_to_seg[x] & 0x04) hrs.s.c = 1;\
143:               if (dec_to_seg[x] & 0x02) hrs.s.b = 1;\
144:               if (dec_to_seg[x] & 0x01) hrs.s.a = 1;\
145:           }
146:           
147:           #define UPDATE_HRS10(x)   { \
148:               if (dec_to_seg[x] & 0x40) hrs10.s.g = 1;\
149:               if (dec_to_seg[x] & 0x20) hrs10.s.f = 1;\
150:               if (dec_to_seg[x] & 0x10) hrs10.s.e = 1;\
151:               if (dec_to_seg[x] & 0x08) hrs10.s.d = 1;\
152:               if (dec_to_seg[x] & 0x04) hrs10.s.c = 1;\
153:               if (dec_to_seg[x] & 0x02) hrs10.s.b = 1;\
154:               if (dec_to_seg[x] & 0x01) hrs10.s.a = 1;\
155:           }
156:           
157:           /* setting the gpio takes 2 cycles */
158:           #define SET_MIN   { \
159:               SEG_MIN_G = min.s.g;\
160:               SEG_MIN_F = min.s.f;\
161:               SEG_MIN_E = min.s.e;\
162:               SEG_MIN_D = min.s.d;\
163:               SEG_MIN_C = min.s.c;\
164:               SEG_MIN_B = min.s.b;\
165:               SEG_MIN_A = min.s.a;\
166:           }
167:           
168:           #define SET_MIN10  { \
169:               SEG_MIN10_G = min10.s.g;\
170:               SEG_MIN10_F = min10.s.f;\
171:               SEG_MIN10_E = min10.s.e;\
172:               SEG_MIN10_D = min10.s.d;\
173:               SEG_MIN10_C = min10.s.c;\
174:               SEG_MIN10_B = min10.s.b;\
175:               SEG_MIN10_A = min10.s.a;\
176:           }
177:           
178:           #define SET_HRS   { \
179:               SEG_HRS_G = hrs.s.g;\
180:               SEG_HRS_F = hrs.s.f;\
181:               SEG_HRS_E = hrs.s.e;\
182:               SEG_HRS_D = hrs.s.d;\
183:               SEG_HRS_C = hrs.s.c;\
184:               SEG_HRS_B = hrs.s.b;\
185:               SEG_HRS_A = hrs.s.a;\
186:           }
187:           
188:           #define SET_HRS10   { \
189:               SEG_HRS10_G = hrs10.s.g;\
190:               SEG_HRS10_F = hrs10.s.f;\
191:               SEG_HRS10_E = hrs10.s.e;\
192:               SEG_HRS10_D = hrs10.s.d;\
193:               SEG_HRS10_C = hrs10.s.c;\
194:               SEG_HRS10_B = hrs10.s.b;\
195:               SEG_HRS10_A = hrs10.s.a;\
196:           }
197:           
198:           /* add a nop to have also 2 cycles to clear the GPIO*/
199:           #define RESET_MIN   { \
200:               SEG_MIN_G = 0; Nop();\
201:               SEG_MIN_F = 0; Nop();\
202:               SEG_MIN_E = 0; Nop();\
203:               SEG_MIN_D = 0; Nop();\
204:               SEG_MIN_C = 0; Nop();\
205:               SEG_MIN_B = 0; Nop();\
206:               SEG_MIN_A = 0; Nop();\
207:           }
208:           
209:           #define RESET_MIN10   { \
210:               SEG_MIN10_G = 0; Nop();\
211:               SEG_MIN10_F = 0; Nop();\
212:               SEG_MIN10_E = 0; Nop();\
213:               SEG_MIN10_D = 0; Nop();\
214:               SEG_MIN10_C = 0; Nop();\
215:               SEG_MIN10_B = 0; Nop();\
216:               SEG_MIN10_A = 0; Nop();\
217:           }
218:           
219:           #define RESET_HRS   { \
220:               SEG_HRS_G = 0; Nop();\
221:               SEG_HRS_F = 0; Nop();\
222:               SEG_HRS_E = 0; Nop();\
223:               SEG_HRS_D = 0; Nop();\
224:               SEG_HRS_C = 0; Nop();\
225:               SEG_HRS_B = 0; Nop();\
226:               SEG_HRS_A = 0; Nop();\
227:           }
228:           
229:           #define RESET_HRS10   { \
230:               SEG_HRS10_G = 0; Nop();\
231:               SEG_HRS10_F = 0; Nop();\
232:               SEG_HRS10_E = 0; Nop();\
233:               SEG_HRS10_D = 0; Nop();\
234:               SEG_HRS10_C = 0; Nop();\
235:               SEG_HRS10_B = 0; Nop();\
236:               SEG_HRS10_A = 0; Nop();\
237:           }
238:           
239:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
240:           //-------------------------------- Main Program -------------------------------
241:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
242:           void main (void)
10000  0E00     MOVLW 0x0
10002  0100     MOVLB 0x0
10004  6FEE     MOVWF pwm, BANKED
243:           {
244:               u8 cnt = 0;
245:               u8 pwm = 0;
246:               u8 bcd[5];
247:               u8 pwm_cycle = 10;
10006  0E0A     MOVLW 0xA
10008  6FED     MOVWF pwm_cycle, BANKED
248:               u8 bcd_min = 0;
1000A  0E00     MOVLW 0x0
1000C  6FEF     MOVWF bcd_min, BANKED
249:               u8 bcd_min10 = 0;
1000E  0E00     MOVLW 0x0
10010  6FF0     MOVWF bcd_min10, BANKED
250:               u8 bcd_hrs = 0;
10012  0E00     MOVLW 0x0
10014  6FF1     MOVWF bcd_hrs, BANKED
251:               u8 bcd_hrs10 = 0;
10016  0E00     MOVLW 0x0
10018  6FF2     MOVWF bcd_hrs10, BANKED
252:               
253:               date_time_t t = {
1001A  0E0F     MOVLW 0xF
1001C  6FF3     MOVWF t, BANKED
10020  F3CC     NOP
10022  F0F3     NOP
10024  0E38     MOVLW 0x38
10026  6FF4     MOVWF 0xF4, BANKED
1002A  F3D0     NOP
1002C  F0F4     NOP
1002E  0E00     MOVLW 0x0
10030  6FF5     MOVWF 0xF5, BANKED
10034  F3D4     NOP
10036  F0F5     NOP
10038  0E06     MOVLW 0x6
1003A  6FF6     MOVWF 0xF6, BANKED
1003E  F3D8     NOP
10040  F0F6     NOP
10042  0E0B     MOVLW 0xB
10044  6FF7     MOVWF 0xF7, BANKED
10048  F3DC     NOP
1004A  F0F7     NOP
1004C  0E07     MOVLW 0x7
1004E  6FF8     MOVWF 0xF8, BANKED
10052  F3E0     NOP
10054  F0F8     NOP
10056  0E14     MOVLW 0x14
10058  6FF9     MOVWF 0xF9, BANKED
1005C  F3E4     NOP
1005E  F0F9     NOP
254:                   t.hrs = 15,
255:                   t.min = 56,
256:                   t.sec =  0,
257:                   t.dow =  6,
258:                   t.day = 11,
259:                   t.mth = 07,
260:                   t.yrs = 20
261:               };
262:           
263:           //--------------------------- Initialisation du PIC ---------------------------
264:               /* select analog (1) or digital (0) GPIO */
265:               ANSELA = 0;
10060  0E00     MOVLW 0x0
10062  013A     MOVLB 0x3A
10064  6F40     MOVWF 0x40, BANKED
266:               ANSELB = 0;
10066  0E00     MOVLW 0x0
10068  6F50     MOVWF 0x50, BANKED
267:               ANSELC = 0;
1006A  0E00     MOVLW 0x0
1006C  6F60     MOVWF __pbssBANK0, BANKED
268:               ANSELD = 0;
1006E  0E00     MOVLW 0x0
10070  6F70     MOVWF 0x70, BANKED
269:               ANSELE = 0;
10072  0E00     MOVLW 0x0
10074  6F80     MOVWF 0x80, BANKED
270:               ANSELF = 0;
10076  0E00     MOVLW 0x0
10078  6F90     MOVWF 0x90, BANKED
271:           
272:               /* config GPIO as an input (1) or an output (0) */
273:               set_port_A_input(0);
1007A  0E00     MOVLW 0x0
1007C  6EC2     MOVWF 0xFC2, ACCESS
274:               set_port_B_input(BIT_5 | BIT_4);
1007E  0E30     MOVLW 0x30
10080  6EC3     MOVWF 0xFC3, ACCESS
275:               set_port_C_input(BIT_0);
10082  0E01     MOVLW 0x1
10084  6EC4     MOVWF 0xFC4, ACCESS
276:               set_port_D_input(BIT_3 | BIT_0);
10086  0E09     MOVLW 0x9
10088  6EC5     MOVWF 0xFC5, ACCESS
277:               set_port_E_input(0);
1008A  0E00     MOVLW 0x0
1008C  6EC6     MOVWF 0xFC6, ACCESS
278:               set_port_F_input(0);
1008E  0E00     MOVLW 0x0
10090  6EC7     MOVWF 0xFC7, ACCESS
279:           
280:               /* Configure RC3, RC4 as Open Drain */
281:               ODCONA = 0;
10092  0E00     MOVLW 0x0
10094  6F42     MOVWF 0x42, BANKED
282:               ODCONB = 0;
10096  0E00     MOVLW 0x0
10098  6F52     MOVWF 0x52, BANKED
283:               ODCONC = 0;
1009A  0E00     MOVLW 0x0
1009C  6F62     MOVWF 0x62, BANKED
284:               ODCONCbits.ODCC3 = 1;   /* I2C1 SCL */
1009E  8762     BSF 0x62, 3, BANKED
285:               ODCONCbits.ODCC4 = 1;   /* I2C1 SDA */
100A0  8962     BSF 0x62, 4, BANKED
286:               ODCOND = 0;
100A2  0E00     MOVLW 0x0
100A4  6F72     MOVWF 0x72, BANKED
287:               ODCONE = 0;
100A6  0E00     MOVLW 0x0
100A8  6F82     MOVWF 0x82, BANKED
288:               ODCONF = 0;
100AA  0E00     MOVLW 0x0
100AC  6F92     MOVWF 0x92, BANKED
289:           
290:               /* default state */
291:               LATA = 0x00;
100AE  0E00     MOVLW 0x0
100B0  6EBA     MOVWF 0xFBA, ACCESS
292:               LATB = 0x00;
100B2  0E00     MOVLW 0x0
100B4  6EBB     MOVWF 0xFBB, ACCESS
293:               LATC = 0x00;
100B6  0E00     MOVLW 0x0
100B8  6EBC     MOVWF 0xFBC, ACCESS
294:               LATD = 0x00;
100BA  0E00     MOVLW 0x0
100BC  6EBD     MOVWF 0xFBD, ACCESS
295:               LATE = 0x00;
100BE  0E00     MOVLW 0x0
100C0  6EBE     MOVWF 0xFBE, ACCESS
296:               LATF = 0x00;
100C2  0E00     MOVLW 0x0
100C4  6EBF     MOVWF 0xFBF, ACCESS
297:           
298:           //----------------------------------- UART ------------------------------------
299:               // if (uart_init(UART_ID_1, UART_FREQ) != SUCCESS){
300:               //     LED_ERROR = 1;
301:               // }
302:               
303:           //--------------------- i2c, bus & devices initialization ---------------------
304:               // if (i2c_init(I2C_BUS_1, I2C_FREQ, I2C_MASTER) != SUCCESS){
305:               //     PRINT_ERROR("I2C initialization failed");
306:               //     LED_ERROR = 1;
307:               // }
308:               // i2c_detect(UART_ID_1, I2C_BUS_1);
309:               
310:           //------------------------------- Init Timer 2 --------------------------------
311:               /* Timer period = Fosc(10M) /  Prescaler(1) / Postscaler(10) / Timer(100) / Cnt(1000) = 1s */
312:               if (timer_init(TIMER_ID_2, TMR_PRESCALER_1, TMR_POSTSCALER_10, 100/*timer*/) != SUCCESS){
100C6  0E00     MOVLW 0x0
100C8  6E02     MOVWF dividend, ACCESS
100CA  0E09     MOVLW 0x9
100CC  6E03     MOVWF uart_id, ACCESS
100CE  0E64     MOVLW 0x64
100D0  6E04     MOVWF txData, ACCESS
100D2  0E02     MOVLW 0x2
100D4  ECDF     CALL 0x117BE, 0
100D6  F08B     NOP
100D8  0900     IORLW 0x0
100DA  B4D8     BTFSC 0xFD8, 2, ACCESS
100DC  EF72     GOTO 0x100E4
100DE  F080     NOP
100E0  EF74     GOTO 0x100E8
100E2  F080     NOP
100E4  EF7C     GOTO 0x100F8
100E6  F080     NOP
313:                   PRINT_ERROR("Timer initialization failed");
100E8  0E3E     MOVLW 0x3E
100EA  0100     MOVLB 0x0
100EC  6FEA     MOVWF log, BANKED
100EE  0EFE     MOVLW 0xFE
100F0  6FEB     MOVWF 0xEB, BANKED
100F2  EC0F     CALL 0x1201E, 0
100F4  F090     NOP
314:                   LED_ERROR = 1;
100F6  84BE     BSF 0xFBE, 2, ACCESS
315:               }
316:           
317:           //------------------------------------ RTC ------------------------------------
318:               // ds1307_init(I2C_BUS_1, I2C_ADR_DS1307);
319:               // ds1307_set_time(I2C_BUS_1, I2C_ADR_DS1307, t);
320:               // ds1307_get_time(I2C_BUS_1, I2C_ADR_DS1307, &t);
321:           
322:           //----------------------------- Global Interrupts -----------------------------
323:               // enable_global_interrutps();
324:           
325:           //-----------------------------------------------------------------------------
326:               while (1)
327:               {
328:           
329:                   UPDATE_MIN  (bcd_min);
100F8  0E3D     MOVLW 0x3D
100FA  0100     MOVLB 0x0
100FC  25EF     ADDWF bcd_min, W, BANKED
100FE  6EF6     MOVWF 0xFF6, ACCESS
10100  6AF7     CLRF 0xFF7, ACCESS
10102  0EFD     MOVLW 0xFD
10104  22F7     ADDWFC 0xFF7, F, ACCESS
10106  6AF8     CLRF 0xFF8, ACCESS
10108  0E00     MOVLW 0x0
1010A  22F8     ADDWFC 0xFF8, F, ACCESS
1010C  0008     TBLRD*
1010E  ACF5     BTFSS 0xFF5, 6, ACCESS
10110  EF8C     GOTO 0x10118
10112  F080     NOP
10114  EF8E     GOTO 0x1011C
10116  F080     NOP
10118  EF90     GOTO 0x10120
1011A  F080     NOP
1011C  0100     MOVLB 0x0
1011E  8D79     BSF min, 6, BANKED
10120  0E3D     MOVLW 0x3D
10122  0100     MOVLB 0x0
10124  25EF     ADDWF bcd_min, W, BANKED
10126  6EF6     MOVWF 0xFF6, ACCESS
10128  6AF7     CLRF 0xFF7, ACCESS
1012A  0EFD     MOVLW 0xFD
1012C  22F7     ADDWFC 0xFF7, F, ACCESS
1012E  6AF8     CLRF 0xFF8, ACCESS
10130  0E00     MOVLW 0x0
10132  22F8     ADDWFC 0xFF8, F, ACCESS
10134  0008     TBLRD*
10136  AAF5     BTFSS 0xFF5, 5, ACCESS
10138  EFA0     GOTO 0x10140
1013A  F080     NOP
1013C  EFA2     GOTO 0x10144
1013E  F080     NOP
10140  EFA4     GOTO 0x10148
10142  F080     NOP
10144  0100     MOVLB 0x0
10146  8B79     BSF min, 5, BANKED
10148  0E3D     MOVLW 0x3D
1014A  0100     MOVLB 0x0
1014C  25EF     ADDWF bcd_min, W, BANKED
1014E  6EF6     MOVWF 0xFF6, ACCESS
10150  6AF7     CLRF 0xFF7, ACCESS
10152  0EFD     MOVLW 0xFD
10154  22F7     ADDWFC 0xFF7, F, ACCESS
10156  6AF8     CLRF 0xFF8, ACCESS
10158  0E00     MOVLW 0x0
1015A  22F8     ADDWFC 0xFF8, F, ACCESS
1015C  0008     TBLRD*
1015E  A8F5     BTFSS 0xFF5, 4, ACCESS
10160  EFB4     GOTO 0x10168
10162  F080     NOP
10164  EFB6     GOTO 0x1016C
10166  F080     NOP
10168  EFB8     GOTO 0x10170
1016A  F080     NOP
1016C  0100     MOVLB 0x0
1016E  8979     BSF min, 4, BANKED
10170  0E3D     MOVLW 0x3D
10172  0100     MOVLB 0x0
10174  25EF     ADDWF bcd_min, W, BANKED
10176  6EF6     MOVWF 0xFF6, ACCESS
10178  6AF7     CLRF 0xFF7, ACCESS
1017A  0EFD     MOVLW 0xFD
1017C  22F7     ADDWFC 0xFF7, F, ACCESS
1017E  6AF8     CLRF 0xFF8, ACCESS
10180  0E00     MOVLW 0x0
10182  22F8     ADDWFC 0xFF8, F, ACCESS
10184  0008     TBLRD*
10186  A6F5     BTFSS 0xFF5, 3, ACCESS
10188  EFC8     GOTO 0x10190
1018A  F080     NOP
1018C  EFCA     GOTO 0x10194
1018E  F080     NOP
10190  EFCC     GOTO 0x10198
10192  F080     NOP
10194  0100     MOVLB 0x0
10196  8779     BSF min, 3, BANKED
10198  0E3D     MOVLW 0x3D
1019A  0100     MOVLB 0x0
1019C  25EF     ADDWF bcd_min, W, BANKED
1019E  6EF6     MOVWF 0xFF6, ACCESS
101A0  6AF7     CLRF 0xFF7, ACCESS
101A2  0EFD     MOVLW 0xFD
101A4  22F7     ADDWFC 0xFF7, F, ACCESS
101A6  6AF8     CLRF 0xFF8, ACCESS
101A8  0E00     MOVLW 0x0
101AA  22F8     ADDWFC 0xFF8, F, ACCESS
101AC  0008     TBLRD*
101AE  A4F5     BTFSS 0xFF5, 2, ACCESS
101B0  EFDC     GOTO 0x101B8
101B2  F080     NOP
101B4  EFDE     GOTO 0x101BC
101B6  F080     NOP
101B8  EFE0     GOTO 0x101C0
101BA  F080     NOP
101BC  0100     MOVLB 0x0
101BE  8579     BSF min, 2, BANKED
101C0  0E3D     MOVLW 0x3D
101C2  0100     MOVLB 0x0
101C4  25EF     ADDWF bcd_min, W, BANKED
101C6  6EF6     MOVWF 0xFF6, ACCESS
101C8  6AF7     CLRF 0xFF7, ACCESS
101CA  0EFD     MOVLW 0xFD
101CC  22F7     ADDWFC 0xFF7, F, ACCESS
101CE  6AF8     CLRF 0xFF8, ACCESS
101D0  0E00     MOVLW 0x0
101D2  22F8     ADDWFC 0xFF8, F, ACCESS
101D4  0008     TBLRD*
101D6  A2F5     BTFSS 0xFF5, 1, ACCESS
101D8  EFF0     GOTO 0x101E0
101DA  F080     NOP
101DC  EFF2     GOTO 0x101E4
101DE  F080     NOP
101E0  EFF4     GOTO 0x101E8
101E2  F080     NOP
101E4  0100     MOVLB 0x0
101E6  8379     BSF min, 1, BANKED
101E8  0E3D     MOVLW 0x3D
101EA  0100     MOVLB 0x0
101EC  25EF     ADDWF bcd_min, W, BANKED
101EE  6EF6     MOVWF 0xFF6, ACCESS
101F0  6AF7     CLRF 0xFF7, ACCESS
101F2  0EFD     MOVLW 0xFD
101F4  22F7     ADDWFC 0xFF7, F, ACCESS
101F6  6AF8     CLRF 0xFF8, ACCESS
101F8  0E00     MOVLW 0x0
101FA  22F8     ADDWFC 0xFF8, F, ACCESS
101FC  0008     TBLRD*
101FE  A0F5     BTFSS 0xFF5, 0, ACCESS
10200  EF04     GOTO 0x10208
10202  F081     NOP
10204  EF06     GOTO 0x1020C
10206  F081     NOP
10208  EF08     GOTO 0x10210
1020A  F081     NOP
1020C  0100     MOVLB 0x0
1020E  8179     BSF min, 0, BANKED
330:                   UPDATE_MIN10(bcd_min10);
10210  0E3D     MOVLW 0x3D
10212  0100     MOVLB 0x0
10214  25F0     ADDWF bcd_min10, W, BANKED
10216  6EF6     MOVWF 0xFF6, ACCESS
10218  6AF7     CLRF 0xFF7, ACCESS
1021A  0EFD     MOVLW 0xFD
1021C  22F7     ADDWFC 0xFF7, F, ACCESS
1021E  6AF8     CLRF 0xFF8, ACCESS
10220  0E00     MOVLW 0x0
10222  22F8     ADDWFC 0xFF8, F, ACCESS
10224  0008     TBLRD*
10226  ACF5     BTFSS 0xFF5, 6, ACCESS
10228  EF18     GOTO 0x10230
1022A  F081     NOP
1022C  EF1A     GOTO 0x10234
1022E  F081     NOP
10230  EF1C     GOTO 0x10238
10232  F081     NOP
10234  0100     MOVLB 0x0
10236  8D78     BSF min10, 6, BANKED
10238  0E3D     MOVLW 0x3D
1023A  0100     MOVLB 0x0
1023C  25F0     ADDWF bcd_min10, W, BANKED
1023E  6EF6     MOVWF 0xFF6, ACCESS
10240  6AF7     CLRF 0xFF7, ACCESS
10242  0EFD     MOVLW 0xFD
10244  22F7     ADDWFC 0xFF7, F, ACCESS
10246  6AF8     CLRF 0xFF8, ACCESS
10248  0E00     MOVLW 0x0
1024A  22F8     ADDWFC 0xFF8, F, ACCESS
1024C  0008     TBLRD*
1024E  AAF5     BTFSS 0xFF5, 5, ACCESS
10250  EF2C     GOTO 0x10258
10252  F081     NOP
10254  EF2E     GOTO 0x1025C
10256  F081     NOP
10258  EF30     GOTO 0x10260
1025A  F081     NOP
1025C  0100     MOVLB 0x0
1025E  8B78     BSF min10, 5, BANKED
10260  0E3D     MOVLW 0x3D
10262  0100     MOVLB 0x0
10264  25F0     ADDWF bcd_min10, W, BANKED
10266  6EF6     MOVWF 0xFF6, ACCESS
10268  6AF7     CLRF 0xFF7, ACCESS
1026A  0EFD     MOVLW 0xFD
1026C  22F7     ADDWFC 0xFF7, F, ACCESS
1026E  6AF8     CLRF 0xFF8, ACCESS
10270  0E00     MOVLW 0x0
10272  22F8     ADDWFC 0xFF8, F, ACCESS
10274  0008     TBLRD*
10276  A8F5     BTFSS 0xFF5, 4, ACCESS
10278  EF40     GOTO 0x10280
1027A  F081     NOP
1027C  EF42     GOTO 0x10284
1027E  F081     NOP
10280  EF44     GOTO 0x10288
10282  F081     NOP
10284  0100     MOVLB 0x0
10286  8978     BSF min10, 4, BANKED
10288  0E3D     MOVLW 0x3D
1028A  0100     MOVLB 0x0
1028C  25F0     ADDWF bcd_min10, W, BANKED
1028E  6EF6     MOVWF 0xFF6, ACCESS
10290  6AF7     CLRF 0xFF7, ACCESS
10292  0EFD     MOVLW 0xFD
10294  22F7     ADDWFC 0xFF7, F, ACCESS
10296  6AF8     CLRF 0xFF8, ACCESS
10298  0E00     MOVLW 0x0
1029A  22F8     ADDWFC 0xFF8, F, ACCESS
1029C  0008     TBLRD*
1029E  A6F5     BTFSS 0xFF5, 3, ACCESS
102A0  EF54     GOTO 0x102A8
102A2  F081     NOP
102A4  EF56     GOTO 0x102AC
102A6  F081     NOP
102A8  EF58     GOTO 0x102B0
102AA  F081     NOP
102AC  0100     MOVLB 0x0
102AE  8778     BSF min10, 3, BANKED
102B0  0E3D     MOVLW 0x3D
102B2  0100     MOVLB 0x0
102B4  25F0     ADDWF bcd_min10, W, BANKED
102B6  6EF6     MOVWF 0xFF6, ACCESS
102B8  6AF7     CLRF 0xFF7, ACCESS
102BA  0EFD     MOVLW 0xFD
102BC  22F7     ADDWFC 0xFF7, F, ACCESS
102BE  6AF8     CLRF 0xFF8, ACCESS
102C0  0E00     MOVLW 0x0
102C2  22F8     ADDWFC 0xFF8, F, ACCESS
102C4  0008     TBLRD*
102C6  A4F5     BTFSS 0xFF5, 2, ACCESS
102C8  EF68     GOTO 0x102D0
102CA  F081     NOP
102CC  EF6A     GOTO 0x102D4
102CE  F081     NOP
102D0  EF6C     GOTO 0x102D8
102D2  F081     NOP
102D4  0100     MOVLB 0x0
102D6  8578     BSF min10, 2, BANKED
102D8  0E3D     MOVLW 0x3D
102DA  0100     MOVLB 0x0
102DC  25F0     ADDWF bcd_min10, W, BANKED
102DE  6EF6     MOVWF 0xFF6, ACCESS
102E0  6AF7     CLRF 0xFF7, ACCESS
102E2  0EFD     MOVLW 0xFD
102E4  22F7     ADDWFC 0xFF7, F, ACCESS
102E6  6AF8     CLRF 0xFF8, ACCESS
102E8  0E00     MOVLW 0x0
102EA  22F8     ADDWFC 0xFF8, F, ACCESS
102EC  0008     TBLRD*
102EE  A2F5     BTFSS 0xFF5, 1, ACCESS
102F0  EF7C     GOTO 0x102F8
102F2  F081     NOP
102F4  EF7E     GOTO 0x102FC
102F6  F081     NOP
102F8  EF80     GOTO 0x10300
102FA  F081     NOP
102FC  0100     MOVLB 0x0
102FE  8378     BSF min10, 1, BANKED
10300  0E3D     MOVLW 0x3D
10302  0100     MOVLB 0x0
10304  25F0     ADDWF bcd_min10, W, BANKED
10306  6EF6     MOVWF 0xFF6, ACCESS
10308  6AF7     CLRF 0xFF7, ACCESS
1030A  0EFD     MOVLW 0xFD
1030C  22F7     ADDWFC 0xFF7, F, ACCESS
1030E  6AF8     CLRF 0xFF8, ACCESS
10310  0E00     MOVLW 0x0
10312  22F8     ADDWFC 0xFF8, F, ACCESS
10314  0008     TBLRD*
10316  A0F5     BTFSS 0xFF5, 0, ACCESS
10318  EF90     GOTO 0x10320
1031A  F081     NOP
1031C  EF92     GOTO 0x10324
1031E  F081     NOP
10320  EF94     GOTO 0x10328
10322  F081     NOP
10324  0100     MOVLB 0x0
10326  8178     BSF min10, 0, BANKED
331:                   UPDATE_HRS  (bcd_hrs);
10328  0E3D     MOVLW 0x3D
1032A  0100     MOVLB 0x0
1032C  25F1     ADDWF bcd_hrs, W, BANKED
1032E  6EF6     MOVWF 0xFF6, ACCESS
10330  6AF7     CLRF 0xFF7, ACCESS
10332  0EFD     MOVLW 0xFD
10334  22F7     ADDWFC 0xFF7, F, ACCESS
10336  6AF8     CLRF 0xFF8, ACCESS
10338  0E00     MOVLW 0x0
1033A  22F8     ADDWFC 0xFF8, F, ACCESS
1033C  0008     TBLRD*
1033E  ACF5     BTFSS 0xFF5, 6, ACCESS
10340  EFA4     GOTO 0x10348
10342  F081     NOP
10344  EFA6     GOTO 0x1034C
10346  F081     NOP
10348  EFA8     GOTO 0x10350
1034A  F081     NOP
1034C  0100     MOVLB 0x0
1034E  8D77     BSF hrs, 6, BANKED
10350  0E3D     MOVLW 0x3D
10352  0100     MOVLB 0x0
10354  25F1     ADDWF bcd_hrs, W, BANKED
10356  6EF6     MOVWF 0xFF6, ACCESS
10358  6AF7     CLRF 0xFF7, ACCESS
1035A  0EFD     MOVLW 0xFD
1035C  22F7     ADDWFC 0xFF7, F, ACCESS
1035E  6AF8     CLRF 0xFF8, ACCESS
10360  0E00     MOVLW 0x0
10362  22F8     ADDWFC 0xFF8, F, ACCESS
10364  0008     TBLRD*
10366  AAF5     BTFSS 0xFF5, 5, ACCESS
10368  EFB8     GOTO 0x10370
1036A  F081     NOP
1036C  EFBA     GOTO 0x10374
1036E  F081     NOP
10370  EFBC     GOTO 0x10378
10372  F081     NOP
10374  0100     MOVLB 0x0
10376  8B77     BSF hrs, 5, BANKED
10378  0E3D     MOVLW 0x3D
1037A  0100     MOVLB 0x0
1037C  25F1     ADDWF bcd_hrs, W, BANKED
1037E  6EF6     MOVWF 0xFF6, ACCESS
10380  6AF7     CLRF 0xFF7, ACCESS
10382  0EFD     MOVLW 0xFD
10384  22F7     ADDWFC 0xFF7, F, ACCESS
10386  6AF8     CLRF 0xFF8, ACCESS
10388  0E00     MOVLW 0x0
1038A  22F8     ADDWFC 0xFF8, F, ACCESS
1038C  0008     TBLRD*
1038E  A8F5     BTFSS 0xFF5, 4, ACCESS
10390  EFCC     GOTO 0x10398
10392  F081     NOP
10394  EFCE     GOTO 0x1039C
10396  F081     NOP
10398  EFD0     GOTO 0x103A0
1039A  F081     NOP
1039C  0100     MOVLB 0x0
1039E  8977     BSF hrs, 4, BANKED
103A0  0E3D     MOVLW 0x3D
103A2  0100     MOVLB 0x0
103A4  25F1     ADDWF bcd_hrs, W, BANKED
103A6  6EF6     MOVWF 0xFF6, ACCESS
103A8  6AF7     CLRF 0xFF7, ACCESS
103AA  0EFD     MOVLW 0xFD
103AC  22F7     ADDWFC 0xFF7, F, ACCESS
103AE  6AF8     CLRF 0xFF8, ACCESS
103B0  0E00     MOVLW 0x0
103B2  22F8     ADDWFC 0xFF8, F, ACCESS
103B4  0008     TBLRD*
103B6  A6F5     BTFSS 0xFF5, 3, ACCESS
103B8  EFE0     GOTO 0x103C0
103BA  F081     NOP
103BC  EFE2     GOTO 0x103C4
103BE  F081     NOP
103C0  EFE4     GOTO 0x103C8
103C2  F081     NOP
103C4  0100     MOVLB 0x0
103C6  8777     BSF hrs, 3, BANKED
103C8  0E3D     MOVLW 0x3D
103CA  0100     MOVLB 0x0
103CC  25F1     ADDWF bcd_hrs, W, BANKED
103CE  6EF6     MOVWF 0xFF6, ACCESS
103D0  6AF7     CLRF 0xFF7, ACCESS
103D2  0EFD     MOVLW 0xFD
103D4  22F7     ADDWFC 0xFF7, F, ACCESS
103D6  6AF8     CLRF 0xFF8, ACCESS
103D8  0E00     MOVLW 0x0
103DA  22F8     ADDWFC 0xFF8, F, ACCESS
103DC  0008     TBLRD*
103DE  A4F5     BTFSS 0xFF5, 2, ACCESS
103E0  EFF4     GOTO 0x103E8
103E2  F081     NOP
103E4  EFF6     GOTO 0x103EC
103E6  F081     NOP
103E8  EFF8     GOTO 0x103F0
103EA  F081     NOP
103EC  0100     MOVLB 0x0
103EE  8577     BSF hrs, 2, BANKED
103F0  0E3D     MOVLW 0x3D
103F2  0100     MOVLB 0x0
103F4  25F1     ADDWF bcd_hrs, W, BANKED
103F6  6EF6     MOVWF 0xFF6, ACCESS
103F8  6AF7     CLRF 0xFF7, ACCESS
103FA  0EFD     MOVLW 0xFD
103FC  22F7     ADDWFC 0xFF7, F, ACCESS
103FE  6AF8     CLRF 0xFF8, ACCESS
10400  0E00     MOVLW 0x0
10402  22F8     ADDWFC 0xFF8, F, ACCESS
10404  0008     TBLRD*
10406  A2F5     BTFSS 0xFF5, 1, ACCESS
10408  EF08     GOTO 0x10410
1040A  F082     NOP
1040C  EF0A     GOTO 0x10414
1040E  F082     NOP
10410  EF0C     GOTO 0x10418
10412  F082     NOP
10414  0100     MOVLB 0x0
10416  8377     BSF hrs, 1, BANKED
10418  0E3D     MOVLW 0x3D
1041A  0100     MOVLB 0x0
1041C  25F1     ADDWF bcd_hrs, W, BANKED
1041E  6EF6     MOVWF 0xFF6, ACCESS
10420  6AF7     CLRF 0xFF7, ACCESS
10422  0EFD     MOVLW 0xFD
10424  22F7     ADDWFC 0xFF7, F, ACCESS
10426  6AF8     CLRF 0xFF8, ACCESS
10428  0E00     MOVLW 0x0
1042A  22F8     ADDWFC 0xFF8, F, ACCESS
1042C  0008     TBLRD*
1042E  A0F5     BTFSS 0xFF5, 0, ACCESS
10430  EF1C     GOTO 0x10438
10432  F082     NOP
10434  EF1E     GOTO 0x1043C
10436  F082     NOP
10438  EF20     GOTO 0x10440
1043A  F082     NOP
1043C  0100     MOVLB 0x0
1043E  8177     BSF hrs, 0, BANKED
332:                   UPDATE_HRS10(bcd_hrs10);
10440  0E3D     MOVLW 0x3D
10442  0100     MOVLB 0x0
10444  25F2     ADDWF bcd_hrs10, W, BANKED
10446  6EF6     MOVWF 0xFF6, ACCESS
10448  6AF7     CLRF 0xFF7, ACCESS
1044A  0EFD     MOVLW 0xFD
1044C  22F7     ADDWFC 0xFF7, F, ACCESS
1044E  6AF8     CLRF 0xFF8, ACCESS
10450  0E00     MOVLW 0x0
10452  22F8     ADDWFC 0xFF8, F, ACCESS
10454  0008     TBLRD*
10456  ACF5     BTFSS 0xFF5, 6, ACCESS
10458  EF30     GOTO 0x10460
1045A  F082     NOP
1045C  EF32     GOTO 0x10464
1045E  F082     NOP
10460  EF34     GOTO 0x10468
10462  F082     NOP
10464  0100     MOVLB 0x0
10466  8D76     BSF hrs10, 6, BANKED
10468  0E3D     MOVLW 0x3D
1046A  0100     MOVLB 0x0
1046C  25F2     ADDWF bcd_hrs10, W, BANKED
1046E  6EF6     MOVWF 0xFF6, ACCESS
10470  6AF7     CLRF 0xFF7, ACCESS
10472  0EFD     MOVLW 0xFD
10474  22F7     ADDWFC 0xFF7, F, ACCESS
10476  6AF8     CLRF 0xFF8, ACCESS
10478  0E00     MOVLW 0x0
1047A  22F8     ADDWFC 0xFF8, F, ACCESS
1047C  0008     TBLRD*
1047E  AAF5     BTFSS 0xFF5, 5, ACCESS
10480  EF44     GOTO 0x10488
10482  F082     NOP
10484  EF46     GOTO 0x1048C
10486  F082     NOP
10488  EF48     GOTO 0x10490
1048A  F082     NOP
1048C  0100     MOVLB 0x0
1048E  8B76     BSF hrs10, 5, BANKED
10490  0E3D     MOVLW 0x3D
10492  0100     MOVLB 0x0
10494  25F2     ADDWF bcd_hrs10, W, BANKED
10496  6EF6     MOVWF 0xFF6, ACCESS
10498  6AF7     CLRF 0xFF7, ACCESS
1049A  0EFD     MOVLW 0xFD
1049C  22F7     ADDWFC 0xFF7, F, ACCESS
1049E  6AF8     CLRF 0xFF8, ACCESS
104A0  0E00     MOVLW 0x0
104A2  22F8     ADDWFC 0xFF8, F, ACCESS
104A4  0008     TBLRD*
104A6  A8F5     BTFSS 0xFF5, 4, ACCESS
104A8  EF58     GOTO 0x104B0
104AA  F082     NOP
104AC  EF5A     GOTO 0x104B4
104AE  F082     NOP
104B0  EF5C     GOTO 0x104B8
104B2  F082     NOP
104B4  0100     MOVLB 0x0
104B6  8976     BSF hrs10, 4, BANKED
104B8  0E3D     MOVLW 0x3D
104BA  0100     MOVLB 0x0
104BC  25F2     ADDWF bcd_hrs10, W, BANKED
104BE  6EF6     MOVWF 0xFF6, ACCESS
104C0  6AF7     CLRF 0xFF7, ACCESS
104C2  0EFD     MOVLW 0xFD
104C4  22F7     ADDWFC 0xFF7, F, ACCESS
104C6  6AF8     CLRF 0xFF8, ACCESS
104C8  0E00     MOVLW 0x0
104CA  22F8     ADDWFC 0xFF8, F, ACCESS
104CC  0008     TBLRD*
104CE  A6F5     BTFSS 0xFF5, 3, ACCESS
104D0  EF6C     GOTO 0x104D8
104D2  F082     NOP
104D4  EF6E     GOTO 0x104DC
104D6  F082     NOP
104D8  EF70     GOTO 0x104E0
104DA  F082     NOP
104DC  0100     MOVLB 0x0
104DE  8776     BSF hrs10, 3, BANKED
104E0  0E3D     MOVLW 0x3D
104E2  0100     MOVLB 0x0
104E4  25F2     ADDWF bcd_hrs10, W, BANKED
104E6  6EF6     MOVWF 0xFF6, ACCESS
104E8  6AF7     CLRF 0xFF7, ACCESS
104EA  0EFD     MOVLW 0xFD
104EC  22F7     ADDWFC 0xFF7, F, ACCESS
104EE  6AF8     CLRF 0xFF8, ACCESS
104F0  0E00     MOVLW 0x0
104F2  22F8     ADDWFC 0xFF8, F, ACCESS
104F4  0008     TBLRD*
104F6  A4F5     BTFSS 0xFF5, 2, ACCESS
104F8  EF80     GOTO 0x10500
104FA  F082     NOP
104FC  EF82     GOTO 0x10504
104FE  F082     NOP
10500  EF84     GOTO 0x10508
10502  F082     NOP
10504  0100     MOVLB 0x0
10506  8576     BSF hrs10, 2, BANKED
10508  0E3D     MOVLW 0x3D
1050A  0100     MOVLB 0x0
1050C  25F2     ADDWF bcd_hrs10, W, BANKED
1050E  6EF6     MOVWF 0xFF6, ACCESS
10510  6AF7     CLRF 0xFF7, ACCESS
10512  0EFD     MOVLW 0xFD
10514  22F7     ADDWFC 0xFF7, F, ACCESS
10516  6AF8     CLRF 0xFF8, ACCESS
10518  0E00     MOVLW 0x0
1051A  22F8     ADDWFC 0xFF8, F, ACCESS
1051C  0008     TBLRD*
1051E  A2F5     BTFSS 0xFF5, 1, ACCESS
10520  EF94     GOTO 0x10528
10522  F082     NOP
10524  EF96     GOTO 0x1052C
10526  F082     NOP
10528  EF98     GOTO 0x10530
1052A  F082     NOP
1052C  0100     MOVLB 0x0
1052E  8376     BSF hrs10, 1, BANKED
10530  0E3D     MOVLW 0x3D
10532  0100     MOVLB 0x0
10534  25F2     ADDWF bcd_hrs10, W, BANKED
10536  6EF6     MOVWF 0xFF6, ACCESS
10538  6AF7     CLRF 0xFF7, ACCESS
1053A  0EFD     MOVLW 0xFD
1053C  22F7     ADDWFC 0xFF7, F, ACCESS
1053E  6AF8     CLRF 0xFF8, ACCESS
10540  0E00     MOVLW 0x0
10542  22F8     ADDWFC 0xFF8, F, ACCESS
10544  0008     TBLRD*
10546  A0F5     BTFSS 0xFF5, 0, ACCESS
10548  EFA8     GOTO 0x10550
1054A  F082     NOP
1054C  EFAA     GOTO 0x10554
1054E  F082     NOP
10550  EFAC     GOTO 0x10558
10552  F082     NOP
10554  0100     MOVLB 0x0
10556  8176     BSF hrs10, 0, BANKED
333:           
334:                   /* update displayed time */
335:                   for (pwm = 0; pwm < 50; pwm++){
10558  0E00     MOVLW 0x0
1055A  0100     MOVLB 0x0
1055C  6FEE     MOVWF pwm, BANKED
336:                       if (pwm < 25){
1055E  0E19     MOVLW 0x19
10560  61EE     CPFSLT pwm, BANKED
10562  EFB5     GOTO 0x1056A
10564  F082     NOP
10566  EFB7     GOTO 0x1056E
10568  F082     NOP
1056A  EF78     GOTO 0x106F0
1056C  F083     NOP
337:                           SET_MIN;
1056E  AD79     BTFSS min, 6, BANKED
10570  D002     BRA 0x576
10572  8EBD     BSF 0xFBD, 7, ACCESS
10574  D001     BRA 0x578
10576  9EBD     BCF 0xFBD, 7, ACCESS
10578  0100     MOVLB 0x0
1057A  AB79     BTFSS min, 5, BANKED
1057C  D002     BRA 0x582
1057E  8CBD     BSF 0xFBD, 6, ACCESS
10580  D001     BRA 0x584
10582  9CBD     BCF 0xFBD, 6, ACCESS
10584  0100     MOVLB 0x0
10586  A979     BTFSS min, 4, BANKED
10588  D002     BRA 0x58E
1058A  8ABD     BSF 0xFBD, 5, ACCESS
1058C  D001     BRA 0x590
1058E  9ABD     BCF 0xFBD, 5, ACCESS
10590  0100     MOVLB 0x0
10592  A779     BTFSS min, 3, BANKED
10594  D002     BRA 0x59A
10596  88BD     BSF 0xFBD, 4, ACCESS
10598  D001     BRA 0x59C
1059A  98BD     BCF 0xFBD, 4, ACCESS
1059C  0100     MOVLB 0x0
1059E  A579     BTFSS min, 2, BANKED
105A0  D002     BRA 0x5A6
105A2  8EBC     BSF 0xFBC, 7, ACCESS
105A4  D001     BRA 0x5A8
105A6  9EBC     BCF 0xFBC, 7, ACCESS
105A8  0100     MOVLB 0x0
105AA  A379     BTFSS min, 1, BANKED
105AC  D002     BRA 0x5B2
105AE  8CBC     BSF 0xFBC, 6, ACCESS
105B0  D001     BRA 0x5B4
105B2  9CBC     BCF 0xFBC, 6, ACCESS
105B4  0100     MOVLB 0x0
105B6  A179     BTFSS min, 0, BANKED
105B8  D002     BRA 0x5BE
105BA  8ABC     BSF 0xFBC, 5, ACCESS
105BC  D001     BRA 0x5C0
105BE  9ABC     BCF 0xFBC, 5, ACCESS
338:                           SET_MIN10;
105C0  0100     MOVLB 0x0
105C2  AD78     BTFSS min10, 6, BANKED
105C4  D002     BRA 0x5CA
105C6  8CBF     BSF 0xFBF, 6, ACCESS
105C8  D001     BRA 0x5CC
105CA  9CBF     BCF 0xFBF, 6, ACCESS
105CC  0100     MOVLB 0x0
105CE  AB78     BTFSS min10, 5, BANKED
105D0  D002     BRA 0x5D6
105D2  8ABF     BSF 0xFBF, 5, ACCESS
105D4  D001     BRA 0x5D8
105D6  9ABF     BCF 0xFBF, 5, ACCESS
105D8  0100     MOVLB 0x0
105DA  A978     BTFSS min10, 4, BANKED
105DC  D002     BRA 0x5E2
105DE  88BF     BSF 0xFBF, 4, ACCESS
105E0  D001     BRA 0x5E4
105E2  98BF     BCF 0xFBF, 4, ACCESS
105E4  0100     MOVLB 0x0
105E6  A778     BTFSS min10, 3, BANKED
105E8  D002     BRA 0x5EE
105EA  86BB     BSF 0xFBB, 3, ACCESS
105EC  D001     BRA 0x5F0
105EE  96BB     BCF 0xFBB, 3, ACCESS
105F0  0100     MOVLB 0x0
105F2  A578     BTFSS min10, 2, BANKED
105F4  D002     BRA 0x5FA
105F6  84BB     BSF 0xFBB, 2, ACCESS
105F8  D001     BRA 0x5FC
105FA  94BB     BCF 0xFBB, 2, ACCESS
105FC  0100     MOVLB 0x0
105FE  A378     BTFSS min10, 1, BANKED
10600  D002     BRA 0x606
10602  82BB     BSF 0xFBB, 1, ACCESS
10604  D001     BRA 0x608
10606  92BB     BCF 0xFBB, 1, ACCESS
10608  0100     MOVLB 0x0
1060A  A178     BTFSS min10, 0, BANKED
1060C  D002     BRA 0x612
1060E  80BB     BSF 0xFBB, 0, ACCESS
10610  D001     BRA 0x614
10612  90BB     BCF 0xFBB, 0, ACCESS
339:                           SET_HRS;
10614  0100     MOVLB 0x0
10616  AD77     BTFSS hrs, 6, BANKED
10618  D002     BRA 0x61E
1061A  82BC     BSF 0xFBC, 1, ACCESS
1061C  D001     BRA 0x620
1061E  92BC     BCF 0xFBC, 1, ACCESS
10620  0100     MOVLB 0x0
10622  AB77     BTFSS hrs, 5, BANKED
10624  D002     BRA 0x62A
10626  80BF     BSF 0xFBF, 0, ACCESS
10628  D001     BRA 0x62C
1062A  90BF     BCF 0xFBF, 0, ACCESS
1062C  0100     MOVLB 0x0
1062E  A977     BTFSS hrs, 4, BANKED
10630  D002     BRA 0x636
10632  82BF     BSF 0xFBF, 1, ACCESS
10634  D001     BRA 0x638
10636  92BF     BCF 0xFBF, 1, ACCESS
10638  0100     MOVLB 0x0
1063A  A777     BTFSS hrs, 3, BANKED
1063C  D002     BRA 0x642
1063E  84BF     BSF 0xFBF, 2, ACCESS
10640  D001     BRA 0x644
10642  94BF     BCF 0xFBF, 2, ACCESS
10644  0100     MOVLB 0x0
10646  A577     BTFSS hrs, 2, BANKED
10648  D002     BRA 0x64E
1064A  86BF     BSF 0xFBF, 3, ACCESS
1064C  D001     BRA 0x650
1064E  96BF     BCF 0xFBF, 3, ACCESS
10650  0100     MOVLB 0x0
10652  A377     BTFSS hrs, 1, BANKED
10654  D002     BRA 0x65A
10656  84BC     BSF 0xFBC, 2, ACCESS
10658  D001     BRA 0x65C
1065A  94BC     BCF 0xFBC, 2, ACCESS
1065C  0100     MOVLB 0x0
1065E  A177     BTFSS hrs, 0, BANKED
10660  D002     BRA 0x666
10662  82BD     BSF 0xFBD, 1, ACCESS
10664  D001     BRA 0x668
10666  92BD     BCF 0xFBD, 1, ACCESS
340:                           if (bcd_hrs10 != 0){
10668  0100     MOVLB 0x0
1066A  51F2     MOVF bcd_hrs10, W, BANKED
1066C  B4D8     BTFSC 0xFD8, 2, ACCESS
1066E  EF3B     GOTO 0x10676
10670  F083     NOP
10672  EF3D     GOTO 0x1067A
10674  F083     NOP
10676  EF68     GOTO 0x106D0
10678  F083     NOP
341:                               SET_HRS10;
1067A  AD76     BTFSS hrs10, 6, BANKED
1067C  D002     BRA 0x682
1067E  80BA     BSF 0xFBA, 0, ACCESS
10680  D001     BRA 0x684
10682  90BA     BCF 0xFBA, 0, ACCESS
10684  0100     MOVLB 0x0
10686  AB76     BTFSS hrs10, 5, BANKED
10688  D002     BRA 0x68E
1068A  82BA     BSF 0xFBA, 1, ACCESS
1068C  D001     BRA 0x690
1068E  92BA     BCF 0xFBA, 1, ACCESS
10690  0100     MOVLB 0x0
10692  A976     BTFSS hrs10, 4, BANKED
10694  D002     BRA 0x69A
10696  84BA     BSF 0xFBA, 2, ACCESS
10698  D001     BRA 0x69C
1069A  94BA     BCF 0xFBA, 2, ACCESS
1069C  0100     MOVLB 0x0
1069E  A776     BTFSS hrs10, 3, BANKED
106A0  D002     BRA 0x6A6
106A2  86BA     BSF 0xFBA, 3, ACCESS
106A4  D001     BRA 0x6A8
106A6  96BA     BCF 0xFBA, 3, ACCESS
106A8  0100     MOVLB 0x0
106AA  A576     BTFSS hrs10, 2, BANKED
106AC  D002     BRA 0x6B2
106AE  88BA     BSF 0xFBA, 4, ACCESS
106B0  D001     BRA 0x6B4
106B2  98BA     BCF 0xFBA, 4, ACCESS
106B4  0100     MOVLB 0x0
106B6  A376     BTFSS hrs10, 1, BANKED
106B8  D002     BRA 0x6BE
106BA  8ABA     BSF 0xFBA, 5, ACCESS
106BC  D001     BRA 0x6C0
106BE  9ABA     BCF 0xFBA, 5, ACCESS
106C0  0100     MOVLB 0x0
106C2  A176     BTFSS hrs10, 0, BANKED
106C4  D002     BRA 0x6CA
106C6  80BE     BSF 0xFBE, 0, ACCESS
106C8  D001     BRA 0x6CC
106CA  90BE     BCF 0xFBE, 0, ACCESS
342:                           } 
106CC  EFB0     GOTO 0x10760
106CE  F083     NOP
343:                           else{
106D0  90BA     BCF 0xFBA, 0, ACCESS
106D2  F000     NOP
106D4  92BA     BCF 0xFBA, 1, ACCESS
106D6  F000     NOP
106D8  94BA     BCF 0xFBA, 2, ACCESS
106DA  F000     NOP
106DC  96BA     BCF 0xFBA, 3, ACCESS
106DE  F000     NOP
106E0  98BA     BCF 0xFBA, 4, ACCESS
106E2  F000     NOP
106E4  9ABA     BCF 0xFBA, 5, ACCESS
106E6  F000     NOP
106E8  90BE     BCF 0xFBE, 0, ACCESS
106EA  F000     NOP
106EC  EFB0     GOTO 0x10760
106EE  F083     NOP
344:                               RESET_HRS10;
345:                           }
346:                       }else{
106F0  9EBD     BCF 0xFBD, 7, ACCESS
106F2  F000     NOP
106F4  9CBD     BCF 0xFBD, 6, ACCESS
106F6  F000     NOP
106F8  9ABD     BCF 0xFBD, 5, ACCESS
106FA  F000     NOP
106FC  98BD     BCF 0xFBD, 4, ACCESS
106FE  F000     NOP
10700  9EBC     BCF 0xFBC, 7, ACCESS
10702  F000     NOP
10704  9CBC     BCF 0xFBC, 6, ACCESS
10706  F000     NOP
10708  9ABC     BCF 0xFBC, 5, ACCESS
1070A  F000     NOP
347:                           RESET_MIN;
348:                           RESET_MIN10;
1070C  9CBF     BCF 0xFBF, 6, ACCESS
1070E  F000     NOP
10710  9ABF     BCF 0xFBF, 5, ACCESS
10712  F000     NOP
10714  98BF     BCF 0xFBF, 4, ACCESS
10716  F000     NOP
10718  96BB     BCF 0xFBB, 3, ACCESS
1071A  F000     NOP
1071C  94BB     BCF 0xFBB, 2, ACCESS
1071E  F000     NOP
10720  92BB     BCF 0xFBB, 1, ACCESS
10722  F000     NOP
10724  90BB     BCF 0xFBB, 0, ACCESS
10726  F000     NOP
349:                           RESET_HRS;
10728  92BC     BCF 0xFBC, 1, ACCESS
1072A  F000     NOP
1072C  90BF     BCF 0xFBF, 0, ACCESS
1072E  F000     NOP
10730  92BF     BCF 0xFBF, 1, ACCESS
10732  F000     NOP
10734  94BF     BCF 0xFBF, 2, ACCESS
10736  F000     NOP
10738  96BF     BCF 0xFBF, 3, ACCESS
1073A  F000     NOP
1073C  94BC     BCF 0xFBC, 2, ACCESS
1073E  F000     NOP
10740  92BD     BCF 0xFBD, 1, ACCESS
10742  F000     NOP
350:                           RESET_HRS10;
10744  90BA     BCF 0xFBA, 0, ACCESS
10746  F000     NOP
10748  92BA     BCF 0xFBA, 1, ACCESS
1074A  F000     NOP
1074C  94BA     BCF 0xFBA, 2, ACCESS
1074E  F000     NOP
10750  96BA     BCF 0xFBA, 3, ACCESS
10752  F000     NOP
10754  98BA     BCF 0xFBA, 4, ACCESS
10756  F000     NOP
10758  9ABA     BCF 0xFBA, 5, ACCESS
1075A  F000     NOP
1075C  90BE     BCF 0xFBE, 0, ACCESS
1075E  F000     NOP
351:                       }
352:                   }
10760  0100     MOVLB 0x0
10762  2BEE     INCF pwm, F, BANKED
10764  0E31     MOVLW 0x31
10766  65EE     CPFSGT pwm, BANKED
10768  EFB8     GOTO 0x10770
1076A  F083     NOP
1076C  EFBA     GOTO 0x10774
1076E  F083     NOP
10770  EFAF     GOTO 0x1055E
10772  F082     NOP
10774  EF7C     GOTO 0x100F8
10776  F080     NOP
10778  EF0D     GOTO 0x1A
1077A  F000     NOP
353:           
354:                //if (time_has_changed_user || time_has_changed_timer){
355:           
356:                //    if (time_has_changed_user){
357:                //        time_has_changed_user = FALSE;
358:                //    }
359:           
360:                //    if (time_has_changed_timer){
361:                //        time_has_changed_timer = FALSE;
362:                //        datetime_increase_seconds(&t);
363:                //    }
364:           
365:                //        bcd_min   = bin_2_bcd(t.min) & 0x0F;
366:                //        bcd_min10 = bin_2_bcd(t.min) >> 4;
367:                //        bcd_hrs   = bin_2_bcd(t.hrs) & 0x0F;
368:                //        bcd_hrs10 = bin_2_bcd(t.hrs) >> 4;
369:                //    /* update RTC */
370:                //    // ds1307_set_time(I2C_BUS_1, I2C_ADR_DS1307, t);
371:                //    
372:           
373:                //}
374:           
375:           /* peut on mettre des interruptions sur les entrées ????? */
376:                   // if (!BTN_MIN_P)
377:                   // {
378:                   //     delay_ms (DEBOUNCE_DELAY);
379:                   //     if (!BTN_MIN_P)
380:                   //     {
381:                   //         datetime_increase_minutes(&t);
382:                   //         time_has_changed_user = TRUE;
383:                   //     }
384:                   // }
385:           
386:                   // if (!BTN_MIN_M)
387:                   // {
388:                   //     delay_ms (DEBOUNCE_DELAY);
389:                   //     if (!BTN_MIN_M)
390:                   //     {
391:                   //         datetime_decrease_minutes(&t);
392:                   //         time_has_changed_user = TRUE;
393:                   //     }
394:                   // }
395:           
396:                   // if (!BTN_HRS_P)
397:                   // {
398:                   //     delay_ms (DEBOUNCE_DELAY);
399:                   //     if (!BTN_HRS_P)
400:                   //     {
401:                   //         datetime_increase_hours(&t);
402:                   //         time_has_changed_user = TRUE;
403:                   //     }
404:                   // }
405:           
406:                   // if (!BTN_HRS_M)
407:                   // {
408:                   //     delay_ms (DEBOUNCE_DELAY);
409:                   //     if (!BTN_HRS_M)
410:                   //     {
411:                   //         datetime_decrease_hours(&t);
412:                   //         time_has_changed_user = TRUE;
413:                   //     }
414:                   // }
415:               }
416:           }
417:           
---  D:/GitHub/mcu/projects/clock_big_7seg_red_v2/interrupts_management.c  ------------------------------
1:             #include "console.h"
2:             #include "interrupts_management.h"
3:             #include "hardware_profile.h"
4:             #include "types.h"
5:             #include "pic_compiler.h"
6:             
7:             extern bool_t time_has_changed_timer;
8:             
9:             //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
10:            //--------------------------- Interrupts management ---------------------------
11:            //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
12:            // void __interrupt(irq(TMR2),high_priority) interrupt()
13:            void __interrupt() INTERRUPT_InterruptManager (void)
11698  0139     MOVLB 0x39
1169A  A793     BTFSS 0x93, 3, BANKED
1169C  EF52     GOTO 0x116A4
1169E  F08B     NOP
116A0  EF54     GOTO 0x116A8
116A2  F08B     NOP
116A4  EF5D     GOTO 0x116BA
116A6  F08B     NOP
116A8  A7A3     BTFSS 0xA3, 3, BANKED
116AA  EF59     GOTO 0x116B2
116AC  F08B     NOP
116AE  EF5B     GOTO 0x116B6
116B0  F08B     NOP
116B2  EF5D     GOTO 0x116BA
116B4  F08B     NOP
116B6  EFDE     GOTO 0x117BC
116B8  F08B     NOP
14:            {
15:                static u16 CntTmrIncSec = 0;
16:            
17:                /*******************************************************/
18:                /* UART interrupt                                      */
19:                /*******************************************************/
20:                if (PIE3bits.U1RXIE == 1 && PIR3bits.U1RXIF == 1){
21:            
22:                }
23:            
24:                /*******************************************************/
25:                /* Timer 2 interrupt                                   */
26:                /*******************************************************/
27:                else if (TMR2IE == 1 && TMR2IF == 1){
116BA  A594     BTFSS 0x94, 2, BANKED
116BC  EF62     GOTO 0x116C4
116BE  F08B     NOP
116C0  EF64     GOTO 0x116C8
116C2  F08B     NOP
116C4  EFD6     GOTO 0x117AC
116C6  F08B     NOP
116C8  A5A4     BTFSS 0xA4, 2, BANKED
116CA  EF69     GOTO 0x116D2
116CC  F08B     NOP
116CE  EF6B     GOTO 0x116D6
116D0  F08B     NOP
116D2  EFD6     GOTO 0x117AC
116D4  F08B     NOP
28:            
29:                    /* clear timer interrupt */
30:                    TMR2IF = 0;
116D6  95A4     BCF 0xA4, 2, BANKED
31:            
32:                    CntTmrIncSec++;
116D8  0100     MOVLB 0x0
116DA  4B6F     INFSNZ CntTmrIncSec, F, BANKED
116DC  2B70     INCF 0x70, F, BANKED
33:            
34:                    if (CntTmrIncSec == 1249){
116DE  0EE1     MOVLW 0xE1
116E0  196F     XORWF CntTmrIncSec, W, BANKED
116E2  E107     BNZ 0x16F2
116E4  0E04     MOVLW 0x4
116E6  1970     XORWF 0x70, W, BANKED
116E8  A4D8     BTFSS 0xFD8, 2, ACCESS
116EA  EF79     GOTO 0x116F2
116EC  F08B     NOP
116EE  EF7B     GOTO 0x116F6
116F0  F08B     NOP
116F2  EF9F     GOTO 0x1173E
116F4  F08B     NOP
35:                        LED_SEC = !LED_SEC;
116F6  AEBF     BTFSS 0xFBF, 7, ACCESS
116F8  EF80     GOTO 0x11700
116FA  F08B     NOP
116FC  EF84     GOTO 0x11708
116FE  F08B     NOP
11700  6A01     CLRF __pcstackCOMRAM, ACCESS
11702  2A01     INCF __pcstackCOMRAM, F, ACCESS
11704  EF85     GOTO 0x1170A
11706  F08B     NOP
11708  6A01     CLRF __pcstackCOMRAM, ACCESS
1170A  3201     RRCF __pcstackCOMRAM, F, ACCESS
1170C  3201     RRCF __pcstackCOMRAM, F, ACCESS
1170E  50BF     MOVF 0xFBF, W, ACCESS
11710  1801     XORWF __pcstackCOMRAM, W, ACCESS
11712  0B7F     ANDLW 0x7F
11714  1801     XORWF __pcstackCOMRAM, W, ACCESS
11716  6EBF     MOVWF 0xFBF, ACCESS
36:                        LED_ERROR = !LED_ERROR;
11718  A4BE     BTFSS 0xFBE, 2, ACCESS
1171A  EF91     GOTO 0x11722
1171C  F08B     NOP
1171E  EF95     GOTO 0x1172A
11720  F08B     NOP
11722  6A01     CLRF __pcstackCOMRAM, ACCESS
11724  2A01     INCF __pcstackCOMRAM, F, ACCESS
11726  EF96     GOTO 0x1172C
11728  F08B     NOP
1172A  6A01     CLRF __pcstackCOMRAM, ACCESS
1172C  4601     RLNCF __pcstackCOMRAM, F, ACCESS
1172E  4601     RLNCF __pcstackCOMRAM, F, ACCESS
11730  50BE     MOVF 0xFBE, W, ACCESS
11732  1801     XORWF __pcstackCOMRAM, W, ACCESS
11734  0BFB     ANDLW 0xFB
11736  1801     XORWF __pcstackCOMRAM, W, ACCESS
11738  6EBE     MOVWF 0xFBE, ACCESS
37:                    }
1173A  EFDE     GOTO 0x117BC
1173C  F08B     NOP
38:                    else if (CntTmrIncSec == 2499)
1173E  0EC3     MOVLW 0xC3
11740  196F     XORWF CntTmrIncSec, W, BANKED
11742  E107     BNZ 0x1752
11744  0E09     MOVLW 0x9
11746  1970     XORWF 0x70, W, BANKED
11748  A4D8     BTFSS 0xFD8, 2, ACCESS
1174A  EFA9     GOTO 0x11752
1174C  F08B     NOP
1174E  EFAB     GOTO 0x11756
11750  F08B     NOP
11752  EFDE     GOTO 0x117BC
11754  F08B     NOP
39:                    {
40:                        time_has_changed_timer = TRUE;
11756  0E01     MOVLW 0x1
11758  6F7A     MOVWF time_has_changed_timer, BANKED
41:                        LED_SEC = !LED_SEC;
1175A  AEBF     BTFSS 0xFBF, 7, ACCESS
1175C  EFB2     GOTO 0x11764
1175E  F08B     NOP
11760  EFB6     GOTO 0x1176C
11762  F08B     NOP
11764  6A01     CLRF __pcstackCOMRAM, ACCESS
11766  2A01     INCF __pcstackCOMRAM, F, ACCESS
11768  EFB7     GOTO 0x1176E
1176A  F08B     NOP
1176C  6A01     CLRF __pcstackCOMRAM, ACCESS
1176E  3201     RRCF __pcstackCOMRAM, F, ACCESS
11770  3201     RRCF __pcstackCOMRAM, F, ACCESS
11772  50BF     MOVF 0xFBF, W, ACCESS
11774  1801     XORWF __pcstackCOMRAM, W, ACCESS
11776  0B7F     ANDLW 0x7F
11778  1801     XORWF __pcstackCOMRAM, W, ACCESS
1177A  6EBF     MOVWF 0xFBF, ACCESS
42:                        LED_ERROR = !LED_ERROR;
1177C  A4BE     BTFSS 0xFBE, 2, ACCESS
1177E  EFC3     GOTO 0x11786
11780  F08B     NOP
11782  EFC7     GOTO 0x1178E
11784  F08B     NOP
11786  6A01     CLRF __pcstackCOMRAM, ACCESS
11788  2A01     INCF __pcstackCOMRAM, F, ACCESS
1178A  EFC8     GOTO 0x11790
1178C  F08B     NOP
1178E  6A01     CLRF __pcstackCOMRAM, ACCESS
11790  4601     RLNCF __pcstackCOMRAM, F, ACCESS
11792  4601     RLNCF __pcstackCOMRAM, F, ACCESS
11794  50BE     MOVF 0xFBE, W, ACCESS
11796  1801     XORWF __pcstackCOMRAM, W, ACCESS
11798  0BFB     ANDLW 0xFB
1179A  1801     XORWF __pcstackCOMRAM, W, ACCESS
1179C  6EBE     MOVWF 0xFBE, ACCESS
43:                        CntTmrIncSec = 0;
1179E  0E00     MOVLW 0x0
117A0  0100     MOVLB 0x0
117A2  6F70     MOVWF 0x70, BANKED
117A4  0E00     MOVLW 0x0
117A6  6F6F     MOVWF CntTmrIncSec, BANKED
117A8  EFDE     GOTO 0x117BC
117AA  F08B     NOP
44:                    }
45:                }
46:            
47:                /*******************************************************/
48:                /* I2C Error                                           */
49:                /*******************************************************/
50:                else if (PIE3bits.I2C1EIE == 1 && PIR3bits.I2C1EIF == 1){
117AC  A593     BTFSS 0x93, 2, BANKED
117AE  EFDB     GOTO 0x117B6
117B0  F08B     NOP
117B2  EFDD     GOTO 0x117BA
117B4  F08B     NOP
117B6  EFDE     GOTO 0x117BC
117B8  F08B     NOP
117BA  51A3     MOVF 0xA3, W, BANKED
51:            
52:                }
53:            }
117BC  0011     RETFIE 1
---  D:/GitHub/mcu/libraries/lib_pic/uart.c  ------------------------------------------------------------
1:             #include "bcd.h"
2:             #include "date_time.h"
3:             #include "delays.h"
4:             #include "hardware_profile.h"
5:             #include "math.h"
6:             #include "uart.h"
7:             
8:             extern UART_ID UART_ID_LOG;
9:             
10:            //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:            //----------------------------- UART Configuration ----------------------------
12:            //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:            result_t uart_init (UART_ID uart_id, u32 baudrate)
14:            {
15:                #if defined (_18F252)
16:            
17:                    SPBRG = GetSystemClock() / (16.0 * baudrate) - 1;
18:            
19:                    if (uart_id == UART_ID_1){
20:                        // high speed mode
21:                        TXSTAbits.BRGH = 1;
22:            
23:                        // enable transmittion
24:                        TXSTAbits.TXEN = 1;
25:            
26:                        // Enable port
27:                        RCSTAbits.SPEN = 1;
28:            
29:                        // continuous reception
30:                        RCSTAbits.CREN = 1;
31:            
32:                        // Enable Recieve Interrupts
33:                        PIR1bits.RCIF = 0;
34:                        PIE1bits.RCIE = 1;
35:                    }
36:                    else{
37:                        return ERROR;
38:                    }
39:                    
40:                #elif defined (_18F26K42) || defined (_18F57K42) || defined (_18F57Q43)
41:            
42:                    if (uart_id == UART_ID_1){
43:                        /* set baudrate */
44:                        U1BRGH = 0;
45:                        U1BRGL = GetSystemClock() / (4.0 * baudrate) - 1;
46:            
47:                        /* 8 bits, async mode, high speed mode */
48:                        U1CON0 = 0;
49:                        U1CON0bits.BRGS = 1;
50:            
51:                        /* enable serial port */
52:                        U1CON1 = 0;
53:                        U1CON1bits.ON = 1;
54:            
55:                        /* 1 stop bit, normal polarity */
56:                        U1CON2 = 0;
57:            
58:                        U1FIFO = 0;
59:            
60:                        /* Auto-baud not enabled */
61:                        U1UIR = 0x00; 
62:                        
63:                        U1ERRIR = 0x00;
64:                        U1ERRIE = 0x00;
65:            
66:                        /* enable transmittion & reception */
67:                        U1CON0bits.TXEN = 1;
68:                        U1CON0bits.RXEN = 1;
69:            
70:                        /* enable receive interrupt */
71:                        U1RXIE = 1;
72:                    }
73:                    else{
74:                        return ERROR;
75:                    }
76:            
77:                #elif defined(__PIC24F__) || defined(__dsPIC33F__)
78:            
79:                    u16 UART_BRG = (u16)(GetInstructionClock() / (4 * (baudrate + 1)));
80:            
81:                    //===============================================================
82:                    if (uart_id == UART_ID_1){
83:            
84:                        // Enable UART
85:                        U1MODEbits.UARTEN = 1;
86:            
87:                        // Use high speed mode
88:                        U1MODEbits.BRGH = 1;
89:            
90:                        // Enable Transmission
91:                        U1STAbits.UTXEN = 1;
92:            
93:                        // Fcy/(4*Baud)-1; // 115200 bauds @ 40MIPS (actually = 116 618)
94:                        U1BRG = UART_BRG;
95:            
96:                        // Clear the Receive Interrupt Flag
97:                        IFS0bits.U1RXIF = 0;
98:            
99:                        // Enable Recieve Interrupts
100:                       if ((opt&UART_EN_IT_RX) == UART_EN_IT_RX){
101:                           IEC0bits.U1RXIE = 1;
102:                       }
103:           
104:                       // set it for dma
105:                       if ((opt&UART_EN_IT_DMA) == UART_EN_IT_DMA){
106:                           U1STAbits.UTXISEL0 = 0;             // Interrupt after one Tx character is transmitted
107:                           U1STAbits.UTXISEL1 = 0;
108:                           U1STAbits.URXISEL  = 0;             // Interrupt after one RX character is received
109:                       }
110:                       
111:                   //===============================================================
112:                   #ifdef _U2TXIF
113:                   }else if (uart_id == UART_ID_2){
114:           
115:                       // Enable UART
116:                       U2MODEbits.UARTEN = 1;
117:           
118:                       // Use high speed mode
119:                       U2MODEbits.BRGH = 1;
120:           
121:                       // Enable Transmission
122:                       U2STAbits.UTXEN = 1;
123:           
124:                       // Fcy/(4*Baud)-1; // 115200 bauds @ 40MIPS (actually = 116 618)
125:                       U2BRG = UART_BRG;
126:           
127:                       // Clear the Receive Interrupt Flag
128:                       IFS1bits.U2RXIF = 0;
129:           
130:                       // Enable Recieve Interrupts
131:                       if ((opt&UART_EN_IT_RX) == UART_EN_IT_RX){
132:                           IEC1bits.U2RXIE = 1;
133:                       }
134:           
135:                       // set it for dma
136:                       if ((opt&UART_EN_IT_DMA) == UART_EN_IT_DMA){
137:                           U2STAbits.UTXISEL0 = 0;             // Interrupt after one Tx character is transmitted
138:                           U2STAbits.UTXISEL1 = 0;
139:                           U2STAbits.URXISEL  = 0;             // Interrupt after one RX character is received
140:                       }
141:                   #endif
142:                       
143:                   //===============================================================
144:                   #ifdef _U3TXIF
145:                   }else if (uart_id == UART_ID_3){
146:                       
147:                       // Enable UART
148:                       U3MODEbits.UARTEN = 1;
149:           
150:                       // Use high speed mode
151:                       U3MODEbits.BRGH = 1;
152:           
153:                       // Enable Transmission
154:                       U2STAbits.UTXEN = 1;
155:           
156:                       // Fcy/(4*Baud)-1; // 115200 bauds @ 40MIPS (actually = 116 618)
157:                       U2BRG = UART_BRG;
158:           
159:                       // Clear the Receive Interrupt Flag
160:                       IFS1bits.U2RXIF = 0;
161:           
162:                       // Enable Recieve Interrupts
163:                       if ((opt&UART_EN_IT_RX) == UART_EN_IT_RX){
164:                           IEC1bits.U2RXIE = 1;
165:                       }
166:           
167:                       // set it for dma
168:                       if ((opt&UART_EN_IT_DMA) == UART_EN_IT_DMA){
169:                           U2STAbits.UTXISEL0 = 0;             // Interrupt after one Tx character is transmitted
170:                           U2STAbits.UTXISEL1 = 0;
171:                           U2STAbits.URXISEL  = 0;             // Interrupt after one RX character is received
172:                       }
173:                   #endif
174:           
175:                   //===============================================================
176:                   }else{
177:                       return ERROR;
178:                   }
179:           
180:               #else
181:                   #error -- processor ID not specified in generic header file
182:               #endif
183:           
184:               return SUCCESS;
185:           }
186:           
187:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
188:           //--------------------- Transmit one byte (used by printf) --------------------
189:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
190:           void putch(char txData)
12038  6E04     MOVWF txData, ACCESS
191:           {
192:               uart_write(UART_ID_LOG, txData);
1203C  F010     NOP
1203E  F002     NOP
12040  0E00     MOVLW 0x0
12042  ECFA     CALL 0x11FF4, 0
12044  F08F     NOP
193:           }
12046  0012     RETURN 0
194:           
195:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
196:           //----------------------------- Transmit one byte -----------------------------
197:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
198:           result_t uart_write (UART_ID uart_id, u8 data)
11FF4  6E03     MOVWF uart_id, ACCESS
199:           {
200:               #if defined (_18F252)
201:           
202:                   if (uart_id == UART_ID_1){
203:                       /* wait for the buffer to be empty */
204:                       while(!TXSTAbits.TRMT);         
205:           
206:                       /* send data */
207:                       TXREG = data;                   
208:                   }
209:                   else{
210:                       return ERROR;
211:                   }
212:           
213:               #elif defined (_18F26K42) || defined (_18F57K42)
214:           
215:                   if (uart_id == UART_ID_1){
11FF6  5003     MOVF uart_id, W, ACCESS
11FF8  A4D8     BTFSS 0xFD8, 2, ACCESS
11FFA  EF01     GOTO 0x12002
11FFC  F090     NOP
11FFE  EF03     GOTO 0x12006
12000  F090     NOP
12002  EF0E     GOTO 0x1201C
12004  F090     NOP
216:                       /* wait for the buffer to be empty */
217:                       while(0 == PIR3bits.U1TXIF);         
12006  0139     MOVLB 0x39
12008  A9A3     BTFSS 0xA3, 4, BANKED
1200A  EF09     GOTO 0x12012
1200C  F090     NOP
1200E  EF0B     GOTO 0x12016
12010  F090     NOP
12012  EF03     GOTO 0x12006
12014  F090     NOP
218:           
219:                       /* send data */
220:                       U1TXB = data;    
12018  F00B     NOP
1201A  FDEA     NOP
221:                   }
222:                   else{
223:                       return ERROR;
224:                   }
225:           
226:               #elif defined (_18F57Q43)
227:           
228:                   if (uart_id == UART_ID_1){
229:                       /* wait for the buffer to be empty */
230:                       while(0 == PIR4bits.U1TXIF);         
231:           
232:                       /* send data */
233:                       U1TXB = data;    
234:                   }
235:                   else{
236:                       return ERROR;
237:                   }
238:           
239:               #elif defined(__PIC24F__) || defined(__dsPIC33F__)
240:           
241:                   //===============================================================
242:                   #ifdef _U1TXIF
243:                   if (uart_id == UART_ID_1){
244:                       /* wait for the buffer to be empty */
245:                       while (!U1STAbits.TRMT);
246:           
247:                       /* send data */
248:                       U1TXREG = data;       
249:                   #endif
250:                   
251:                   //===============================================================
252:                   #ifdef _U2TXIF
253:                   }else if (uart_id == UART_ID_2){
254:                       /* wait for the buffer to be empty */
255:                       while (!U2STAbits.TRMT);
256:           
257:                       /* send data */
258:                       U2TXREG = data;        
259:                   #endif
260:               
261:                   //===============================================================
262:                   #ifdef _U3TXIF
263:                   }else if (uart_id == UART_ID_3){
264:                       /* wait for the buffer to be empty */
265:                       while (!U3STAbits.TRMT);
266:           
267:                       /* send data */
268:                       U3TXREG = data;   
269:                   #endif
270:           
271:                   //===============================================================
272:                   }else{
273:                       return ERROR;
274:                   }
275:                   
276:               #else
277:           
278:                   #error -- processor ID not specified in generic header file
279:           
280:               #endif
281:           
282:               return SUCCESS;
283:           }
1201C  0012     RETURN 0
284:           
285:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
286:           //----------------------------- Transmit a string -----------------------------
287:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
288:           result_t uart_write_string (UART_ID uart_id, const char *data)
289:           {
290:               #if defined (_18F252)
291:                   while (*data != '\0')   
292:                   {
293:                       /* wait for the buffer to be empty */
294:                       while (!TXSTAbits.TRMT); 
295:           
296:                       /* send data */
297:                       TXREG = *data++;     
298:                   }
299:           
300:               #elif defined (_18F26K42) || defined (_18F57K42) || defined (_18F57Q43)
301:           
302:                   while (*data != '\0')          
303:                   {
304:                       /* wait for the buffer to be empty */
305:                       while (U1FIFObits.TXBF); 
306:           
307:                       /* send data */
308:                       U1TXB = *data++;              
309:                   }
310:           
311:               #elif defined(__PIC24F__) || defined(__dsPIC33F__)
312:           
313:                   //===============================================================
314:                   #ifdef _U1TXIF
315:                   if (uart_id == UART_ID_1){
316:                       while (*data != '\0')
317:                       {
318:                           /* wait for the buffer to be empty */
319:                           while (!U1STAbits.TRMT);
320:           
321:                           /* send data */
322:                           U1TXREG = *data++;  
323:                       }
324:                   #endif
325:                   
326:                   //===============================================================
327:                   #ifdef _U2TXIF
328:                   }else if (uart_id == UART_ID_2){
329:                       while (*data != '\0')
330:                       {
331:                           /* wait for the buffer to be empty */
332:                           while (!U1STAbits.TRMT);
333:           
334:                           /* send data */
335:                           U1TXREG = *data++;    
336:                       }
337:                   #endif
338:               
339:                   //===============================================================
340:                   #ifdef _U3TXIF
341:                   }else if (uart_id == UART_ID_3){
342:                       while (*data != '\0')
343:                       {
344:                           /* wait for the buffer to be empty */
345:                           while (!U1STAbits.TRMT);
346:           
347:                           /* send data */
348:                           U1TXREG = *data++; 
349:                       }
350:                   #endif
351:           
352:                   //===============================================================
353:                   }else{
354:                       return ERROR;
355:                   }
356:                   
357:               #else
358:           
359:                   #error -- processor ID not specified in generic header file
360:                   
361:               #endif
362:           
363:               return SUCCESS;
364:           }
---  D:/GitHub/mcu/libraries/lib_pic/timer.c  -----------------------------------------------------------
1:             #include "timer.h"
2:             #include "types.h"
3:             
4:             #if defined(__PIC24F__) || defined(__dsPIC33F__)
5:             #include "interrupts_management.h"
6:             #endif
7:             
8:             //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9:             //--------------------- Configuration of 16 bits Timers -----------------------
10:            //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:            result_t timer_init(
117BE  6E06     MOVWF product, ACCESS
12:                TIMER_ID id, 
13:                TMR_PRESCALER prescaler, 
14:                TMR_POSTSCALER postscaler,
15:                u8 period
16:            )
17:            {
18:                if (id == TIMER_ID_0){
117C0  5006     MOVF product, W, ACCESS
117C2  A4D8     BTFSS 0xFD8, 2, ACCESS
117C4  EFE6     GOTO 0x117CC
117C6  F08B     NOP
117C8  EFE8     GOTO 0x117D0
117CA  F08B     NOP
117CC  EFEB     GOTO 0x117D6
117CE  F08B     NOP
19:                    return ERROR;
117D0  0E01     MOVLW 0x1
117D2  EF70     GOTO 0x118E0
117D4  F08C     NOP
20:                }
21:                else if (id == TIMER_ID_1){
117D6  0406     DECF product, W, ACCESS
117D8  A4D8     BTFSS 0xFD8, 2, ACCESS
117DA  EFF1     GOTO 0x117E2
117DC  F08B     NOP
117DE  EFF3     GOTO 0x117E6
117E0  F08B     NOP
117E2  EFF5     GOTO 0x117EA
117E4  F08B     NOP
117E6  EFE8     GOTO 0x117D0
117E8  F08B     NOP
22:                    return ERROR;
23:                }
24:                else if (id == TIMER_ID_2){
117EA  0E02     MOVLW 0x2
117EC  1806     XORWF product, W, ACCESS
117EE  A4D8     BTFSS 0xFD8, 2, ACCESS
117F0  EFFC     GOTO 0x117F8
117F2  F08B     NOP
117F4  EFFE     GOTO 0x117FC
117F6  F08B     NOP
117F8  EF17     GOTO 0x1182E
117FA  F08C     NOP
25:                    #if defined (_18F252)
26:            
27:                    /* Enables the TMR2 to PR2 match interrupt */
28:                    PIE1bits.TMR2IE = 1;
29:            
30:                    /* Set Prescaler */
31:                    T2CONbits.T2CKPS = prescaler;
32:            
33:                    /* set postscaler */
34:                    T2CONbits.TOUTPS = postscaler;  
35:            
36:                    /* Set timer period */
37:                    PR2 = period - 1;                    
38:                    
39:                    /* enable timer */
40:                    T2CONbits.TMR2ON = 1;  
41:            
42:                    #elif defined (_18F26K42) || defined (_18F57K42)
43:            
44:                    /* Enables the TMR2 to PR2 match interrupt */
45:                    TMR2IE = 1;
117FC  0139     MOVLB 0x39
117FE  8594     BSF 0x94, 2, BANKED
46:            
47:                    /* Set Prescaler */
48:                    T2CONbits.CKPS = prescaler;
11802  F008     NOP
11804  F005     NOP
11806  3A05     SWAPF c, F, ACCESS
11808  50AC     MOVF 0xFAC, W, ACCESS
1180A  1805     XORWF c, W, ACCESS
1180C  0B8F     ANDLW 0x8F
1180E  1805     XORWF c, W, ACCESS
11810  6EAC     MOVWF 0xFAC, ACCESS
49:            
50:                    /* set postscaler */
51:                    T2CONbits.OUTPS = postscaler;
11812  50AC     MOVF 0xFAC, W, ACCESS
11814  1803     XORWF uart_id, W, ACCESS
11816  0BF0     ANDLW 0xF0
11818  1803     XORWF uart_id, W, ACCESS
1181A  6EAC     MOVWF 0xFAC, ACCESS
52:            
53:                    /* set Fosc/4 as clock source */
54:                    T2CLKbits.CS = 1;
1181C  50AE     MOVF 0xFAE, W, ACCESS
1181E  0BF0     ANDLW 0xF0
11820  0901     IORLW 0x1
11822  6EAE     MOVWF 0xFAE, ACCESS
55:            
56:                    /* Set timer period */
57:                    PR2 = period - 1;                    
11824  0404     DECF txData, W, ACCESS
11826  6EAB     MOVWF 0xFAB, ACCESS
58:            
59:                    /* enable timer */
60:                    T2CONbits.TMR2ON = 1;  
11828  8EAC     BSF 0xFAC, 7, ACCESS
61:            
62:                    #elif defined (_18F57Q43)
63:            
64:                    /* Enables the TMR2 to PR2 match interrupt */
65:                    PIE3bits.TMR2IE = 1;
66:            
67:                    /* Set Prescaler */
68:                    T2CONbits.CKPS = prescaler;
69:            
70:                    /* set postscaler */
71:                    T2CONbits.OUTPS = postscaler;
72:            
73:                    /* set Fosc/4 as clock source */
74:                    T2CLKbits.CS = 1;
75:            
76:                    /* Set timer period */
77:                    PR2 = period - 1;                    
78:                    
79:                    /* enable timer */
80:                    T2CONbits.TMR2ON = 1;   
81:            
82:                    #else
83:                        return ERROR;
84:                    #endif
85:                }
1182A  EF6F     GOTO 0x118DE
1182C  F08C     NOP
86:                else if (id == TIMER_ID_3){
1182E  0E03     MOVLW 0x3
11830  1806     XORWF product, W, ACCESS
11832  A4D8     BTFSS 0xFD8, 2, ACCESS
11834  EF1E     GOTO 0x1183C
11836  F08C     NOP
11838  EF20     GOTO 0x11840
1183A  F08C     NOP
1183C  EF22     GOTO 0x11844
1183E  F08C     NOP
11840  EFE8     GOTO 0x117D0
11842  F08B     NOP
87:                    return ERROR;
88:                }
89:                else if (id == TIMER_ID_4){
11844  0E04     MOVLW 0x4
11846  1806     XORWF product, W, ACCESS
11848  A4D8     BTFSS 0xFD8, 2, ACCESS
1184A  EF29     GOTO 0x11852
1184C  F08C     NOP
1184E  EF2B     GOTO 0x11856
11850  F08C     NOP
11852  EF44     GOTO 0x11888
11854  F08C     NOP
90:                    #if defined (_18F26K42) || defined (_18F57K42)
91:            
92:                    /* Enables the TMR4 to PR4 match interrupt */
93:                    TMR4IE = 1;
11856  0139     MOVLB 0x39
11858  8197     BSF 0x97, 0, BANKED
94:            
95:                    /* Set Prescaler */
96:                    T4CONbits.CKPS = prescaler;
1185C  F008     NOP
1185E  F005     NOP
11860  3A05     SWAPF c, F, ACCESS
11862  50A0     MOVF 0xFA0, W, ACCESS
11864  1805     XORWF c, W, ACCESS
11866  0B8F     ANDLW 0x8F
11868  1805     XORWF c, W, ACCESS
1186A  6EA0     MOVWF 0xFA0, ACCESS
97:            
98:                    /* set postscaler */
99:                    T4CONbits.OUTPS = postscaler;
1186C  50A0     MOVF 0xFA0, W, ACCESS
1186E  1803     XORWF uart_id, W, ACCESS
11870  0BF0     ANDLW 0xF0
11872  1803     XORWF uart_id, W, ACCESS
11874  6EA0     MOVWF 0xFA0, ACCESS
100:           
101:                   /* set Fosc/4 as clock source */
102:                   T4CLKbits.CS = 1;
11876  50A2     MOVF 0xFA2, W, ACCESS
11878  0BF0     ANDLW 0xF0
1187A  0901     IORLW 0x1
1187C  6EA2     MOVWF 0xFA2, ACCESS
103:           
104:                   /* Set timer period */
105:                   PR4 = period - 1;                    
1187E  0404     DECF txData, W, ACCESS
11880  6E9F     MOVWF 0xF9F, ACCESS
106:           
107:                   /* enable timer */
108:                   T4CONbits.TMR4ON = 1;  
11882  8EA0     BSF 0xFA0, 7, ACCESS
109:           
110:                   #else
111:                       return ERROR;
112:                   #endif
113:               }
11884  EF6F     GOTO 0x118DE
11886  F08C     NOP
114:               else if (id == TIMER_ID_5){
11888  0E05     MOVLW 0x5
1188A  1806     XORWF product, W, ACCESS
1188C  A4D8     BTFSS 0xFD8, 2, ACCESS
1188E  EF4B     GOTO 0x11896
11890  F08C     NOP
11892  EF4D     GOTO 0x1189A
11894  F08C     NOP
11896  EF4F     GOTO 0x1189E
11898  F08C     NOP
1189A  EFE8     GOTO 0x117D0
1189C  F08B     NOP
115:                   return ERROR;
116:               }
117:               else if (id == TIMER_ID_6){
1189E  0E06     MOVLW 0x6
118A0  1806     XORWF product, W, ACCESS
118A2  A4D8     BTFSS 0xFD8, 2, ACCESS
118A4  EF56     GOTO 0x118AC
118A6  F08C     NOP
118A8  EF58     GOTO 0x118B0
118AA  F08C     NOP
118AC  EFE8     GOTO 0x117D0
118AE  F08B     NOP
118:                   #if defined (_18F26K42) || defined (_18F57K42)
119:           
120:                   /* Enables the TMR2 to PR2 match interrupt */
121:                   TMR6IE = 1;
118B0  0139     MOVLB 0x39
118B2  8199     BSF 0x99, 0, BANKED
122:           
123:                   /* Set Prescaler */
124:                   T6CONbits.CKPS = prescaler;
118B6  F008     NOP
118B8  F005     NOP
118BA  3A05     SWAPF c, F, ACCESS
118BC  5094     MOVF 0xF94, W, ACCESS
118BE  1805     XORWF c, W, ACCESS
118C0  0B8F     ANDLW 0x8F
118C2  1805     XORWF c, W, ACCESS
118C4  6E94     MOVWF 0xF94, ACCESS
125:           
126:                   /* set postscaler */
127:                   T6CONbits.OUTPS = postscaler;
118C6  5094     MOVF 0xF94, W, ACCESS
118C8  1803     XORWF uart_id, W, ACCESS
118CA  0BF0     ANDLW 0xF0
118CC  1803     XORWF uart_id, W, ACCESS
118CE  6E94     MOVWF 0xF94, ACCESS
128:           
129:                   /* set Fosc/4 as clock source */
130:                   T6CLKbits.CS = 1;
118D0  5096     MOVF 0xF96, W, ACCESS
118D2  0BF0     ANDLW 0xF0
118D4  0901     IORLW 0x1
118D6  6E96     MOVWF 0xF96, ACCESS
131:           
132:                   /* Set timer period */
133:                   PR6 = period - 1;                    
118D8  0404     DECF txData, W, ACCESS
118DA  6E93     MOVWF 0xF93, ACCESS
134:           
135:                   /* enable timer */
136:                   T6CONbits.TMR6ON = 1;  
118DC  8E94     BSF 0xF94, 7, ACCESS
137:           
138:                   #else
139:                       return ERROR;
140:                   #endif
141:               }
142:               else{
143:                   return ERROR;
144:               }
145:           
146:               return SUCCESS;
118DE  0E00     MOVLW 0x0
147:           }
118E0  0012     RETURN 0
148:           //=============================================================================
149:           // #if defined (TMR0IF_bit)
150:           // void timer0_init (TMR_PRESCALER scaler)
151:           // {
152:           //     // ========  ToDo  ========
153:           //     PIE1  = 0x02;                   // enable interrupt sur timer 2
154:           //     INTCON = 0xC0;                  // enable global et periph interrupt
155:           //     T0CONbits.T08BIT = 0;           // configure as a 16-bits timer
156:           //     T0CONbits.T0PS = scaler;        // set prescaler
157:           //     T0CONbits.TMR0ON = 1;           // Enable Timer
158:           //     RCONbits.IPEN = 1;              // Interruption prioritaires activées
159:           // }
160:           // #endif
161:           
162:           
163:           
164:           //=============================================================================
165:           #if defined (_T1IF) || defined (TMR1IF_bit)
166:           void timer1_init (TMR_PRESCALER prescaler, u16 timer)
167:           {
168:               #if defined(__PIC24F__) || defined(__dsPIC33F__)
169:           
170:               // Freq Timer = Fosc / Prescaler / TMR
171:               T1CONbits.TCKPS = scaler;       // Prescaler (0=1 - 1=8 - 2=64 - 3=256)
172:               IFS0bits.T1IF = 0;              // Reset Timer1 interrupt flag
173:               IPC0bits.T1IP = 6;              // priority level
174:               IEC0bits.T1IE = 1;              // Enable Timer 1 interrupt
175:               TMR1 = 0;                       // reset compteur
176:               PR1 = timer;                    // Periode du Timer 1 (64ms)
177:               T1CONbits.TON = 1;              // Lancer le Timer 1
178:           
179:               #endif
180:           }
181:           #endif
182:           
183:           
184:           //=============================================================================
185:           #if defined (_T2IF) || defined (TMR2IF_bit)
186:           void timer2_init (TMR_PRESCALER scaler, u16 timer)
187:           {
188:               #if defined(__PIC24F__) || defined(__dsPIC33F__)
189:           
190:               // Freq Timer = Fosc / Prescaler / TMR
191:           
192:               T2CONbits.T32 = 0;
193:               TMR2 = 0;                       // reset compteur
194:               PR2 = timer;                    // Periode du Timer 1 (64ms)
195:               T2CONbits.TCKPS = scaler;       // Prescaler (0=1 - 1=8 - 2=64 - 3=256)
196:               IFS0bits.T2IF = 0;              // Reset Timer1 interrupt flag
197:               IPC1bits.T2IP = 6;              // priority level
198:               IEC0bits.T2IE = 1;              // Enable Timer 1 interrupt
199:               T2CONbits.TON = 1;              // Lancer le Timer 1
200:           
201:               #endif
202:           }
203:           #endif
204:           
205:           
206:           //=============================================================================
207:           #if defined (_T3IF) || defined (TMR3IF_bit)
208:           void timer3_init (TMR_PRESCALER scaler, u16 timer)
209:           {
210:               #if defined (__18CXX) || defined (__XC8) || defined(_PIC18)
211:               
212:               
213:               #elif defined(__PIC24F__) || defined(__dsPIC33F__)
214:           
215:               // Freq Timer = Fosc / Prescaler / TMR
216:           
217:               TMR3 = 0;                       // reset compteur
218:               PR3 = timer;                    // Periode du Timer 1 (64ms)
219:               T3CONbits.TCKPS = scaler;       // Prescaler (0=1 - 1=8 - 2=64 - 3=256)
220:               IFS0bits.T3IF = 0;              // Reset Timer1 interrupt flag
221:               IPC2bits.T3IP = 6;              // priority level
222:               IEC0bits.T3IE = 1;              // Enable Timer 1 interrupt
223:               T3CONbits.TON = 1;              // Lancer le Timer 1
224:           
225:               #endif
226:           }
227:           #endif
228:           
229:           
230:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
231:           //--------------------- Configuration of 32 bits Timers -----------------------
232:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
233:           #ifdef _T3IF
234:           void timer23_init (TMR_PRESCALER scaler, u32 timer)
235:           {
236:               #if defined(__PIC24F__) || defined(__dsPIC33F__)
237:           
238:               // Freq Timer = Fosc / Prescaler / TMR
239:           
240:               T3CONbits.TON = 0;              // Stop any 16-bit Timer3 operation
241:               T2CONbits.TON = 0;              // Stop any 16/32-bit Timer3 operation
242:               T2CONbits.T32 = 1;              // Enable 32-bit Timer mode
243:               T2CONbits.TCS = 0;              // Select internal instruction cycle clock
244:               T2CONbits.TGATE = 0;            // Disable Gated Timer mode
245:               TMR2 = 0;                       // reset compteur
246:               TMR3 = 0;                       // reset compteur
247:               PR2 = (u16)timer;               // Timer period (lsb)
248:               PR3 = timer<<16;                // Timer period (msb)
249:               T2CONbits.TCKPS = scaler;       // Prescaler (0=1 - 1=8 - 2=64 - 3=256)
250:               IPC2bits.T3IP = 0x01;           // Set Timer3 Interrupt Priority Level
251:               IFS0bits.T3IF = 0;              // Clear Timer3 Interrupt Flag
252:               IEC0bits.T3IE = 1;              // Enable Timer3 interrupt
253:               T2CONbits.TON = 1;              // Start 32-bit Timer
254:           
255:               #endif
256:           }
257:           #endif
258:           
259:           
260:           #ifdef _T5IF
261:           void timer45_init (TMR_PRESCALER scaler, u32 timer)
262:           {
263:               #if defined(__PIC24F__) || defined(__dsPIC33F__)
264:           
265:               // Freq Timer = Fosc / Prescaler / TMR
266:           
267:               T5CONbits.TON = 0;              // Stop any 16-bit Timer3 operation
268:               T4CONbits.TON = 0;              // Stop any 16/32-bit Timer3 operation
269:               T4CONbits.T32 = 1;              // Enable 32-bit Timer mode
270:               T4CONbits.TCS = 0;              // Select internal instruction cycle clock
271:               T4CONbits.TGATE = 0;            // Disable Gated Timer mode
272:               TMR4 = 0;                       // reset compteur
273:               TMR5 = 0;                       // reset compteur
274:               PR4 = (u16)timer;               // Timer period (lsb)
275:               PR5 = timer<<16;                // Timer period (msb)
276:               T4CONbits.TCKPS = scaler;       // Prescaler (0=1 - 1=8 - 2=64 - 3=256)
277:               IPC7bits.T5IP = 0x01;           // Set Timer3 Interrupt Priority Level
278:               IFS1bits.T5IF = 0;              // Clear Timer3 Interrupt Flag
279:               IEC1bits.T5IE = 1;              // Enable Timer3 interrupt
280:               T4CONbits.TON = 1;              // Start 32-bit Timer
281:           
282:               #endif
283:           }
284:           #endif
285:           
286:           
287:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
288:           //------------------------------ Timers ISR -----------------------------------
289:           //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
290:           #ifdef _T1IF
291:           void __attribute__((interrupt, no_auto_psv)) _T1Interrupt(void)
292:           {
293:               IFS0bits.T1IF = 0;              // RAZ du flag d'interruption
294:               T1CONbits.TON = 0;              // arreter le timer
295:               timer1_isr();
296:               TMR1 = 0;                       // RAZ du compteur
297:               T1CONbits.TON = 1;              // relancer le timer
298:           }
299:           #endif
300:           
301:           
302:           #ifdef _T2IF
303:           void __attribute__((interrupt, no_auto_psv)) _T2Interrupt(void)
304:           {
305:               IFS0bits.T2IF = 0;              // RAZ du flag d'interruption
306:               T2CONbits.TON = 0;              // arreter le timer
307:               timer2_isr();
308:               TMR2 = 0;                       // RAZ du compteur
309:               T2CONbits.TON = 1;              // relancer le timer
310:           }
311:           #endif
312:           
313:           
314:           #ifdef _T3IF
315:           void __attribute__((interrupt, no_auto_psv)) _T3Interrupt(void)
316:           {
317:               IFS0bits.T3IF = 0;              // RAZ du flag d'interruption
318:               T3CONbits.TON = 0;              // arreter le timer
319:               timer3_isr();
320:               TMR3 = 0;                       // RAZ du compteur
321:               T3CONbits.TON = 1;              // relancer le timer
322:           }
323:           #endif
324:           
325:           
326:           #ifdef _T4IF
327:           void __attribute__((interrupt, no_auto_psv)) _T4Interrupt(void)
328:           {
329:               IFS1bits.T4IF = 0;              // RAZ du flag d'interruption
330:               T4CONbits.TON = 0;              // arreter le timer
331:               timer4_isr();
332:               TMR4 = 0;                       // RAZ du compteur
333:               T4CONbits.TON = 1;              // relancer le timer
334:           }
335:           #endif
336:           
337:           
338:           #ifdef _T5IF
339:           void __attribute__((interrupt, no_auto_psv)) _T5Interrupt(void)
340:           {
341:               IFS1bits.T5IF = 0;              // RAZ du flag d'interruption
342:               T5CONbits.TON = 0;              // arreter le timer
343:               timer5_isr();
344:               TMR5 = 0;                       // RAZ du compteur
345:               T5CONbits.TON = 1;              // relancer le timer
346:           }
347:           #endif
---  D:/GitHub/mcu/libraries/lib_misc/log.c  ------------------------------------------------------------
1:             #include "stdio.h"
2:             
3:             #include "log.h"
4:             
5:             extern UART_ID UART_ID_LOG;
6:             
7:             void PRINT_ERROR(char *log)
1201E  0E85     MOVLW 0x85
12020  6E59     MOVWF fmt, ACCESS
12022  0EFE     MOVLW 0xFE
12024  6E5A     MOVWF 0x5A, ACCESS
12028  F3A8     NOP
1202A  F05B     NOP
1202E  F3AC     NOP
12030  F05C     NOP
12032  ECE4     CALL 0x11FC8, 0
12034  F08F     NOP
8:             {
9:                 printf(CONS_FG_RED"%s\n"CONS_FG_WHITE, log);
10:            }
12036  0012     RETURN 0
11:            
12:            void PRINT_DEBUG(char *log)
13:            {
14:                printf("%s\n", log);
15:            }
16:            
17:            void PRINT_WARN (char *log)
18:            {
19:                printf(CONS_BG_YELLOW"%s\n"CONS_FG_WHITE, log);
20:            }
---  C:/Users/Pierre/AppData/Local/Temp/s844.s  ---------------------------------------------------------
11DCE  0E5E     MOVLW 0x5E
11DD0  6EF6     MOVWF 0xFF6, ACCESS
11DD2  0E1F     MOVLW 0x1F
11DD4  6EF7     MOVWF 0xFF7, ACCESS
11DD6  0E01     MOVLW 0x1
11DD8  6EF8     MOVWF 0xFF8, ACCESS
11DDA  EE00     LFSR 0, 0x9C
11DDE  EE10     LFSR 1, 0x3B
11DE2  0009     TBLRD*+
11DEA  50E5     MOVF 0xFE5, W, ACCESS
11DEC  50E1     MOVF 0xFE1, W, ACCESS
11DEE  E1F9     BNZ 0x1DE2
11DF0  EE00     LFSR 0, 0x100
11DF4  EE10     LFSR 1, 0x100
11DF8  6AEE     CLRF 0xFEE, ACCESS
11DFA  50E5     MOVF 0xFE5, W, ACCESS
11DFC  50E1     MOVF 0xFE1, W, ACCESS
11DFE  E1FC     BNZ 0x1DF8
11E00  50E2     MOVF 0xFE2, W, ACCESS
11E02  E1FA     BNZ 0x1DF8
11E04  EE00     LFSR 0, 0x60
11E08  0E3C     MOVLW 0x3C
11E0A  6AEE     CLRF 0xFEE, ACCESS
11E0C  06E8     DECF 0xFE8, F, ACCESS
11E0E  E1FD     BNZ 0x1E0A
11E10  6A5D     CLRF __pbssCOMRAM, ACCESS
11E12  0E08     MOVLW 0x8
11E14  6ED5     MOVWF 0xFD5, ACCESS
11E16  0E00     MOVLW 0x0
11E18  6ED6     MOVWF 0xFD6, ACCESS
11E1A  0E00     MOVLW 0x0
11E1C  6ED7     MOVWF 0xFD7, ACCESS
11E1E  0100     MOVLB 0x0
11E20  EF00     GOTO 0x10000
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/toupper.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
11CB4  0E9F     MOVLW 0x9F
11CB6  6E0A     MOVWF divisor, ACCESS
11CB8  0EFF     MOVLW 0xFF
11CBA  6E0B     MOVWF 0xB, ACCESS
11CBE  F020     NOP
11CC0  F00C     NOP
11CC4  F024     NOP
11CC6  F00D     NOP
11CC8  500A     MOVF divisor, W, ACCESS
11CCA  260C     ADDWF 0xC, F, ACCESS
11CCC  500B     MOVF 0xB, W, ACCESS
11CCE  220D     ADDWFC 0xD, F, ACCESS
11CD0  500D     MOVF 0xD, W, ACCESS
11CD2  E10A     BNZ 0x1CE8
11CD4  0E1A     MOVLW 0x1A
11CD6  5C0C     SUBWF 0xC, W, ACCESS
11CD8  A0D8     BTFSS 0xFD8, 0, ACCESS
11CDA  EF71     GOTO 0x11CE2
11CDC  F08E     NOP
11CDE  EF74     GOTO 0x11CE8
11CE0  F08E     NOP
11CE2  0E01     MOVLW 0x1
11CE4  EF75     GOTO 0x11CEA
11CE6  F08E     NOP
11CE8  0E00     MOVLW 0x0
11CEA  6E0E     MOVWF s, ACCESS
11CEC  6A0F     CLRF neg, ACCESS
11CEE  500E     MOVF s, W, ACCESS
11CF0  100F     IORWF neg, W, ACCESS
11CF2  B4D8     BTFSC 0xFD8, 2, ACCESS
11CF4  EF7E     GOTO 0x11CFC
11CF6  F08E     NOP
11CF8  EF80     GOTO 0x11D00
11CFA  F08E     NOP
11CFC  EF86     GOTO 0x11D0C
11CFE  F08E     NOP
11D00  0E5F     MOVLW 0x5F
11D02  1408     ANDWF c, W, ACCESS
11D04  6E08     MOVWF c, ACCESS
11D06  6A09     CLRF s, ACCESS
11D08  EF8C     GOTO 0x11D18
11D0A  F08E     NOP
5:             {
6:             	if (islower(c)) return c & 0x5f;
7:             	return c;
11D0E  F020     NOP
11D10  F008     NOP
11D14  F024     NOP
11D16  F009     NOP
8:             }
11D18  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/strlen.c  -----------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
11D1C  F008     NOP
11D1E  F004     NOP
11D22  F00C     NOP
11D24  F005     NOP
6:             {
7:             	const char *a = s;
8:             	while(*s) {
11D26  EF97     GOTO 0x11D2E
11D28  F08E     NOP
11D30  F00B     NOP
11D32  FFF6     NOP
11D36  F00F     NOP
11D38  FFF7     NOP
11D3A  0E00     MOVLW 0x0
11D3C  6EF8     MOVWF 0xFF8, ACCESS
11D3E  0E1F     MOVLW 0x1F
11D40  64F7     CPFSGT 0xFF7, ACCESS
11D42  D003     BRA 0x1D4A
11D44  0008     TBLRD*
11D46  50F5     MOVF 0xFF5, W, ACCESS
11D48  D007     BRA 0x1D58
11D4C  FFDB     NOP
11D4E  FFE9     NOP
11D52  FFDF     NOP
11D54  FFEA     NOP
11D56  50EF     MOVF 0xFEF, W, ACCESS
11D58  0900     IORLW 0x0
11D5A  A4D8     BTFSS 0xFD8, 2, ACCESS
11D5C  EFB2     GOTO 0x11D64
11D5E  F08E     NOP
11D60  EFB4     GOTO 0x11D68
11D62  F08E     NOP
11D64  EF95     GOTO 0x11D2A
11D66  F08E     NOP
9:             		s++;
11D2A  4A02     INFSNZ dividend, F, ACCESS
11D2C  2A03     INCF uart_id, F, ACCESS
10:            	}
11:            	return s-a;
11D68  5004     MOVF txData, W, ACCESS
11D6A  5C02     SUBWF dividend, W, ACCESS
11D6C  6E02     MOVWF dividend, ACCESS
11D6E  5005     MOVF c, W, ACCESS
11D70  5803     SUBWFB uart_id, W, ACCESS
11D72  6E03     MOVWF uart_id, ACCESS
12:            }
11D74  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/printf.c  -----------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
11FC8  0E5B     MOVLW 0x5B
11FCA  0100     MOVLB 0x0
11FCC  6FE8     MOVWF ap, BANKED
11FCE  0E00     MOVLW 0x0
11FD0  6FE9     MOVWF 0xE9, BANKED
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
10:            	ret = vfprintf(stdout, fmt, ap);
11FD2  0E00     MOVLW 0x0
11FD4  6E51     MOVWF fp, ACCESS
11FD6  0E00     MOVLW 0x0
11FD8  6E52     MOVWF 0x52, ACCESS
11FDC  F164     NOP
11FDE  F053     NOP
11FE2  F168     NOP
11FE4  F054     NOP
11FE6  0EE8     MOVLW 0xE8
11FE8  6E55     MOVWF ap, ACCESS
11FEA  0E00     MOVLW 0x0
11FEC  6E56     MOVWF 0x56, ACCESS
11FEE  EC1D     CALL 0x11C3A, 0
11FF0  F08E     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
11FF2  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/nf_fputs.c  ---------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
11E24  0E00     MOVLW 0x0
11E26  6E14     MOVWF 0x14, ACCESS
11E28  0E00     MOVLW 0x0
11E2A  6E13     MOVWF i, ACCESS
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
14:                while ((c = *(s + i))) {
11E2C  EF26     GOTO 0x11E4C
11E2E  F08F     NOP
11E4C  5013     MOVF i, W, ACCESS
11E4E  240E     ADDWF s, W, ACCESS
11E50  6ED9     MOVWF 0xFD9, ACCESS
11E52  5014     MOVF 0x14, W, ACCESS
11E54  200F     ADDWFC neg, W, ACCESS
11E56  6EDA     MOVWF 0xFDA, ACCESS
11E58  50DF     MOVF 0xFDF, W, ACCESS
11E5A  6E12     MOVWF counter, ACCESS
11E5C  5012     MOVF counter, W, ACCESS
11E5E  A4D8     BTFSS 0xFD8, 2, ACCESS
11E60  EF34     GOTO 0x11E68
11E62  F08F     NOP
11E64  EF36     GOTO 0x11E6C
11E66  F08F     NOP
11E68  EF18     GOTO 0x11E30
11E6A  F08F     NOP
15:            	fputc(c,fp);
11E32  F048     NOP
11E34  F005     NOP
11E36  6A06     CLRF product, ACCESS
11E3A  F040     NOP
11E3C  F007     NOP
11E40  F044     NOP
11E42  F008     NOP
11E44  ECD2     CALL 0x11BA4, 0
11E46  F08D     NOP
16:                    ++i;
11E48  4A13     INFSNZ i, F, ACCESS
11E4A  2A14     INCF 0x14, F, ACCESS
17:                }
18:                return i;
19:            }
11E6C  0012     RETURN 0
20:            
21:            #endif
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/nf_fputc.c  ---------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
11BA4  5007     MOVF fp, W, ACCESS
11BA6  1008     IORWF c, W, ACCESS
11BA8  B4D8     BTFSC 0xFD8, 2, ACCESS
11BAA  EFD9     GOTO 0x11BB2
11BAC  F08D     NOP
11BAE  EFDB     GOTO 0x11BB6
11BB0  F08D     NOP
11BB2  EFE4     GOTO 0x11BC8
11BB4  F08D     NOP
11BB6  5007     MOVF fp, W, ACCESS
11BB8  1008     IORWF c, W, ACCESS
11BBA  A4D8     BTFSS 0xFD8, 2, ACCESS
11BBC  EFE2     GOTO 0x11BC4
11BBE  F08D     NOP
11BC0  EFE4     GOTO 0x11BC8
11BC2  F08D     NOP
11BC4  EFE9     GOTO 0x11BD2
11BC6  F08D     NOP
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
13:                    putch(c);
11BC8  5005     MOVF c, W, ACCESS
11BCA  EC1C     CALL 0x12038, 0
11BCC  F090     NOP
14:                } else {
11BCE  EF1C     GOTO 0x11C38
11BD0  F08E     NOP
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
11BD2  EE20     LFSR 2, 0x4
11BD4  F004     NOP
11BD6  5007     MOVF fp, W, ACCESS
11BD8  26D9     ADDWF 0xFD9, F, ACCESS
11BDA  5008     MOVF c, W, ACCESS
11BDC  22DA     ADDWFC 0xFDA, F, ACCESS
11BDE  50DE     MOVF 0xFDE, W, ACCESS
11BE0  10DE     IORWF 0xFDE, W, ACCESS
11BE2  B4D8     BTFSC 0xFD8, 2, ACCESS
11BE4  EFF6     GOTO 0x11BEC
11BE6  F08D     NOP
11BE8  EFF8     GOTO 0x11BF0
11BEA  F08D     NOP
11BEC  EF13     GOTO 0x11C26
11BEE  F08E     NOP
11BF0  EE20     LFSR 2, 0x4
11BF2  F004     NOP
11BF4  5007     MOVF fp, W, ACCESS
11BF6  26D9     ADDWF 0xFD9, F, ACCESS
11BF8  5008     MOVF c, W, ACCESS
11BFA  22DA     ADDWFC 0xFDA, F, ACCESS
11BFC  EE10     LFSR 1, 0x2
11BFE  F002     NOP
11C00  5007     MOVF fp, W, ACCESS
11C02  26E1     ADDWF 0xFE1, F, ACCESS
11C04  5008     MOVF c, W, ACCESS
11C06  22E2     ADDWFC 0xFE2, F, ACCESS
11C08  50DE     MOVF 0xFDE, W, ACCESS
11C0A  5CE6     SUBWF 0xFE6, W, ACCESS
11C0C  50E6     MOVF 0xFE6, W, ACCESS
11C0E  0A80     XORLW 0x80
11C10  6E0D     MOVWF 0xD, ACCESS
11C12  50DE     MOVF 0xFDE, W, ACCESS
11C14  0A80     XORLW 0x80
11C16  580D     SUBWFB 0xD, W, ACCESS
11C18  B0D8     BTFSC 0xFD8, 0, ACCESS
11C1A  EF11     GOTO 0x11C22
11C1C  F08E     NOP
11C1E  EF13     GOTO 0x11C26
11C20  F08E     NOP
11C22  EF1C     GOTO 0x11C38
11C24  F08E     NOP
16:            	        fp->buffer[fp->count] = (char)c;
17:            		++fp->count;
11C26  EE20     LFSR 2, 0x2
11C28  F002     NOP
11C2A  5007     MOVF fp, W, ACCESS
11C2C  26D9     ADDWF 0xFD9, F, ACCESS
11C2E  5008     MOVF c, W, ACCESS
11C30  22DA     ADDWFC 0xFDA, F, ACCESS
11C32  2ADE     INCF 0xFDE, F, ACCESS
11C34  0E00     MOVLW 0x0
11C36  22DD     ADDWFC 0xFDD, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
11C38  0012     RETURN 0
22:            
23:            #endif
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/lomod.c  ------------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
11AC4  500A     MOVF divisor, W, ACCESS
11AC6  100B     IORWF 0xB, W, ACCESS
11AC8  100C     IORWF 0xC, W, ACCESS
11ACA  100D     IORWF 0xD, W, ACCESS
11ACC  100E     IORWF s, W, ACCESS
11ACE  100F     IORWF neg, W, ACCESS
11AD0  1010     IORWF fp, W, ACCESS
11AD2  1011     IORWF 0x11, W, ACCESS
11AD4  B4D8     BTFSC 0xFD8, 2, ACCESS
11AD6  EF6F     GOTO 0x11ADE
11AD8  F08D     NOP
11ADA  EF71     GOTO 0x11AE2
11ADC  F08D     NOP
11ADE  EFB9     GOTO 0x11B72
11AE0  F08D     NOP
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
15:            		counter = 1;
11AE2  0E01     MOVLW 0x1
11AE4  6E12     MOVWF counter, ACCESS
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
11AE6  EF7F     GOTO 0x11AFE
11AE8  F08D     NOP
11AFE  AE11     BTFSS 0x11, 7, ACCESS
11B00  EF84     GOTO 0x11B08
11B02  F08D     NOP
11B04  EF86     GOTO 0x11B0C
11B06  F08D     NOP
11B08  EF75     GOTO 0x11AEA
11B0A  F08D     NOP
17:            			divisor <<= 1;
11AEA  90D8     BCF 0xFD8, 0, ACCESS
11AEC  360A     RLCF divisor, F, ACCESS
11AEE  360B     RLCF 0xB, F, ACCESS
11AF0  360C     RLCF 0xC, F, ACCESS
11AF2  360D     RLCF 0xD, F, ACCESS
11AF4  360E     RLCF s, F, ACCESS
11AF6  360F     RLCF neg, F, ACCESS
11AF8  3610     RLCF fp, F, ACCESS
11AFA  3611     RLCF 0x11, F, ACCESS
18:            			counter++;
11AFC  2A12     INCF counter, F, ACCESS
19:            		}
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
11B0C  500A     MOVF divisor, W, ACCESS
11B0E  5C02     SUBWF dividend, W, ACCESS
11B10  500B     MOVF 0xB, W, ACCESS
11B12  5803     SUBWFB uart_id, W, ACCESS
11B14  500C     MOVF 0xC, W, ACCESS
11B16  5804     SUBWFB txData, W, ACCESS
11B18  500D     MOVF 0xD, W, ACCESS
11B1A  5805     SUBWFB c, W, ACCESS
11B1C  500E     MOVF s, W, ACCESS
11B1E  5806     SUBWFB product, W, ACCESS
11B20  500F     MOVF neg, W, ACCESS
11B22  5807     SUBWFB fp, W, ACCESS
11B24  5010     MOVF fp, W, ACCESS
11B26  5808     SUBWFB c, W, ACCESS
11B28  5011     MOVF 0x11, W, ACCESS
11B2A  5809     SUBWFB s, W, ACCESS
11B2C  A0D8     BTFSS 0xFD8, 0, ACCESS
11B2E  EF9B     GOTO 0x11B36
11B30  F08D     NOP
11B32  EF9D     GOTO 0x11B3A
11B34  F08D     NOP
11B36  EFAD     GOTO 0x11B5A
11B38  F08D     NOP
22:            				dividend -= divisor;
11B3A  500A     MOVF divisor, W, ACCESS
11B3C  5E02     SUBWF dividend, F, ACCESS
11B3E  500B     MOVF 0xB, W, ACCESS
11B40  5A03     SUBWFB uart_id, F, ACCESS
11B42  500C     MOVF 0xC, W, ACCESS
11B44  5A04     SUBWFB txData, F, ACCESS
11B46  500D     MOVF 0xD, W, ACCESS
11B48  5A05     SUBWFB c, F, ACCESS
11B4A  500E     MOVF s, W, ACCESS
11B4C  5A06     SUBWFB product, F, ACCESS
11B4E  500F     MOVF neg, W, ACCESS
11B50  5A07     SUBWFB fp, F, ACCESS
11B52  5010     MOVF fp, W, ACCESS
11B54  5A08     SUBWFB c, F, ACCESS
11B56  5011     MOVF 0x11, W, ACCESS
11B58  5A09     SUBWFB s, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
11B5A  90D8     BCF 0xFD8, 0, ACCESS
11B5C  3211     RRCF 0x11, F, ACCESS
11B5E  3210     RRCF fp, F, ACCESS
11B60  320F     RRCF neg, F, ACCESS
11B62  320E     RRCF s, F, ACCESS
11B64  320D     RRCF 0xD, F, ACCESS
11B66  320C     RRCF 0xC, F, ACCESS
11B68  320B     RRCF 0xB, F, ACCESS
11B6A  320A     RRCF divisor, F, ACCESS
24:            		} while(--counter != 0);
11B6C  2E12     DECFSZ counter, F, ACCESS
11B6E  EF86     GOTO 0x11B0C
11B70  F08D     NOP
25:            	}
11B74  F008     NOP
11B76  F002     NOP
11B7A  F00C     NOP
11B7C  F003     NOP
11B80  F010     NOP
11B82  F004     NOP
11B86  F014     NOP
11B88  F005     NOP
11B8C  F018     NOP
11B8E  F006     NOP
11B92  F01C     NOP
11B94  F007     NOP
11B98  F020     NOP
11B9A  F008     NOP
11B9E  F024     NOP
11BA0  F009     NOP
26:            	return dividend;
27:            }
11BA2  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/lodiv.c  ------------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
118E2  EE20     LFSR 2, 0x12
118E4  F012     NOP
118E6  0E07     MOVLW 0x7
118E8  6ADE     CLRF 0xFDE, ACCESS
118EA  06E8     DECF 0xFE8, F, ACCESS
118EC  E2FD     BC 0x18E8
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
16:            	if(divisor != 0) {
118EE  500A     MOVF divisor, W, ACCESS
118F0  100B     IORWF 0xB, W, ACCESS
118F2  100C     IORWF 0xC, W, ACCESS
118F4  100D     IORWF 0xD, W, ACCESS
118F6  100E     IORWF s, W, ACCESS
118F8  100F     IORWF neg, W, ACCESS
118FA  1010     IORWF fp, W, ACCESS
118FC  1011     IORWF 0x11, W, ACCESS
118FE  B4D8     BTFSC 0xFD8, 2, ACCESS
11900  EF84     GOTO 0x11908
11902  F08C     NOP
11904  EF86     GOTO 0x1190C
11906  F08C     NOP
11908  EFD8     GOTO 0x119B0
1190A  F08C     NOP
17:            		counter = 1;
1190C  0E01     MOVLW 0x1
1190E  6E1A     MOVWF counter, ACCESS
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
11910  EF94     GOTO 0x11928
11912  F08C     NOP
11928  AE11     BTFSS 0x11, 7, ACCESS
1192A  EF99     GOTO 0x11932
1192C  F08C     NOP
1192E  EF9B     GOTO 0x11936
11930  F08C     NOP
11932  EF8A     GOTO 0x11914
11934  F08C     NOP
19:            			divisor <<= 1;
11914  90D8     BCF 0xFD8, 0, ACCESS
11916  360A     RLCF divisor, F, ACCESS
11918  360B     RLCF 0xB, F, ACCESS
1191A  360C     RLCF 0xC, F, ACCESS
1191C  360D     RLCF 0xD, F, ACCESS
1191E  360E     RLCF s, F, ACCESS
11920  360F     RLCF neg, F, ACCESS
11922  3610     RLCF fp, F, ACCESS
11924  3611     RLCF 0x11, F, ACCESS
20:            			counter++;
11926  2A1A     INCF counter, F, ACCESS
21:            		}
22:            		do {
23:            			quotient <<= 1;
11936  90D8     BCF 0xFD8, 0, ACCESS
11938  3612     RLCF counter, F, ACCESS
1193A  3613     RLCF i, F, ACCESS
1193C  3614     RLCF 0x14, F, ACCESS
1193E  3615     RLCF fp, F, ACCESS
11940  3616     RLCF n, F, ACCESS
11942  3617     RLCF buf, F, ACCESS
11944  3618     RLCF 0x18, F, ACCESS
11946  3619     RLCF p, F, ACCESS
24:            			if(divisor <= dividend) {
11948  500A     MOVF divisor, W, ACCESS
1194A  5C02     SUBWF dividend, W, ACCESS
1194C  500B     MOVF 0xB, W, ACCESS
1194E  5803     SUBWFB uart_id, W, ACCESS
11950  500C     MOVF 0xC, W, ACCESS
11952  5804     SUBWFB txData, W, ACCESS
11954  500D     MOVF 0xD, W, ACCESS
11956  5805     SUBWFB c, W, ACCESS
11958  500E     MOVF s, W, ACCESS
1195A  5806     SUBWFB product, W, ACCESS
1195C  500F     MOVF neg, W, ACCESS
1195E  5807     SUBWFB fp, W, ACCESS
11960  5010     MOVF fp, W, ACCESS
11962  5808     SUBWFB c, W, ACCESS
11964  5011     MOVF 0x11, W, ACCESS
11966  5809     SUBWFB s, W, ACCESS
11968  A0D8     BTFSS 0xFD8, 0, ACCESS
1196A  EFB9     GOTO 0x11972
1196C  F08C     NOP
1196E  EFBB     GOTO 0x11976
11970  F08C     NOP
11972  EFCC     GOTO 0x11998
11974  F08C     NOP
25:            				dividend -= divisor;
11976  500A     MOVF divisor, W, ACCESS
11978  5E02     SUBWF dividend, F, ACCESS
1197A  500B     MOVF 0xB, W, ACCESS
1197C  5A03     SUBWFB uart_id, F, ACCESS
1197E  500C     MOVF 0xC, W, ACCESS
11980  5A04     SUBWFB txData, F, ACCESS
11982  500D     MOVF 0xD, W, ACCESS
11984  5A05     SUBWFB c, F, ACCESS
11986  500E     MOVF s, W, ACCESS
11988  5A06     SUBWFB product, F, ACCESS
1198A  500F     MOVF neg, W, ACCESS
1198C  5A07     SUBWFB fp, F, ACCESS
1198E  5010     MOVF fp, W, ACCESS
11990  5A08     SUBWFB c, F, ACCESS
11992  5011     MOVF 0x11, W, ACCESS
11994  5A09     SUBWFB s, F, ACCESS
26:            				quotient |= 1;
11996  8012     BSF counter, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
11998  90D8     BCF 0xFD8, 0, ACCESS
1199A  3211     RRCF 0x11, F, ACCESS
1199C  3210     RRCF fp, F, ACCESS
1199E  320F     RRCF neg, F, ACCESS
119A0  320E     RRCF s, F, ACCESS
119A2  320D     RRCF 0xD, F, ACCESS
119A4  320C     RRCF 0xC, F, ACCESS
119A6  320B     RRCF 0xB, F, ACCESS
119A8  320A     RRCF divisor, F, ACCESS
29:            		} while(--counter != 0);
119AA  2E1A     DECFSZ counter, F, ACCESS
119AC  EF9B     GOTO 0x11936
119AE  F08C     NOP
30:            	}
119B2  F048     NOP
119B4  F002     NOP
119B8  F04C     NOP
119BA  F003     NOP
119BE  F050     NOP
119C0  F004     NOP
119C4  F054     NOP
119C6  F005     NOP
119CA  F058     NOP
119CC  F006     NOP
119D0  F05C     NOP
119D2  F007     NOP
119D6  F060     NOP
119D8  F008     NOP
119DC  F064     NOP
119DE  F009     NOP
31:            	return quotient;
32:            }
119E0  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/isupper.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
11EAA  0EBF     MOVLW 0xBF
11EAC  6E04     MOVWF txData, ACCESS
11EAE  0EFF     MOVLW 0xFF
11EB0  6E05     MOVWF c, ACCESS
11EB4  F008     NOP
11EB6  F006     NOP
11EBA  F00C     NOP
11EBC  F007     NOP
11EBE  5004     MOVF txData, W, ACCESS
11EC0  2606     ADDWF product, F, ACCESS
11EC2  5005     MOVF c, W, ACCESS
11EC4  2207     ADDWFC fp, F, ACCESS
11EC6  5007     MOVF fp, W, ACCESS
11EC8  E10A     BNZ 0x1EDE
11ECA  0E1A     MOVLW 0x1A
11ECC  5C06     SUBWF product, W, ACCESS
11ECE  A0D8     BTFSS 0xFD8, 0, ACCESS
11ED0  EF6C     GOTO 0x11ED8
11ED2  F08F     NOP
11ED4  EF6F     GOTO 0x11EDE
11ED6  F08F     NOP
11ED8  0E01     MOVLW 0x1
11EDA  EF70     GOTO 0x11EE0
11EDC  F08F     NOP
11EDE  0E00     MOVLW 0x0
11EE0  6E02     MOVWF dividend, ACCESS
11EE2  6A03     CLRF uart_id, ACCESS
6:             {
7:             	return (unsigned)c-'A' < 26;
8:             }
11EE4  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/isspace.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
11D76  0E01     MOVLW 0x1
11D78  6E08     MOVWF c, ACCESS
11D7A  0E20     MOVLW 0x20
11D7C  1802     XORWF dividend, W, ACCESS
11D7E  1003     IORWF uart_id, W, ACCESS
11D80  B4D8     BTFSC 0xFD8, 2, ACCESS
11D82  EFC5     GOTO 0x11D8A
11D84  F08E     NOP
11D86  EFC7     GOTO 0x11D8E
11D88  F08E     NOP
11D8A  EFE2     GOTO 0x11DC4
11D8C  F08E     NOP
11D8E  0EF7     MOVLW 0xF7
11D90  6E04     MOVWF txData, ACCESS
11D92  0EFF     MOVLW 0xFF
11D94  6E05     MOVWF c, ACCESS
11D98  F008     NOP
11D9A  F006     NOP
11D9E  F00C     NOP
11DA0  F007     NOP
11DA2  5004     MOVF txData, W, ACCESS
11DA4  2606     ADDWF product, F, ACCESS
11DA6  5005     MOVF c, W, ACCESS
11DA8  2207     ADDWFC fp, F, ACCESS
11DAA  5007     MOVF fp, W, ACCESS
11DAC  E109     BNZ 0x1DC0
11DAE  0E05     MOVLW 0x5
11DB0  5C06     SUBWF product, W, ACCESS
11DB2  A0D8     BTFSS 0xFD8, 0, ACCESS
11DB4  EFDE     GOTO 0x11DBC
11DB6  F08E     NOP
11DB8  EFE0     GOTO 0x11DC0
11DBA  F08E     NOP
11DBC  EFE2     GOTO 0x11DC4
11DBE  F08E     NOP
11DC0  0E00     MOVLW 0x0
11DC2  6E08     MOVWF c, ACCESS
11DC6  F020     NOP
11DC8  F002     NOP
11DCA  6A03     CLRF uart_id, ACCESS
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
8:             }
11DCC  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/islower.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
11E6E  0E9F     MOVLW 0x9F
11E70  6E04     MOVWF txData, ACCESS
11E72  0EFF     MOVLW 0xFF
11E74  6E05     MOVWF c, ACCESS
11E78  F008     NOP
11E7A  F006     NOP
11E7E  F00C     NOP
11E80  F007     NOP
11E82  5004     MOVF txData, W, ACCESS
11E84  2606     ADDWF product, F, ACCESS
11E86  5005     MOVF c, W, ACCESS
11E88  2207     ADDWFC fp, F, ACCESS
11E8A  5007     MOVF fp, W, ACCESS
11E8C  E10A     BNZ 0x1EA2
11E8E  0E1A     MOVLW 0x1A
11E90  5C06     SUBWF product, W, ACCESS
11E92  A0D8     BTFSS 0xFD8, 0, ACCESS
11E94  EF4E     GOTO 0x11E9C
11E96  F08F     NOP
11E98  EF51     GOTO 0x11EA2
11E9A  F08F     NOP
11E9C  0E01     MOVLW 0x1
11E9E  EF52     GOTO 0x11EA4
11EA0  F08F     NOP
11EA2  0E00     MOVLW 0x0
11EA4  6E02     MOVWF dividend, ACCESS
11EA6  6A03     CLRF uart_id, ACCESS
6:             {
7:             	return (unsigned)c-'a' < 26;
8:             }
11EA8  0012     RETURN 0
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/isdigit.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
11F22  0ED0     MOVLW 0xD0
11F24  6E04     MOVWF txData, ACCESS
11F26  0EFF     MOVLW 0xFF
11F28  6E05     MOVWF c, ACCESS
11F2C  F008     NOP
11F2E  F006     NOP
11F32  F00C     NOP
11F34  F007     NOP
11F36  5004     MOVF txData, W, ACCESS
11F38  2606     ADDWF product, F, ACCESS
11F3A  5005     MOVF c, W, ACCESS
11F3C  2207     ADDWFC fp, F, ACCESS
11F3E  5007     MOVF fp, W, ACCESS
11F40  E10A     BNZ 0x1F56
11F42  0E0A     MOVLW 0xA
11F44  5C06     SUBWF product, W, ACCESS
11F46  A0D8     BTFSS 0xFD8, 0, ACCESS
11F48  EFA8     GOTO 0x11F50
11F4A  F08F     NOP
11F4C  EFAB     GOTO 0x11F56
11F4E  F08F     NOP
11F50  0E01     MOVLW 0x1
11F52  EFAC     GOTO 0x11F58
11F54  F08F     NOP
11F56  0E00     MOVLW 0x0
11F58  6E02     MOVWF dividend, ACCESS
11F5A  6A03     CLRF uart_id, ACCESS
6:             {
7:             	return (unsigned)c-'0' < 10;
8:             }
11F5C  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/isalpha.c  ----------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
11EE6  0E9F     MOVLW 0x9F
11EE8  6E04     MOVWF txData, ACCESS
11EEA  0EFF     MOVLW 0xFF
11EEC  6E05     MOVWF c, ACCESS
11EEE  0E20     MOVLW 0x20
11EF0  1002     IORWF dividend, W, ACCESS
11EF2  6E06     MOVWF product, ACCESS
11EF4  0E00     MOVLW 0x0
11EF6  1003     IORWF uart_id, W, ACCESS
11EF8  6E07     MOVWF fp, ACCESS
11EFA  5004     MOVF txData, W, ACCESS
11EFC  2606     ADDWF product, F, ACCESS
11EFE  5005     MOVF c, W, ACCESS
11F00  2207     ADDWFC fp, F, ACCESS
11F02  5007     MOVF fp, W, ACCESS
11F04  E10A     BNZ 0x1F1A
11F06  0E1A     MOVLW 0x1A
11F08  5C06     SUBWF product, W, ACCESS
11F0A  A0D8     BTFSS 0xFD8, 0, ACCESS
11F0C  EF8A     GOTO 0x11F14
11F0E  F08F     NOP
11F10  EF8D     GOTO 0x11F1A
11F12  F08F     NOP
11F14  0E01     MOVLW 0x1
11F16  EF8E     GOTO 0x11F1C
11F18  F08F     NOP
11F1A  0E00     MOVLW 0x0
11F1C  6E02     MOVWF dividend, ACCESS
11F1E  6A03     CLRF uart_id, ACCESS
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
8:             }
11F20  0012     RETURN 0
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/doprnt.c  -----------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
119E2  0100     MOVLB 0x0
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
78:                    fputs((const char *)buf, fp);
119F4  F05C     NOP
119F6  F00E     NOP
119FA  F060     NOP
119FC  F00F     NOP
11A00  F054     NOP
11A02  F010     NOP
11A06  F058     NOP
11A08  F011     NOP
11A0A  EC12     CALL 0x11E24, 0
11A0C  F08F     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
11A0E  BE1A     BTFSC counter, 7, ACCESS
11A10  EF0C     GOTO 0x11A18
11A12  F08D     NOP
11A14  EF0E     GOTO 0x11A1C
11A16  F08D     NOP
11A18  EF16     GOTO 0x11A2C
11A1A  F08D     NOP
11A1E  F064     NOP
11A20  F01E     NOP
11A24  F068     NOP
11A26  F01F     NOP
11A28  EF1A     GOTO 0x11A34
11A2A  F08D     NOP
11A2C  0E00     MOVLW 0x0
11A2E  6E1F     MOVWF 0x1F, ACCESS
11A30  0E00     MOVLW 0x0
11A32  6E1E     MOVWF cp, ACCESS
83:                i = 0;
11A34  0E00     MOVLW 0x0
11A36  6E1D     MOVWF 0x1D, ACCESS
11A38  0E00     MOVLW 0x0
11A3A  6E1C     MOVWF w, ACCESS
84:                while (i < w) {
11A3C  EF2E     GOTO 0x11A5C
11A3E  F08D     NOP
11A5C  501E     MOVF cp, W, ACCESS
11A5E  5C1C     SUBWF w, W, ACCESS
11A60  501D     MOVF 0x1D, W, ACCESS
11A62  0A80     XORLW 0x80
11A64  6E1B     MOVWF 0x1B, ACCESS
11A66  501F     MOVF 0x1F, W, ACCESS
11A68  0A80     XORLW 0x80
11A6A  581B     SUBWFB 0x1B, W, ACCESS
11A6C  A0D8     BTFSS 0xFD8, 0, ACCESS
11A6E  EF3B     GOTO 0x11A76
11A70  F08D     NOP
11A72  EF3D     GOTO 0x11A7A
11A74  F08D     NOP
11A76  EF20     GOTO 0x11A40
11A78  F08D     NOP
85:                    fputc(' ', fp);
11A40  0E00     MOVLW 0x0
11A42  6E06     MOVWF product, ACCESS
11A44  0E20     MOVLW 0x20
11A46  6E05     MOVWF c, ACCESS
11A4A  F054     NOP
11A4C  F007     NOP
11A50  F058     NOP
11A52  F008     NOP
11A54  ECD2     CALL 0x11BA4, 0
11A56  F08D     NOP
86:                    ++i;
11A58  4A1C     INFSNZ w, F, ACCESS
11A5A  2A1D     INCF 0x1D, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
11A7A  0100     MOVLB 0x0
11A7C  B16D     BTFSC flags, 0, BANKED
11A7E  EF43     GOTO 0x11A86
11A80  F08D     NOP
11A82  EF45     GOTO 0x11A8A
11A84  F08D     NOP
11A86  EF53     GOTO 0x11AA6
11A88  F08D     NOP
91:                    fputs((const char *)buf, fp);
11A8C  F05C     NOP
11A8E  F00E     NOP
11A92  F060     NOP
11A94  F00F     NOP
11A98  F054     NOP
11A9A  F010     NOP
11A9E  F058     NOP
11AA0  F011     NOP
11AA2  EC12     CALL 0x11E24, 0
11AA4  F08F     NOP
92:                }
93:            
94:                return strlen(buf) + w;
11AA8  F05C     NOP
11AAA  F002     NOP
11AAE  F060     NOP
11AB0  F003     NOP
11AB2  EC8D     CALL 0x11D1A, 0
11AB4  F08E     NOP
11AB6  501E     MOVF cp, W, ACCESS
11AB8  2402     ADDWF dividend, W, ACCESS
11ABA  6E15     MOVWF fp, ACCESS
11ABC  501F     MOVF 0x1F, W, ACCESS
11ABE  2003     ADDWFC uart_id, W, ACCESS
11AC0  6E16     MOVWF n, ACCESS
95:            }
11AC2  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
281:               s = n < 0 ? 1 : 0;
282:               if (s) {
283:                   n = -n;
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
288:                   flags &= ~ZERO_FLAG;
289:               }
290:               p = (0 < prec) ? prec : 1;
291:               w = width;
292:               if (s || (flags & PLUS_FLAG)) {
293:                   --w;
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
298:               dbuf[i] = '\0';
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
300:                   --i;
301:                   dbuf[i] = '0' + abs(n % 10);
302:                   --p;
303:                   --w;
304:                   n = n / 10;
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
309:                   --i;
310:                   dbuf[i] = s ? '-' : '+';
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
315:           }
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
112FA  EE20     LFSR 2, 0xD0
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
11310  F040     NOP
11312  F01E     NOP
11316  F044     NOP
11318  F01F     NOP
553:               if (!cp) {
1131A  501E     MOVF cp, W, ACCESS
1131C  101F     IORWF 0x1F, W, ACCESS
1131E  A4D8     BTFSS 0xFD8, 2, ACCESS
11320  EF94     GOTO 0x11328
11322  F089     NOP
11324  EF96     GOTO 0x1132C
11326  F089     NOP
11328  EF9A     GOTO 0x11334
1132A  F089     NOP
554:                   cp = nuls;
1132C  0E13     MOVLW 0x13
1132E  6E1E     MOVWF cp, ACCESS
11330  0E00     MOVLW 0x0
11332  6E1F     MOVWF 0x1F, ACCESS
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
11336  F078     NOP
11338  F002     NOP
1133C  F07C     NOP
1133E  F003     NOP
11340  EC8D     CALL 0x11D1A, 0
11342  F08E     NOP
11346  F008     NOP
11348  F022     NOP
1134C  F00C     NOP
1134E  F023     NOP
559:               p = prec;
11352  F1AC     NOP
11354  F020     NOP
11358  F1B0     NOP
1135A  F021     NOP
560:               l = (!(p < 0) && (p < l)) ? p : l;
1135C  BE21     BTFSC 0x21, 7, ACCESS
1135E  EFB3     GOTO 0x11366
11360  F089     NOP
11362  EFB5     GOTO 0x1136A
11364  F089     NOP
11366  EFCC     GOTO 0x11398
11368  F089     NOP
1136A  5022     MOVF d, W, ACCESS
1136C  5C20     SUBWF fp, W, ACCESS
1136E  5021     MOVF 0x21, W, ACCESS
11370  0A80     XORLW 0x80
11372  6E12     MOVWF counter, ACCESS
11374  5023     MOVF 0x23, W, ACCESS
11376  0A80     XORLW 0x80
11378  5812     SUBWFB counter, W, ACCESS
1137A  A0D8     BTFSS 0xFD8, 0, ACCESS
1137C  EFC2     GOTO 0x11384
1137E  F089     NOP
11380  EFC4     GOTO 0x11388
11382  F089     NOP
11384  EFC6     GOTO 0x1138C
11386  F089     NOP
11388  EFCC     GOTO 0x11398
1138A  F089     NOP
1138E  F080     NOP
11390  F022     NOP
11394  F084     NOP
11396  F023     NOP
561:               p = l;
1139A  F088     NOP
1139C  F020     NOP
113A0  F08C     NOP
113A2  F021     NOP
562:               w = width;
113A6  F1A4     NOP
113A8  F01C     NOP
113AC  F1A8     NOP
113AE  F01D     NOP
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
113B0  0100     MOVLB 0x0
113B2  B16D     BTFSC flags, 0, BANKED
113B4  EFDE     GOTO 0x113BC
113B6  F089     NOP
113B8  EFE0     GOTO 0x113C0
113BA  F089     NOP
113BC  EFFF     GOTO 0x113FE
113BE  F089     NOP
113C0  EFF0     GOTO 0x113E0
113C2  F089     NOP
566:                   while (l < w) {
113E0  501C     MOVF w, W, ACCESS
113E2  5C22     SUBWF d, W, ACCESS
113E4  5023     MOVF 0x23, W, ACCESS
113E6  0A80     XORLW 0x80
113E8  6E12     MOVWF counter, ACCESS
113EA  501D     MOVF 0x1D, W, ACCESS
113EC  0A80     XORLW 0x80
113EE  5812     SUBWFB counter, W, ACCESS
113F0  A0D8     BTFSS 0xFD8, 0, ACCESS
113F2  EFFD     GOTO 0x113FA
113F4  F089     NOP
113F6  EFFF     GOTO 0x113FE
113F8  F089     NOP
113FA  EFE2     GOTO 0x113C4
113FC  F089     NOP
567:                       fputc(' ', fp);
113C4  0E00     MOVLW 0x0
113C6  6E06     MOVWF product, ACCESS
113C8  0E20     MOVLW 0x20
113CA  6E05     MOVWF c, ACCESS
113CE  F038     NOP
113D0  F007     NOP
113D4  F03C     NOP
113D6  F008     NOP
113D8  ECD2     CALL 0x11BA4, 0
113DA  F08D     NOP
568:                       ++l;
113DC  4A22     INFSNZ d, F, ACCESS
113DE  2A23     INCF 0x23, F, ACCESS
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
113FE  0E00     MOVLW 0x0
11400  6E1B     MOVWF 0x1B, ACCESS
11402  0E00     MOVLW 0x0
11404  6E1A     MOVWF counter, ACCESS
574:               while (i < p) {
11406  EF2A     GOTO 0x11454
11408  F08A     NOP
11454  5020     MOVF fp, W, ACCESS
11456  5C1A     SUBWF counter, W, ACCESS
11458  501B     MOVF 0x1B, W, ACCESS
1145A  0A80     XORLW 0x80
1145C  6E12     MOVWF counter, ACCESS
1145E  5021     MOVF 0x21, W, ACCESS
11460  0A80     XORLW 0x80
11462  5812     SUBWFB counter, W, ACCESS
11464  A0D8     BTFSS 0xFD8, 0, ACCESS
11466  EF37     GOTO 0x1146E
11468  F08A     NOP
1146A  EF39     GOTO 0x11472
1146C  F08A     NOP
1146E  EF05     GOTO 0x1140A
11470  F08A     NOP
575:                   fputc(*cp, fp);
1140C  F07B     NOP
1140E  FFF6     NOP
11412  F07F     NOP
11414  FFF7     NOP
11416  0E00     MOVLW 0x0
11418  6EF8     MOVWF 0xFF8, ACCESS
1141A  0E1F     MOVLW 0x1F
1141C  64F7     CPFSGT 0xFF7, ACCESS
1141E  D003     BRA 0x1426
11420  0008     TBLRD*
11422  50F5     MOVF 0xFF5, W, ACCESS
11424  D007     BRA 0x1434
11428  FFDB     NOP
1142A  FFE9     NOP
1142E  FFDF     NOP
11430  FFEA     NOP
11432  50EF     MOVF 0xFEF, W, ACCESS
11434  6E12     MOVWF counter, ACCESS
11436  5012     MOVF counter, W, ACCESS
11438  6E05     MOVWF c, ACCESS
1143A  6A06     CLRF product, ACCESS
1143E  F038     NOP
11440  F007     NOP
11444  F03C     NOP
11446  F008     NOP
11448  ECD2     CALL 0x11BA4, 0
1144A  F08D     NOP
576:                   ++cp;
1144C  4A1E     INFSNZ cp, F, ACCESS
1144E  2A1F     INCF 0x1F, F, ACCESS
577:                   ++i;
11450  4A1A     INFSNZ counter, F, ACCESS
11452  2A1B     INCF 0x1B, F, ACCESS
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
11472  0100     MOVLB 0x0
11474  A16D     BTFSS flags, 0, BANKED
11476  EF3F     GOTO 0x1147E
11478  F08A     NOP
1147A  EF41     GOTO 0x11482
1147C  F08A     NOP
1147E  EF60     GOTO 0x114C0
11480  F08A     NOP
11482  EF51     GOTO 0x114A2
11484  F08A     NOP
582:                   while (l < w) {
114A2  501C     MOVF w, W, ACCESS
114A4  5C22     SUBWF d, W, ACCESS
114A6  5023     MOVF 0x23, W, ACCESS
114A8  0A80     XORLW 0x80
114AA  6E12     MOVWF counter, ACCESS
114AC  501D     MOVF 0x1D, W, ACCESS
114AE  0A80     XORLW 0x80
114B0  5812     SUBWFB counter, W, ACCESS
114B2  A0D8     BTFSS 0xFD8, 0, ACCESS
114B4  EF5E     GOTO 0x114BC
114B6  F08A     NOP
114B8  EF60     GOTO 0x114C0
114BA  F08A     NOP
114BC  EF43     GOTO 0x11486
114BE  F08A     NOP
583:                       fputc(' ', fp);
11486  0E00     MOVLW 0x0
11488  6E06     MOVWF product, ACCESS
1148A  0E20     MOVLW 0x20
1148C  6E05     MOVWF c, ACCESS
11490  F038     NOP
11492  F007     NOP
11496  F03C     NOP
11498  F008     NOP
1149A  ECD2     CALL 0x11BA4, 0
1149C  F08D     NOP
584:                       ++l;
1149E  4A22     INFSNZ d, F, ACCESS
114A0  2A23     INCF 0x23, F, ACCESS
585:                   }
586:               }
114C2  F088     NOP
114C4  F00E     NOP
114C8  F08C     NOP
114CA  F00F     NOP
587:           
588:               return l;
589:           }
114CC  0012     RETURN 0
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
11094  0100     MOVLB 0x0
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
600:                   flags &= ~ZERO_FLAG;
110A4  936D     BCF flags, 1, BANKED
601:               }
602:               p = (0 < prec) ? prec : 1;
110A6  BF6C     BTFSC 0x6C, 7, BANKED
110A8  EF60     GOTO 0x110C0
110AA  F088     NOP
110AC  516C     MOVF 0x6C, W, BANKED
110AE  E106     BNZ 0x10BC
110B0  056B     DECF prec, W, BANKED
110B2  B0D8     BTFSC 0xFD8, 0, ACCESS
110B4  EF5E     GOTO 0x110BC
110B6  F088     NOP
110B8  EF60     GOTO 0x110C0
110BA  F088     NOP
110BC  EF66     GOTO 0x110CC
110BE  F088     NOP
110C0  0E00     MOVLW 0x0
110C2  6E33     MOVWF 0x33, ACCESS
110C4  0E01     MOVLW 0x1
110C6  6E32     MOVWF p, ACCESS
110C8  EF6C     GOTO 0x110D8
110CA  F088     NOP
110CE  F1AC     NOP
110D0  F032     NOP
110D4  F1B0     NOP
110D6  F033     NOP
603:               w = width;
110DA  F1A4     NOP
110DC  F034     NOP
110E0  F1A8     NOP
110E2  F035     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
110E6  F088     NOP
110E8  F036     NOP
110EC  F08C     NOP
110EE  F037     NOP
110F2  F090     NOP
110F4  F038     NOP
110F8  F094     NOP
110FA  F039     NOP
110FE  F098     NOP
11100  F03A     NOP
11104  F09C     NOP
11106  F03B     NOP
1110A  F0A0     NOP
1110C  F03C     NOP
11110  F0A4     NOP
11112  F03D     NOP
607:               i = sizeof(dbuf) - 1;
11114  0E00     MOVLW 0x0
11116  6E3F     MOVWF 0x3F, ACCESS
11118  0E1F     MOVLW 0x1F
1111A  6E3E     MOVWF i, ACCESS
608:               dbuf[i] = '\0';
1111C  0E00     MOVLW 0x0
1111E  6F9B     MOVWF 0x9B, BANKED
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
11120  EF28     GOTO 0x11250
11122  F089     NOP
11250  503E     MOVF i, W, ACCESS
11252  103F     IORWF 0x3F, W, ACCESS
11254  B4D8     BTFSC 0xFD8, 2, ACCESS
11256  EF2F     GOTO 0x1125E
11258  F089     NOP
1125A  EF31     GOTO 0x11262
1125C  F089     NOP
1125E  EF62     GOTO 0x112C4
11260  F089     NOP
11262  5036     MOVF n, W, ACCESS
11264  1037     IORWF p, W, ACCESS
11266  1038     IORWF 0x38, W, ACCESS
11268  1039     IORWF w, W, ACCESS
1126A  103A     IORWF 0x3A, W, ACCESS
1126C  103B     IORWF n, W, ACCESS
1126E  103C     IORWF 0x3C, W, ACCESS
11270  103D     IORWF 0x3D, W, ACCESS
11272  A4D8     BTFSS 0xFD8, 2, ACCESS
11274  EF3E     GOTO 0x1127C
11276  F089     NOP
11278  EF40     GOTO 0x11280
1127A  F089     NOP
1127C  EF92     GOTO 0x11124
1127E  F088     NOP
11280  BE33     BTFSC 0x33, 7, ACCESS
11282  EF4D     GOTO 0x1129A
11284  F089     NOP
11286  5033     MOVF 0x33, W, ACCESS
11288  E106     BNZ 0x1296
1128A  0432     DECF p, W, ACCESS
1128C  B0D8     BTFSC 0xFD8, 0, ACCESS
1128E  EF4B     GOTO 0x11296
11290  F089     NOP
11292  EF4D     GOTO 0x1129A
11294  F089     NOP
11296  EF92     GOTO 0x11124
11298  F088     NOP
1129A  BE35     BTFSC 0x35, 7, ACCESS
1129C  EF58     GOTO 0x112B0
1129E  F089     NOP
112A0  5035     MOVF 0x35, W, ACCESS
112A2  E108     BNZ 0x12B4
112A4  0434     DECF w, W, ACCESS
112A6  A0D8     BTFSS 0xFD8, 0, ACCESS
112A8  EF58     GOTO 0x112B0
112AA  F089     NOP
112AC  EF5A     GOTO 0x112B4
112AE  F089     NOP
112B0  EF62     GOTO 0x112C4
112B2  F089     NOP
112B4  0100     MOVLB 0x0
112B6  B36D     BTFSC flags, 1, BANKED
112B8  EF60     GOTO 0x112C0
112BA  F089     NOP
112BC  EF62     GOTO 0x112C4
112BE  F089     NOP
112C0  EF92     GOTO 0x11124
112C2  F088     NOP
610:                   --i;
11124  063E     DECF i, F, ACCESS
11126  A0D8     BTFSS 0xFD8, 0, ACCESS
11128  063F     DECF 0x3F, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
1112A  0E7C     MOVLW 0x7C
1112C  243E     ADDWF i, W, ACCESS
1112E  6ED9     MOVWF 0xFD9, ACCESS
11130  0E00     MOVLW 0x0
11132  203F     ADDWFC 0x3F, W, ACCESS
11134  6EDA     MOVWF 0xFDA, ACCESS
11138  F0D8     NOP
1113A  F002     NOP
1113E  F0DC     NOP
11140  F003     NOP
11144  F0E0     NOP
11146  F004     NOP
1114A  F0E4     NOP
1114C  F005     NOP
11150  F0E8     NOP
11152  F006     NOP
11156  F0EC     NOP
11158  F007     NOP
1115C  F0F0     NOP
1115E  F008     NOP
11162  F0F4     NOP
11164  F009     NOP
11166  0E0A     MOVLW 0xA
11168  6E0A     MOVWF divisor, ACCESS
1116A  0E00     MOVLW 0x0
1116C  6E0B     MOVWF 0xB, ACCESS
1116E  0E00     MOVLW 0x0
11170  6E0C     MOVWF 0xC, ACCESS
11172  0E00     MOVLW 0x0
11174  6E0D     MOVWF 0xD, ACCESS
11176  0E00     MOVLW 0x0
11178  6E0E     MOVWF s, ACCESS
1117A  0E00     MOVLW 0x0
1117C  6E0F     MOVWF neg, ACCESS
1117E  0E00     MOVLW 0x0
11180  6E10     MOVWF fp, ACCESS
11182  0E00     MOVLW 0x0
11184  6E11     MOVWF 0x11, ACCESS
11186  EC62     CALL 0x11AC4, 0
11188  F08D     NOP
1118C  F008     NOP
1118E  F02A     NOP
11192  F00C     NOP
11194  F02B     NOP
11198  F010     NOP
1119A  F02C     NOP
1119E  F014     NOP
111A0  F02D     NOP
111A4  F018     NOP
111A6  F02E     NOP
111AA  F01C     NOP
111AC  F02F     NOP
111B0  F020     NOP
111B2  F030     NOP
111B6  F024     NOP
111B8  F031     NOP
111BA  502A     MOVF x, W, ACCESS
111BC  0F30     ADDLW 0x30
111BE  6EDF     MOVWF 0xFDF, ACCESS
612:                   --p;
111C0  0632     DECF p, F, ACCESS
111C2  A0D8     BTFSS 0xFD8, 0, ACCESS
111C4  0633     DECF 0x33, F, ACCESS
613:                   --w;
111C6  0634     DECF w, F, ACCESS
111C8  A0D8     BTFSS 0xFD8, 0, ACCESS
111CA  0635     DECF 0x35, F, ACCESS
614:                   n = n / 10;
111CE  F0D8     NOP
111D0  F002     NOP
111D4  F0DC     NOP
111D6  F003     NOP
111DA  F0E0     NOP
111DC  F004     NOP
111E0  F0E4     NOP
111E2  F005     NOP
111E6  F0E8     NOP
111E8  F006     NOP
111EC  F0EC     NOP
111EE  F007     NOP
111F2  F0F0     NOP
111F4  F008     NOP
111F8  F0F4     NOP
111FA  F009     NOP
111FC  0E0A     MOVLW 0xA
111FE  6E0A     MOVWF divisor, ACCESS
11200  0E00     MOVLW 0x0
11202  6E0B     MOVWF 0xB, ACCESS
11204  0E00     MOVLW 0x0
11206  6E0C     MOVWF 0xC, ACCESS
11208  0E00     MOVLW 0x0
1120A  6E0D     MOVWF 0xD, ACCESS
1120C  0E00     MOVLW 0x0
1120E  6E0E     MOVWF s, ACCESS
11210  0E00     MOVLW 0x0
11212  6E0F     MOVWF neg, ACCESS
11214  0E00     MOVLW 0x0
11216  6E10     MOVWF fp, ACCESS
11218  0E00     MOVLW 0x0
1121A  6E11     MOVWF 0x11, ACCESS
1121C  EC71     CALL 0x118E2, 0
1121E  F08C     NOP
11222  F008     NOP
11224  F036     NOP
11228  F00C     NOP
1122A  F037     NOP
1122E  F010     NOP
11230  F038     NOP
11234  F014     NOP
11236  F039     NOP
1123A  F018     NOP
1123C  F03A     NOP
11240  F01C     NOP
11242  F03B     NOP
11246  F020     NOP
11248  F03C     NOP
1124C  F024     NOP
1124E  F03D     NOP
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
112C6  F080     NOP
112C8  F015     NOP
112CC  F084     NOP
112CE  F016     NOP
112D0  0E7C     MOVLW 0x7C
112D2  243E     ADDWF i, W, ACCESS
112D4  6E17     MOVWF buf, ACCESS
112D6  0E00     MOVLW 0x0
112D8  203F     ADDWFC 0x3F, W, ACCESS
112DA  6E18     MOVWF 0x18, ACCESS
112DE  F0D0     NOP
112E0  F019     NOP
112E4  F0D4     NOP
112E6  F01A     NOP
112E8  ECF1     CALL 0x119E2, 0
112EA  F08C     NOP
112EE  F054     NOP
112F0  F020     NOP
112F4  F058     NOP
112F6  F021     NOP
619:           }
112F8  0012     RETURN 0
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
10D6C  0100     MOVLB 0x0
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
10D7C  936D     BCF flags, 1, BANKED
631:               }
632:               p = (0 < prec) ? prec : 1;
10D7E  BF6C     BTFSC 0x6C, 7, BANKED
10D80  EFCC     GOTO 0x10D98
10D82  F086     NOP
10D84  516C     MOVF 0x6C, W, BANKED
10D86  E106     BNZ 0xD94
10D88  056B     DECF prec, W, BANKED
10D8A  B0D8     BTFSC 0xFD8, 0, ACCESS
10D8C  EFCA     GOTO 0x10D94
10D8E  F086     NOP
10D90  EFCC     GOTO 0x10D98
10D92  F086     NOP
10D94  EFD2     GOTO 0x10DA4
10D96  F086     NOP
10D98  0E00     MOVLW 0x0
10D9A  6E38     MOVWF 0x38, ACCESS
10D9C  0E01     MOVLW 0x1
10D9E  6E37     MOVWF p, ACCESS
10DA0  EFD8     GOTO 0x10DB0
10DA2  F086     NOP
10DA6  F1AC     NOP
10DA8  F037     NOP
10DAC  F1B0     NOP
10DAE  F038     NOP
633:               w = width;
10DB2  F1A4     NOP
10DB4  F039     NOP
10DB8  F1A8     NOP
10DBA  F03A     NOP
634:               if (flags & POUND_FLAG) {
10DBC  A96D     BTFSS flags, 4, BANKED
10DBE  EFE3     GOTO 0x10DC6
10DC0  F086     NOP
10DC2  EFE5     GOTO 0x10DCA
10DC4  F086     NOP
10DC6  EFE9     GOTO 0x10DD2
10DC8  F086     NOP
635:                   w -= 2;
10DCA  0EFE     MOVLW 0xFE
10DCC  2639     ADDWF w, F, ACCESS
10DCE  0EFF     MOVLW 0xFF
10DD0  223A     ADDWFC 0x3A, F, ACCESS
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
10DD4  F088     NOP
10DD6  F03B     NOP
10DDA  F08C     NOP
10DDC  F03C     NOP
10DE0  F090     NOP
10DE2  F03D     NOP
10DE6  F094     NOP
10DE8  F03E     NOP
10DEC  F098     NOP
10DEE  F03F     NOP
10DF2  F09C     NOP
10DF4  F040     NOP
10DF8  F0A0     NOP
10DFA  F041     NOP
10DFE  F0A4     NOP
10E00  F042     NOP
640:               i = sizeof(dbuf) - 1;
10E02  0E00     MOVLW 0x0
10E04  6E44     MOVWF 0x44, ACCESS
10E06  0E1F     MOVLW 0x1F
10E08  6E43     MOVWF i, ACCESS
641:               dbuf[i] = '\0';
10E0A  0E00     MOVLW 0x0
10E0C  6F9B     MOVWF 0x9B, BANKED
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
10E0E  EFD1     GOTO 0x10FA2
10E10  F087     NOP
10FA2  BE44     BTFSC 0x44, 7, ACCESS
10FA4  EFDD     GOTO 0x10FBA
10FA6  F087     NOP
10FA8  5044     MOVF 0x44, W, ACCESS
10FAA  E109     BNZ 0xFBE
10FAC  0E02     MOVLW 0x2
10FAE  5C43     SUBWF i, W, ACCESS
10FB0  A0D8     BTFSS 0xFD8, 0, ACCESS
10FB2  EFDD     GOTO 0x10FBA
10FB4  F087     NOP
10FB6  EFDF     GOTO 0x10FBE
10FB8  F087     NOP
10FBA  EF10     GOTO 0x11020
10FBC  F088     NOP
10FBE  503B     MOVF n, W, ACCESS
10FC0  103C     IORWF 0x3C, W, ACCESS
10FC2  103D     IORWF 0x3D, W, ACCESS
10FC4  103E     IORWF i, W, ACCESS
10FC6  103F     IORWF 0x3F, W, ACCESS
10FC8  1040     IORWF 0x40, W, ACCESS
10FCA  1041     IORWF 0x41, W, ACCESS
10FCC  1042     IORWF 0x42, W, ACCESS
10FCE  A4D8     BTFSS 0xFD8, 2, ACCESS
10FD0  EFEC     GOTO 0x10FD8
10FD2  F087     NOP
10FD4  EFEE     GOTO 0x10FDC
10FD6  F087     NOP
10FD8  EF09     GOTO 0x10E12
10FDA  F087     NOP
10FDC  BE38     BTFSC 0x38, 7, ACCESS
10FDE  EFFB     GOTO 0x10FF6
10FE0  F087     NOP
10FE2  5038     MOVF 0x38, W, ACCESS
10FE4  E106     BNZ 0xFF2
10FE6  0437     DECF p, W, ACCESS
10FE8  B0D8     BTFSC 0xFD8, 0, ACCESS
10FEA  EFF9     GOTO 0x10FF2
10FEC  F087     NOP
10FEE  EFFB     GOTO 0x10FF6
10FF0  F087     NOP
10FF2  EF09     GOTO 0x10E12
10FF4  F087     NOP
10FF6  BE3A     BTFSC 0x3A, 7, ACCESS
10FF8  EF06     GOTO 0x1100C
10FFA  F088     NOP
10FFC  503A     MOVF 0x3A, W, ACCESS
10FFE  E108     BNZ 0x1010
11000  0439     DECF w, W, ACCESS
11002  A0D8     BTFSS 0xFD8, 0, ACCESS
11004  EF06     GOTO 0x1100C
11006  F088     NOP
11008  EF08     GOTO 0x11010
1100A  F088     NOP
1100C  EF10     GOTO 0x11020
1100E  F088     NOP
11010  0100     MOVLB 0x0
11012  B36D     BTFSC flags, 1, BANKED
11014  EF0E     GOTO 0x1101C
11016  F088     NOP
11018  EF10     GOTO 0x11020
1101A  F088     NOP
1101C  EF09     GOTO 0x10E12
1101E  F087     NOP
643:                   --i;
10E12  0643     DECF i, F, ACCESS
10E14  A0D8     BTFSS 0xFD8, 0, ACCESS
10E16  0644     DECF 0x44, F, ACCESS
644:                   c = n & 0x0f;
10E18  0E0F     MOVLW 0xF
10E1A  143B     ANDWF n, W, ACCESS
10E1C  6E45     MOVWF c, ACCESS
10E1E  6A46     CLRF 0x46, ACCESS
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
10E20  BE46     BTFSC 0x46, 7, ACCESS
10E22  EF1C     GOTO 0x10E38
10E24  F087     NOP
10E26  5046     MOVF 0x46, W, ACCESS
10E28  E109     BNZ 0xE3C
10E2A  0E0A     MOVLW 0xA
10E2C  5C45     SUBWF c, W, ACCESS
10E2E  A0D8     BTFSS 0xFD8, 0, ACCESS
10E30  EF1C     GOTO 0x10E38
10E32  F087     NOP
10E34  EF1E     GOTO 0x10E3C
10E36  F087     NOP
10E38  EF26     GOTO 0x10E4C
10E3A  F087     NOP
10E3C  0E57     MOVLW 0x57
10E3E  2445     ADDWF c, W, ACCESS
10E40  6E45     MOVWF c, ACCESS
10E42  0E00     MOVLW 0x0
10E44  2046     ADDWFC 0x46, W, ACCESS
10E46  6E46     MOVWF 0x46, ACCESS
10E48  EF2C     GOTO 0x10E58
10E4A  F087     NOP
10E4C  0E30     MOVLW 0x30
10E4E  2445     ADDWF c, W, ACCESS
10E50  6E45     MOVWF c, ACCESS
10E52  0E00     MOVLW 0x0
10E54  2046     ADDWFC 0x46, W, ACCESS
10E56  6E46     MOVWF 0x46, ACCESS
646:                   if (isupper((int)x) && isalpha(c)) {
10E58  0EBF     MOVLW 0xBF
10E5A  6E2B     MOVWF 0x2B, ACCESS
10E5C  0EFF     MOVLW 0xFF
10E5E  6E2C     MOVWF 0x2C, ACCESS
10E60  502A     MOVF x, W, ACCESS
10E62  6E2D     MOVWF 0x2D, ACCESS
10E64  6A2E     CLRF 0x2E, ACCESS
10E66  502B     MOVF 0x2B, W, ACCESS
10E68  262D     ADDWF 0x2D, F, ACCESS
10E6A  502C     MOVF 0x2C, W, ACCESS
10E6C  222E     ADDWFC 0x2E, F, ACCESS
10E6E  502E     MOVF 0x2E, W, ACCESS
10E70  E10A     BNZ 0xE86
10E72  0E1A     MOVLW 0x1A
10E74  5C2D     SUBWF 0x2D, W, ACCESS
10E76  A0D8     BTFSS 0xFD8, 0, ACCESS
10E78  EF40     GOTO 0x10E80
10E7A  F087     NOP
10E7C  EF43     GOTO 0x10E86
10E7E  F087     NOP
10E80  0E01     MOVLW 0x1
10E82  EF44     GOTO 0x10E88
10E84  F087     NOP
10E86  0E00     MOVLW 0x0
10E88  6E33     MOVWF 0x33, ACCESS
10E8A  6A34     CLRF w, ACCESS
10E8C  5033     MOVF 0x33, W, ACCESS
10E8E  1034     IORWF w, W, ACCESS
10E90  B4D8     BTFSC 0xFD8, 2, ACCESS
10E92  EF4D     GOTO 0x10E9A
10E94  F087     NOP
10E96  EF4F     GOTO 0x10E9E
10E98  F087     NOP
10E9A  EF83     GOTO 0x10F06
10E9C  F087     NOP
10E9E  0E9F     MOVLW 0x9F
10EA0  6E2B     MOVWF 0x2B, ACCESS
10EA2  0EFF     MOVLW 0xFF
10EA4  6E2C     MOVWF 0x2C, ACCESS
10EA6  0E20     MOVLW 0x20
10EA8  1045     IORWF c, W, ACCESS
10EAA  6E2D     MOVWF 0x2D, ACCESS
10EAC  0E00     MOVLW 0x0
10EAE  1046     IORWF 0x46, W, ACCESS
10EB0  6E2E     MOVWF 0x2E, ACCESS
10EB2  502B     MOVF 0x2B, W, ACCESS
10EB4  262D     ADDWF 0x2D, F, ACCESS
10EB6  502C     MOVF 0x2C, W, ACCESS
10EB8  222E     ADDWFC 0x2E, F, ACCESS
10EBA  502E     MOVF 0x2E, W, ACCESS
10EBC  E10A     BNZ 0xED2
10EBE  0E1A     MOVLW 0x1A
10EC0  5C2D     SUBWF 0x2D, W, ACCESS
10EC2  A0D8     BTFSS 0xFD8, 0, ACCESS
10EC4  EF66     GOTO 0x10ECC
10EC6  F087     NOP
10EC8  EF69     GOTO 0x10ED2
10ECA  F087     NOP
10ECC  0E01     MOVLW 0x1
10ECE  EF6A     GOTO 0x10ED4
10ED0  F087     NOP
10ED2  0E00     MOVLW 0x0
10ED4  6E35     MOVWF 0x35, ACCESS
10ED6  6A36     CLRF n, ACCESS
10ED8  5035     MOVF 0x35, W, ACCESS
10EDA  1036     IORWF n, W, ACCESS
10EDC  B4D8     BTFSC 0xFD8, 2, ACCESS
10EDE  EF73     GOTO 0x10EE6
10EE0  F087     NOP
10EE2  EF75     GOTO 0x10EEA
10EE4  F087     NOP
10EE6  EF83     GOTO 0x10F06
10EE8  F087     NOP
647:                       c = toupper(c);
10EEC  F114     NOP
10EEE  F008     NOP
10EF2  F118     NOP
10EF4  F009     NOP
10EF6  EC5A     CALL 0x11CB4, 0
10EF8  F08E     NOP
10EFC  F020     NOP
10EFE  F045     NOP
10F02  F024     NOP
10F04  F046     NOP
648:                   }
649:                   dbuf[i] = (char)c;
10F06  0E7C     MOVLW 0x7C
10F08  2443     ADDWF i, W, ACCESS
10F0A  6ED9     MOVWF 0xFD9, ACCESS
10F0C  0E00     MOVLW 0x0
10F0E  2044     ADDWFC 0x44, W, ACCESS
10F10  6EDA     MOVWF 0xFDA, ACCESS
10F14  F117     NOP
10F16  FFDF     NOP
650:                   --p;
10F18  0637     DECF p, F, ACCESS
10F1A  A0D8     BTFSS 0xFD8, 0, ACCESS
10F1C  0638     DECF 0x38, F, ACCESS
651:                   --w;
10F1E  0639     DECF w, F, ACCESS
10F20  A0D8     BTFSS 0xFD8, 0, ACCESS
10F22  063A     DECF 0x3A, F, ACCESS
652:                   n = n >> 4;
10F26  F0EC     NOP
10F28  F02B     NOP
10F2C  F0F0     NOP
10F2E  F02C     NOP
10F32  F0F4     NOP
10F34  F02D     NOP
10F38  F0F8     NOP
10F3A  F02E     NOP
10F3E  F0FC     NOP
10F40  F02F     NOP
10F44  F100     NOP
10F46  F030     NOP
10F4A  F104     NOP
10F4C  F031     NOP
10F50  F108     NOP
10F52  F032     NOP
10F54  0E05     MOVLW 0x5
10F56  EFB6     GOTO 0x10F6C
10F58  F087     NOP
10F5A  90D8     BCF 0xFD8, 0, ACCESS
10F5C  3232     RRCF p, F, ACCESS
10F5E  3231     RRCF 0x31, F, ACCESS
10F60  3230     RRCF 0x30, F, ACCESS
10F62  322F     RRCF 0x2F, F, ACCESS
10F64  322E     RRCF 0x2E, F, ACCESS
10F66  322D     RRCF 0x2D, F, ACCESS
10F68  322C     RRCF 0x2C, F, ACCESS
10F6A  322B     RRCF 0x2B, F, ACCESS
10F6C  2EE8     DECFSZ 0xFE8, F, ACCESS
10F6E  EFAD     GOTO 0x10F5A
10F70  F087     NOP
10F74  F0AC     NOP
10F76  F03B     NOP
10F7A  F0B0     NOP
10F7C  F03C     NOP
10F80  F0B4     NOP
10F82  F03D     NOP
10F86  F0B8     NOP
10F88  F03E     NOP
10F8C  F0BC     NOP
10F8E  F03F     NOP
10F92  F0C0     NOP
10F94  F040     NOP
10F98  F0C4     NOP
10F9A  F041     NOP
10F9E  F0C8     NOP
10FA0  F042     NOP
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
11020  0100     MOVLB 0x0
11022  A96D     BTFSS flags, 4, BANKED
11024  EF16     GOTO 0x1102C
11026  F088     NOP
11028  EF18     GOTO 0x11030
1102A  F088     NOP
1102C  EF2F     GOTO 0x1105E
1102E  F088     NOP
657:                   --i;
11030  0643     DECF i, F, ACCESS
11032  A0D8     BTFSS 0xFD8, 0, ACCESS
11034  0644     DECF 0x44, F, ACCESS
658:                   dbuf[i] = x;
11036  0E7C     MOVLW 0x7C
11038  2443     ADDWF i, W, ACCESS
1103A  6ED9     MOVWF 0xFD9, ACCESS
1103C  0E00     MOVLW 0x0
1103E  2044     ADDWFC 0x44, W, ACCESS
11040  6EDA     MOVWF 0xFDA, ACCESS
11044  F0AB     NOP
11046  FFDF     NOP
659:                   --i;
11048  0643     DECF i, F, ACCESS
1104A  A0D8     BTFSS 0xFD8, 0, ACCESS
1104C  0644     DECF 0x44, F, ACCESS
660:                   dbuf[i] = '0';
1104E  0E7C     MOVLW 0x7C
11050  2443     ADDWF i, W, ACCESS
11052  6ED9     MOVWF 0xFD9, ACCESS
11054  0E00     MOVLW 0x0
11056  2044     ADDWFC 0x44, W, ACCESS
11058  6EDA     MOVWF 0xFDA, ACCESS
1105A  0E30     MOVLW 0x30
1105C  6EDF     MOVWF 0xFDF, ACCESS
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
11060  F080     NOP
11062  F015     NOP
11066  F084     NOP
11068  F016     NOP
1106A  0E7C     MOVLW 0x7C
1106C  2443     ADDWF i, W, ACCESS
1106E  6E17     MOVWF buf, ACCESS
11070  0E00     MOVLW 0x0
11072  2044     ADDWFC 0x44, W, ACCESS
11074  6E18     MOVWF 0x18, ACCESS
11078  F0E4     NOP
1107A  F019     NOP
1107E  F0E8     NOP
11080  F01A     NOP
11082  ECF1     CALL 0x119E2, 0
11084  F08C     NOP
11088  F054     NOP
1108A  F020     NOP
1108E  F058     NOP
11090  F021     NOP
665:           }
11092  0012     RETURN 0
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
681:                   ++*fmt;
107AE  F127     NOP
107B0  FFD9     NOP
107B4  F12B     NOP
107B6  FFDA     NOP
107B8  2ADE     INCF 0xFDE, F, ACCESS
107BA  0E00     MOVLW 0x0
107BC  22DD     ADDWFC 0xFDD, F, ACCESS
682:           
683:                   flags = width = 0;
107BE  0E00     MOVLW 0x0
107C0  0100     MOVLB 0x0
107C2  6F6A     MOVWF 0x6A, BANKED
107C4  0E00     MOVLW 0x0
107C6  6F69     MOVWF width, BANKED
107C8  C069     MOVFF width, flags
107CA  F06D     NOP
107CC  C06A     MOVFF 0x6A, 0x6E
107CE  F06E     NOP
684:                   prec = -1;
107D0  696B     SETF prec, BANKED
107D2  696C     SETF 0x6C, BANKED
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
107D4  0E00     MOVLW 0x0
107D6  6FDA     MOVWF 0xDA, BANKED
107D8  0E00     MOVLW 0x0
107DA  6FD9     MOVWF done, BANKED
689:                   while (!done) {
107DC  EF3E     GOTO 0x1087C
107DE  F084     NOP
1087C  51D9     MOVF done, W, BANKED
1087E  11DA     IORWF 0xDA, W, BANKED
10880  B4D8     BTFSC 0xFD8, 2, ACCESS
10882  EF45     GOTO 0x1088A
10884  F084     NOP
10886  EF47     GOTO 0x1088E
10888  F084     NOP
1088A  EF0E     GOTO 0x1081C
1088C  F084     NOP
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
107E0  816D     BSF flags, 0, BANKED
693:                               ++*fmt;
107E4  F127     NOP
107E6  FFD9     NOP
107EA  F12B     NOP
107EC  FFDA     NOP
107EE  2ADE     INCF 0xFDE, F, ACCESS
107F0  0E00     MOVLW 0x0
107F2  22DD     ADDWFC 0xFDD, F, ACCESS
694:                               break;
107F4  EF3E     GOTO 0x1087C
107F6  F084     NOP
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
107F8  836D     BSF flags, 1, BANKED
107FA  EFF1     GOTO 0x107E2
107FC  F083     NOP
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
107FE  856D     BSF flags, 2, BANKED
10800  EFF1     GOTO 0x107E2
10802  F083     NOP
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
10804  876D     BSF flags, 3, BANKED
10806  EFF1     GOTO 0x107E2
10808  F083     NOP
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
1080A  896D     BSF flags, 4, BANKED
1080C  EFF1     GOTO 0x107E2
1080E  F083     NOP
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
10810  0E00     MOVLW 0x0
10812  6FDA     MOVWF 0xDA, BANKED
10814  0E01     MOVLW 0x1
10816  6FD9     MOVWF done, BANKED
713:                               break;
10818  EF3E     GOTO 0x1087C
1081A  F084     NOP
714:                       }
1081E  F127     NOP
10820  FFD9     NOP
10824  F12B     NOP
10826  FFDA     NOP
1082A  FF7B     NOP
1082C  FFF6     NOP
10830  FF77     NOP
10832  FFF7     NOP
10834  0E00     MOVLW 0x0
10836  6EF8     MOVWF 0xFF8, ACCESS
10838  0008     TBLRD*
1083A  50F5     MOVF 0xFF5, W, ACCESS
1083C  6E4D     MOVWF 0x4D, ACCESS
1083E  6A4E     CLRF 0x4E, ACCESS
10840  504E     MOVF 0x4E, W, ACCESS
10842  0A00     XORLW 0x0
10844  B4D8     BTFSC 0xFD8, 2, ACCESS
10846  EF27     GOTO 0x1084E
10848  F084     NOP
1084A  EF08     GOTO 0x10810
1084C  F084     NOP
1084E  504D     MOVF 0x4D, W, ACCESS
10850  0A20     XORLW 0x20
10852  B4D8     BTFSC 0xFD8, 2, ACCESS
10854  EF02     GOTO 0x10804
10856  F084     NOP
10858  0A03     XORLW 0x3
1085A  B4D8     BTFSC 0xFD8, 2, ACCESS
1085C  EF05     GOTO 0x1080A
1085E  F084     NOP
10860  0A08     XORLW 0x8
10862  B4D8     BTFSC 0xFD8, 2, ACCESS
10864  EFFF     GOTO 0x107FE
10866  F083     NOP
10868  0A06     XORLW 0x6
1086A  B4D8     BTFSC 0xFD8, 2, ACCESS
1086C  EFF0     GOTO 0x107E0
1086E  F083     NOP
10870  0A1D     XORLW 0x1D
10872  B4D8     BTFSC 0xFD8, 2, ACCESS
10874  EFFC     GOTO 0x107F8
10876  F083     NOP
10878  EF08     GOTO 0x10810
1087A  F084     NOP
715:                   }
716:                   if (flags & MINUS_FLAG) {
1088E  A16D     BTFSS flags, 0, BANKED
10890  EF4C     GOTO 0x10898
10892  F084     NOP
10894  EF4E     GOTO 0x1089C
10896  F084     NOP
10898  EF4F     GOTO 0x1089E
1089A  F084     NOP
717:                       flags &= ~ZERO_FLAG;
1089C  936D     BCF flags, 1, BANKED
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
108A0  F127     NOP
108A2  FFD9     NOP
108A6  F12B     NOP
108A8  FFDA     NOP
108AC  FF7B     NOP
108AE  FFF6     NOP
108B2  FF77     NOP
108B4  FFF7     NOP
108B6  0E00     MOVLW 0x0
108B8  6EF8     MOVWF 0xFF8, ACCESS
108BA  0008     TBLRD*
108BC  50F5     MOVF 0xFF5, W, ACCESS
108BE  0A2A     XORLW 0x2A
108C0  A4D8     BTFSS 0xFD8, 2, ACCESS
108C2  EF65     GOTO 0x108CA
108C4  F084     NOP
108C6  EF67     GOTO 0x108CE
108C8  F084     NOP
108CA  EF9A     GOTO 0x10934
108CC  F084     NOP
724:                       ++*fmt;
108D0  F127     NOP
108D2  FFD9     NOP
108D6  F12B     NOP
108D8  FFDA     NOP
108DA  2ADE     INCF 0xFDE, F, ACCESS
108DC  0E00     MOVLW 0x0
108DE  22DD     ADDWFC 0xFDD, F, ACCESS
725:                       width = va_arg(ap, int);
108E2  F12F     NOP
108E4  FFD9     NOP
108E8  F133     NOP
108EA  FFDA     NOP
108EE  FF7C     NOP
108F0  F04D     NOP
108F2  0E02     MOVLW 0x2
108F4  26DE     ADDWF 0xFDE, F, ACCESS
108F8  FF7C     NOP
108FA  F04E     NOP
108FC  0E00     MOVLW 0x0
108FE  22DD     ADDWFC 0xFDD, F, ACCESS
10902  F137     NOP
10904  FFD9     NOP
10908  F13B     NOP
1090A  FFDA     NOP
1090E  FF78     NOP
10910  F069     NOP
10914  FF74     NOP
10916  F06A     NOP
726:                       if (width < 0) {
10918  BF6A     BTFSC 0x6A, 7, BANKED
1091A  EF93     GOTO 0x10926
1091C  F084     NOP
1091E  EF91     GOTO 0x10922
10920  F084     NOP
10922  EFEC     GOTO 0x109D8
10924  F084     NOP
727:                           flags |= MINUS_FLAG;
10926  816D     BSF flags, 0, BANKED
728:                           width = -width;
10928  6D69     NEGF width, BANKED
1092A  1F6A     COMF 0x6A, F, BANKED
1092C  B0D8     BTFSC 0xFD8, 0, ACCESS
1092E  2B6A     INCF 0x6A, F, BANKED
10930  EFEC     GOTO 0x109D8
10932  F084     NOP
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
10936  F127     NOP
10938  FFD9     NOP
1093C  F12B     NOP
1093E  FFDA     NOP
10942  FF78     NOP
10944  F009     NOP
10948  FF74     NOP
1094A  F00A     NOP
1094C  EC67     CALL 0x114CE, 0
1094E  F08A     NOP
10952  F024     NOP
10954  F069     NOP
10958  F028     NOP
1095A  F06A     NOP
732:                       while (isdigit((*fmt)[0])) {
1095C  EFB9     GOTO 0x10972
1095E  F084     NOP
10972  0ED0     MOVLW 0xD0
10974  6E4D     MOVWF 0x4D, ACCESS
10976  0EFF     MOVLW 0xFF
10978  6E4E     MOVWF 0x4E, ACCESS
1097C  F127     NOP
1097E  FFD9     NOP
10982  F12B     NOP
10984  FFDA     NOP
10988  FF7B     NOP
1098A  FFF6     NOP
1098E  FF77     NOP
10990  FFF7     NOP
10992  0E00     MOVLW 0x0
10994  6EF8     MOVWF 0xFF8, ACCESS
10996  0008     TBLRD*
10998  50F5     MOVF 0xFF5, W, ACCESS
1099A  6E4F     MOVWF 0x4F, ACCESS
1099C  6A50     CLRF 0x50, ACCESS
1099E  504D     MOVF 0x4D, W, ACCESS
109A0  264F     ADDWF 0x4F, F, ACCESS
109A2  504E     MOVF 0x4E, W, ACCESS
109A4  2250     ADDWFC 0x50, F, ACCESS
109A6  5050     MOVF 0x50, W, ACCESS
109A8  E10A     BNZ 0x9BE
109AA  0E0A     MOVLW 0xA
109AC  5C4F     SUBWF 0x4F, W, ACCESS
109AE  A0D8     BTFSS 0xFD8, 0, ACCESS
109B0  EFDC     GOTO 0x109B8
109B2  F084     NOP
109B4  EFDF     GOTO 0x109BE
109B6  F084     NOP
109B8  0E01     MOVLW 0x1
109BA  EFE0     GOTO 0x109C0
109BC  F084     NOP
109BE  0E00     MOVLW 0x0
109C0  0100     MOVLB 0x0
109C2  6FDB     MOVWF 0xDB, BANKED
109C4  6BDC     CLRF 0xDC, BANKED
109C6  51DB     MOVF 0xDB, W, BANKED
109C8  11DC     IORWF 0xDC, W, BANKED
109CA  A4D8     BTFSS 0xFD8, 2, ACCESS
109CC  EFEA     GOTO 0x109D4
109CE  F084     NOP
109D0  EFEC     GOTO 0x109D8
109D2  F084     NOP
109D4  EFB0     GOTO 0x10960
109D6  F084     NOP
733:                           ++*fmt;
10962  F127     NOP
10964  FFD9     NOP
10968  F12B     NOP
1096A  FFDA     NOP
1096C  2ADE     INCF 0xFDE, F, ACCESS
1096E  0E00     MOVLW 0x0
10970  22DD     ADDWFC 0xFDD, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
826:           
827:                       ++*fmt;
828:                       ll = (long long)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
109DA  F127     NOP
109DC  FFD9     NOP
109E0  F12B     NOP
109E2  FFDA     NOP
109E6  FF7B     NOP
109E8  FFF6     NOP
109EC  FF77     NOP
109EE  FFF7     NOP
109F0  0E00     MOVLW 0x0
109F2  6EF8     MOVWF 0xFF8, ACCESS
109F4  0008     TBLRD*
109F6  50F5     MOVF 0xFF5, W, ACCESS
109F8  0A73     XORLW 0x73
109FA  A4D8     BTFSS 0xFD8, 2, ACCESS
109FC  EF02     GOTO 0x10A04
109FE  F085     NOP
10A00  EF04     GOTO 0x10A08
10A02  F085     NOP
10A04  EF3F     GOTO 0x10A7E
10A06  F085     NOP
1150:          
1151:                      ++*fmt;
10A0A  F127     NOP
10A0C  FFD9     NOP
10A10  F12B     NOP
10A12  FFDA     NOP
10A14  2ADE     INCF 0xFDE, F, ACCESS
10A16  0E00     MOVLW 0x0
10A18  22DD     ADDWFC 0xFDD, F, ACCESS
1152:                      cp = va_arg(ap, char *);
10A1C  F12F     NOP
10A1E  FFD9     NOP
10A22  F133     NOP
10A24  FFDA     NOP
10A28  FF7C     NOP
10A2A  F04D     NOP
10A2C  0E02     MOVLW 0x2
10A2E  26DE     ADDWF 0xFDE, F, ACCESS
10A32  FF7C     NOP
10A34  F04E     NOP
10A36  0E00     MOVLW 0x0
10A38  22DD     ADDWFC 0xFDD, F, ACCESS
10A3C  F137     NOP
10A3E  FFD9     NOP
10A42  F13B     NOP
10A44  FFDA     NOP
10A48  FF78     NOP
10A4A  F0D7     NOP
10A4E  FF74     NOP
10A50  F0D8     NOP
1153:          
1154:                      return stoa(fp, cp);
10A54  F11C     NOP
10A56  F00E     NOP
10A5A  F120     NOP
10A5C  F00F     NOP
10A60  F35C     NOP
10A62  F010     NOP
10A66  F360     NOP
10A68  F011     NOP
10A6A  EC7D     CALL 0x112FA, 0
10A6C  F089     NOP
10A70  F038     NOP
10A72  F047     NOP
10A76  F03C     NOP
10A78  F048     NOP
10A7A  EFB5     GOTO 0x10D6A
10A7C  F086     NOP
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
10A80  F127     NOP
10A82  FFD9     NOP
10A86  F12B     NOP
10A88  FFDA     NOP
10A8C  FF7B     NOP
10A8E  FFF6     NOP
10A92  FF77     NOP
10A94  FFF7     NOP
10A96  0E00     MOVLW 0x0
10A98  6EF8     MOVWF 0xFF8, ACCESS
10A9A  0008     TBLRD*
10A9C  50F5     MOVF 0xFF5, W, ACCESS
10A9E  0A75     XORLW 0x75
10AA0  A4D8     BTFSS 0xFD8, 2, ACCESS
10AA2  EF55     GOTO 0x10AAA
10AA4  F085     NOP
10AA6  EF57     GOTO 0x10AAE
10AA8  F085     NOP
10AAA  EFB0     GOTO 0x10B60
10AAC  F085     NOP
1183:          
1184:                      ++*fmt;
10AB0  F127     NOP
10AB2  FFD9     NOP
10AB6  F12B     NOP
10AB8  FFDA     NOP
10ABA  2ADE     INCF 0xFDE, F, ACCESS
10ABC  0E00     MOVLW 0x0
10ABE  22DD     ADDWFC 0xFDD, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
10AC2  F12F     NOP
10AC4  FFD9     NOP
10AC8  F133     NOP
10ACA  FFDA     NOP
10ACE  FF7C     NOP
10AD0  F04D     NOP
10AD2  0E02     MOVLW 0x2
10AD4  26DE     ADDWF 0xFDE, F, ACCESS
10AD8  FF7C     NOP
10ADA  F04E     NOP
10ADC  0E00     MOVLW 0x0
10ADE  22DD     ADDWFC 0xFDD, F, ACCESS
10AE2  F137     NOP
10AE4  FFD9     NOP
10AE8  F13B     NOP
10AEA  FFDA     NOP
10AEE  FF78     NOP
10AF0  F04F     NOP
10AF4  FF74     NOP
10AF6  F050     NOP
10AFA  F13C     NOP
10AFC  F0DE     NOP
10B00  F140     NOP
10B02  F0DF     NOP
10B04  6BE0     CLRF 0xE0, BANKED
10B06  6BE1     CLRF 0xE1, BANKED
10B08  6BE2     CLRF 0xE2, BANKED
10B0A  6BE3     CLRF 0xE3, BANKED
10B0C  6BE4     CLRF 0xE4, BANKED
10B0E  6BE5     CLRF 0xE5, BANKED
1186:                                  
1187:                      return utoa(fp, llu);
10B12  F11C     NOP
10B14  F020     NOP
10B18  F120     NOP
10B1A  F021     NOP
10B1E  F378     NOP
10B20  F022     NOP
10B24  F37C     NOP
10B26  F023     NOP
10B2A  F380     NOP
10B2C  F024     NOP
10B30  F384     NOP
10B32  F025     NOP
10B36  F388     NOP
10B38  F026     NOP
10B3C  F38C     NOP
10B3E  F027     NOP
10B42  F390     NOP
10B44  F028     NOP
10B48  F394     NOP
10B4A  F029     NOP
10B4C  EC4A     CALL 0x11094, 0
10B4E  F088     NOP
10B52  F080     NOP
10B54  F047     NOP
10B58  F084     NOP
10B5A  F048     NOP
10B5C  EFB5     GOTO 0x10D6A
10B5E  F086     NOP
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
10B62  F127     NOP
10B64  FFD9     NOP
10B68  F12B     NOP
10B6A  FFDA     NOP
10B6E  FF7B     NOP
10B70  FFF6     NOP
10B74  FF77     NOP
10B76  FFF7     NOP
10B78  0E00     MOVLW 0x0
10B7A  6EF8     MOVWF 0xFF8, ACCESS
10B7C  0008     TBLRD*
10B7E  50F5     MOVF 0xFF5, W, ACCESS
10B80  0A78     XORLW 0x78
10B82  B4D8     BTFSC 0xFD8, 2, ACCESS
10B84  EFC6     GOTO 0x10B8C
10B86  F085     NOP
10B88  EFC8     GOTO 0x10B90
10B8A  F085     NOP
10B8C  EFE0     GOTO 0x10BC0
10B8E  F085     NOP
10B92  F127     NOP
10B94  FFD9     NOP
10B98  F12B     NOP
10B9A  FFDA     NOP
10B9E  FF7B     NOP
10BA0  FFF6     NOP
10BA4  FF77     NOP
10BA6  FFF7     NOP
10BA8  0E00     MOVLW 0x0
10BAA  6EF8     MOVWF 0xFF8, ACCESS
10BAC  0008     TBLRD*
10BAE  50F5     MOVF 0xFF5, W, ACCESS
10BB0  0A58     XORLW 0x58
10BB2  A4D8     BTFSS 0xFD8, 2, ACCESS
10BB4  EFDE     GOTO 0x10BBC
10BB6  F085     NOP
10BB8  EFE0     GOTO 0x10BC0
10BBA  F085     NOP
10BBC  EF4E     GOTO 0x10C9C
10BBE  F086     NOP
1275:          
1276:                      c = (*fmt)[0];
10BC2  F127     NOP
10BC4  FFD9     NOP
10BC8  F12B     NOP
10BCA  FFDA     NOP
10BCE  FF7B     NOP
10BD0  FFF6     NOP
10BD4  FF77     NOP
10BD6  FFF7     NOP
10BD8  0E00     MOVLW 0x0
10BDA  6EF8     MOVWF 0xFF8, ACCESS
10BDC  0008     TBLRD*
10BE0  FFD4     NOP
10BE2  F0DD     NOP
1277:                      ++*fmt;
10BE6  F127     NOP
10BE8  FFD9     NOP
10BEC  F12B     NOP
10BEE  FFDA     NOP
10BF0  2ADE     INCF 0xFDE, F, ACCESS
10BF2  0E00     MOVLW 0x0
10BF4  22DD     ADDWFC 0xFDD, F, ACCESS
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
10BF8  F12F     NOP
10BFA  FFD9     NOP
10BFE  F133     NOP
10C00  FFDA     NOP
10C04  FF7C     NOP
10C06  F04D     NOP
10C08  0E02     MOVLW 0x2
10C0A  26DE     ADDWF 0xFDE, F, ACCESS
10C0E  FF7C     NOP
10C10  F04E     NOP
10C12  0E00     MOVLW 0x0
10C14  22DD     ADDWFC 0xFDD, F, ACCESS
10C18  F137     NOP
10C1A  FFD9     NOP
10C1E  F13B     NOP
10C20  FFDA     NOP
10C24  FF78     NOP
10C26  F04F     NOP
10C2A  FF74     NOP
10C2C  F050     NOP
10C30  F13C     NOP
10C32  F0DE     NOP
10C36  F140     NOP
10C38  F0DF     NOP
10C3A  6BE0     CLRF 0xE0, BANKED
10C3C  6BE1     CLRF 0xE1, BANKED
10C3E  6BE2     CLRF 0xE2, BANKED
10C40  6BE3     CLRF 0xE3, BANKED
10C42  6BE4     CLRF 0xE4, BANKED
10C44  6BE5     CLRF 0xE5, BANKED
1279:                                  
1280:                      return xtoa(fp, llu, c);
10C48  F11C     NOP
10C4A  F020     NOP
10C4E  F120     NOP
10C50  F021     NOP
10C54  F378     NOP
10C56  F022     NOP
10C5A  F37C     NOP
10C5C  F023     NOP
10C60  F380     NOP
10C62  F024     NOP
10C66  F384     NOP
10C68  F025     NOP
10C6C  F388     NOP
10C6E  F026     NOP
10C72  F38C     NOP
10C74  F027     NOP
10C78  F390     NOP
10C7A  F028     NOP
10C7E  F394     NOP
10C80  F029     NOP
10C84  F374     NOP
10C86  F02A     NOP
10C88  ECB6     CALL 0x10D6C, 0
10C8A  F086     NOP
10C8E  F080     NOP
10C90  F047     NOP
10C94  F084     NOP
10C96  F048     NOP
10C98  EFB5     GOTO 0x10D6A
10C9A  F086     NOP
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
10C9E  F127     NOP
10CA0  FFD9     NOP
10CA4  F12B     NOP
10CA6  FFDA     NOP
10CAA  FF7B     NOP
10CAC  FFF6     NOP
10CB0  FF77     NOP
10CB2  FFF7     NOP
10CB4  0E00     MOVLW 0x0
10CB6  6EF8     MOVWF 0xFF8, ACCESS
10CB8  0008     TBLRD*
10CBA  50F5     MOVF 0xFF5, W, ACCESS
10CBC  0A25     XORLW 0x25
10CBE  A4D8     BTFSS 0xFD8, 2, ACCESS
10CC0  EF64     GOTO 0x10CC8
10CC2  F086     NOP
10CC4  EF66     GOTO 0x10CCC
10CC6  F086     NOP
10CC8  EF81     GOTO 0x10D02
10CCA  F086     NOP
1351:                      ++*fmt;
10CCE  F127     NOP
10CD0  FFD9     NOP
10CD4  F12B     NOP
10CD6  FFDA     NOP
10CD8  2ADE     INCF 0xFDE, F, ACCESS
10CDA  0E00     MOVLW 0x0
10CDC  22DD     ADDWFC 0xFDD, F, ACCESS
1352:                      fputc((int)'%', fp);
10CDE  0E00     MOVLW 0x0
10CE0  6E06     MOVWF product, ACCESS
10CE2  0E25     MOVLW 0x25
10CE4  6E05     MOVWF c, ACCESS
10CE8  F11C     NOP
10CEA  F007     NOP
10CEE  F120     NOP
10CF0  F008     NOP
10CF2  ECD2     CALL 0x11BA4, 0
10CF4  F08D     NOP
1353:                      return 1;
10CF6  0E00     MOVLW 0x0
10CF8  6E48     MOVWF 0x48, ACCESS
10CFA  0E01     MOVLW 0x1
10CFC  6E47     MOVWF fp, ACCESS
10CFE  EFB5     GOTO 0x10D6A
10D00  F086     NOP
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
10D04  F127     NOP
10D06  FFD9     NOP
10D0A  F12B     NOP
10D0C  FFDA     NOP
10D0E  2ADE     INCF 0xFDE, F, ACCESS
10D10  0E00     MOVLW 0x0
10D12  22DD     ADDWFC 0xFDD, F, ACCESS
1358:                  return 0;
10D14  0E00     MOVLW 0x0
10D16  6E48     MOVWF 0x48, ACCESS
10D18  0E00     MOVLW 0x0
10D1A  6E47     MOVWF fp, ACCESS
10D1C  EFB5     GOTO 0x10D6A
10D1E  F086     NOP
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
10D22  F127     NOP
10D24  FFD9     NOP
10D28  F12B     NOP
10D2A  FFDA     NOP
10D2E  FF7B     NOP
10D30  FFF6     NOP
10D34  FF77     NOP
10D36  FFF7     NOP
10D38  0E00     MOVLW 0x0
10D3A  6EF8     MOVWF 0xFF8, ACCESS
10D3C  0008     TBLRD*
10D3E  50F5     MOVF 0xFF5, W, ACCESS
10D40  6E05     MOVWF c, ACCESS
10D42  6A06     CLRF product, ACCESS
10D46  F11C     NOP
10D48  F007     NOP
10D4C  F120     NOP
10D4E  F008     NOP
10D50  ECD2     CALL 0x11BA4, 0
10D52  F08D     NOP
1363:              ++*fmt;
10D56  F127     NOP
10D58  FFD9     NOP
10D5C  F12B     NOP
10D5E  FFDA     NOP
10D60  2ADE     INCF 0xFDE, F, ACCESS
10D62  0E00     MOVLW 0x0
10D64  22DD     ADDWFC 0xFDD, F, ACCESS
10D66  EF7B     GOTO 0x10CF6
10D68  F086     NOP
1364:              return 1;
1365:          }
10D6A  0012     RETURN 0
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
11C3C  F14C     NOP
11C3E  F057     NOP
11C42  F150     NOP
11C44  F058     NOP
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1374:              nout = 0;
11C46  0E00     MOVLW 0x0
11C48  0100     MOVLB 0x0
11C4A  6F68     MOVWF 0x68, BANKED
11C4C  0E00     MOVLW 0x0
11C4E  6F67     MOVWF nout, BANKED
1375:              while (*cfmt) {
11C50  EF41     GOTO 0x11C82
11C52  F08E     NOP
11C84  F15F     NOP
11C86  FFF6     NOP
11C8A  F163     NOP
11C8C  FFF7     NOP
11C8E  0E00     MOVLW 0x0
11C90  6EF8     MOVWF 0xFF8, ACCESS
11C92  0008     TBLRD*
11C94  50F5     MOVF 0xFF5, W, ACCESS
11C96  0900     IORLW 0x0
11C98  A4D8     BTFSS 0xFD8, 2, ACCESS
11C9A  EF51     GOTO 0x11CA2
11C9C  F08E     NOP
11C9E  EF53     GOTO 0x11CA6
11CA0  F08E     NOP
11CA2  EF2A     GOTO 0x11C54
11CA4  F08E     NOP
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
11C56  F144     NOP
11C58  F047     NOP
11C5C  F148     NOP
11C5E  F048     NOP
11C60  0E57     MOVLW 0x57
11C62  6E49     MOVWF fmt, ACCESS
11C64  0E00     MOVLW 0x0
11C66  6E4A     MOVWF 0x4A, ACCESS
11C6A  F154     NOP
11C6C  F04B     NOP
11C70  F158     NOP
11C72  F04C     NOP
11C74  ECBE     CALL 0x1077C, 0
11C76  F083     NOP
11C78  5047     MOVF fp, W, ACCESS
11C7A  0100     MOVLB 0x0
11C7C  2767     ADDWF nout, F, BANKED
11C7E  5048     MOVF 0x48, W, ACCESS
11C80  2368     ADDWFC 0x68, F, BANKED
1377:              }
1378:              return nout;
11CA8  F19C     NOP
11CAA  F051     NOP
11CAE  F1A0     NOP
11CB0  F052     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
11CB2  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/atoi.c  -------------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
114CE  0E00     MOVLW 0x0
114D0  6E17     MOVWF buf, ACCESS
114D2  0E00     MOVLW 0x0
114D4  6E16     MOVWF n, ACCESS
114D6  0E00     MOVLW 0x0
114D8  6E10     MOVWF fp, ACCESS
114DA  0E00     MOVLW 0x0
114DC  6E0F     MOVWF neg, ACCESS
5:             {
6:             	int n=0, neg=0;
7:             	while (isspace(*s)) s++;
114DE  EF73     GOTO 0x114E6
114E0  F08A     NOP
114E2  4A09     INFSNZ s, F, ACCESS
114E4  2A0A     INCF divisor, F, ACCESS
114E6  0E01     MOVLW 0x1
114E8  6E15     MOVWF fp, ACCESS
114EC  F027     NOP
114EE  FFF6     NOP
114F2  F02B     NOP
114F4  FFF7     NOP
114F6  0E00     MOVLW 0x0
114F8  6EF8     MOVWF 0xFF8, ACCESS
114FA  0008     TBLRD*
114FC  50F5     MOVF 0xFF5, W, ACCESS
114FE  0A20     XORLW 0x20
11500  B4D8     BTFSC 0xFD8, 2, ACCESS
11502  EF85     GOTO 0x1150A
11504  F08A     NOP
11506  EF87     GOTO 0x1150E
11508  F08A     NOP
1150A  EFA8     GOTO 0x11550
1150C  F08A     NOP
1150E  0EF7     MOVLW 0xF7
11510  6E0B     MOVWF 0xB, ACCESS
11512  0EFF     MOVLW 0xFF
11514  6E0C     MOVWF 0xC, ACCESS
11518  F027     NOP
1151A  FFF6     NOP
1151E  F02B     NOP
11520  FFF7     NOP
11522  0E00     MOVLW 0x0
11524  6EF8     MOVWF 0xFF8, ACCESS
11526  0008     TBLRD*
11528  50F5     MOVF 0xFF5, W, ACCESS
1152A  6E0D     MOVWF 0xD, ACCESS
1152C  6A0E     CLRF s, ACCESS
1152E  500B     MOVF 0xB, W, ACCESS
11530  260D     ADDWF 0xD, F, ACCESS
11532  500C     MOVF 0xC, W, ACCESS
11534  220E     ADDWFC s, F, ACCESS
11536  500E     MOVF s, W, ACCESS
11538  E109     BNZ 0x154C
1153A  0E05     MOVLW 0x5
1153C  5C0D     SUBWF 0xD, W, ACCESS
1153E  A0D8     BTFSS 0xFD8, 0, ACCESS
11540  EFA4     GOTO 0x11548
11542  F08A     NOP
11544  EFA6     GOTO 0x1154C
11546  F08A     NOP
11548  EFA8     GOTO 0x11550
1154A  F08A     NOP
1154C  0E00     MOVLW 0x0
1154E  6E15     MOVWF fp, ACCESS
11552  F054     NOP
11554  F011     NOP
11556  6A12     CLRF counter, ACCESS
11558  5011     MOVF 0x11, W, ACCESS
1155A  1012     IORWF counter, W, ACCESS
1155C  A4D8     BTFSS 0xFD8, 2, ACCESS
1155E  EFB3     GOTO 0x11566
11560  F08A     NOP
11562  EFB5     GOTO 0x1156A
11564  F08A     NOP
11566  EF71     GOTO 0x114E2
11568  F08A     NOP
1156A  EFBF     GOTO 0x1157E
1156C  F08A     NOP
8:             	switch (*s) {
9:             	case '-': neg=1;
1156E  0E00     MOVLW 0x0
11570  6E10     MOVWF fp, ACCESS
11572  0E01     MOVLW 0x1
11574  6E0F     MOVWF neg, ACCESS
10:            	case '+': s++;
11576  4A09     INFSNZ s, F, ACCESS
11578  2A0A     INCF divisor, F, ACCESS
11:            	}
1157A  EFFE     GOTO 0x115FC
1157C  F08A     NOP
11580  F027     NOP
11582  FFF6     NOP
11586  F02B     NOP
11588  FFF7     NOP
1158A  0E00     MOVLW 0x0
1158C  6EF8     MOVWF 0xFF8, ACCESS
1158E  0008     TBLRD*
11590  50F5     MOVF 0xFF5, W, ACCESS
11592  6E0B     MOVWF 0xB, ACCESS
11594  6A0C     CLRF 0xC, ACCESS
11596  500C     MOVF 0xC, W, ACCESS
11598  0A00     XORLW 0x0
1159A  B4D8     BTFSC 0xFD8, 2, ACCESS
1159C  EFD2     GOTO 0x115A4
1159E  F08A     NOP
115A0  EFFE     GOTO 0x115FC
115A2  F08A     NOP
115A4  500B     MOVF 0xB, W, ACCESS
115A6  0A2B     XORLW 0x2B
115A8  B4D8     BTFSC 0xFD8, 2, ACCESS
115AA  EFBB     GOTO 0x11576
115AC  F08A     NOP
115AE  0A06     XORLW 0x6
115B0  B4D8     BTFSC 0xFD8, 2, ACCESS
115B2  EFB7     GOTO 0x1156E
115B4  F08A     NOP
115B6  EFFE     GOTO 0x115FC
115B8  F08A     NOP
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
115FC  0ED0     MOVLW 0xD0
115FE  6E0B     MOVWF 0xB, ACCESS
11600  0EFF     MOVLW 0xFF
11602  6E0C     MOVWF 0xC, ACCESS
11606  F027     NOP
11608  FFF6     NOP
1160C  F02B     NOP
1160E  FFF7     NOP
11610  0E00     MOVLW 0x0
11612  6EF8     MOVWF 0xFF8, ACCESS
11614  0008     TBLRD*
11616  50F5     MOVF 0xFF5, W, ACCESS
11618  6E0D     MOVWF 0xD, ACCESS
1161A  6A0E     CLRF s, ACCESS
1161C  500B     MOVF 0xB, W, ACCESS
1161E  260D     ADDWF 0xD, F, ACCESS
11620  500C     MOVF 0xC, W, ACCESS
11622  220E     ADDWFC s, F, ACCESS
11624  500E     MOVF s, W, ACCESS
11626  E10A     BNZ 0x163C
11628  0E0A     MOVLW 0xA
1162A  5C0D     SUBWF 0xD, W, ACCESS
1162C  A0D8     BTFSS 0xFD8, 0, ACCESS
1162E  EF1B     GOTO 0x11636
11630  F08B     NOP
11632  EF1E     GOTO 0x1163C
11634  F08B     NOP
11636  0E01     MOVLW 0x1
11638  EF1F     GOTO 0x1163E
1163A  F08B     NOP
1163C  0E00     MOVLW 0x0
1163E  6E13     MOVWF i, ACCESS
11640  6A14     CLRF 0x14, ACCESS
11642  5013     MOVF i, W, ACCESS
11644  1014     IORWF 0x14, W, ACCESS
11646  A4D8     BTFSS 0xFD8, 2, ACCESS
11648  EF28     GOTO 0x11650
1164A  F08B     NOP
1164C  EF2A     GOTO 0x11654
1164E  F08B     NOP
11650  EFDD     GOTO 0x115BA
11652  F08A     NOP
14:            		n = 10*n - (*s++ - '0');
115BC  F058     NOP
115BE  F002     NOP
115C2  F05C     NOP
115C4  F003     NOP
115C6  0E00     MOVLW 0x0
115C8  6E05     MOVWF c, ACCESS
115CA  0E0A     MOVLW 0xA
115CC  6E04     MOVWF txData, ACCESS
115CE  ECCD     CALL 0x11F9A, 0
115D0  F08F     NOP
115D4  F027     NOP
115D6  FFF6     NOP
115DA  F02B     NOP
115DC  FFF7     NOP
115DE  0E00     MOVLW 0x0
115E0  6EF8     MOVWF 0xFF8, ACCESS
115E2  0008     TBLRD*
115E4  50F5     MOVF 0xFF5, W, ACCESS
115E6  5E02     SUBWF dividend, F, ACCESS
115E8  0E00     MOVLW 0x0
115EA  5A03     SUBWFB uart_id, F, ACCESS
115EC  0E30     MOVLW 0x30
115EE  2402     ADDWF dividend, W, ACCESS
115F0  6E16     MOVWF n, ACCESS
115F2  0E00     MOVLW 0x0
115F4  2003     ADDWFC uart_id, W, ACCESS
115F6  6E17     MOVWF buf, ACCESS
115F8  EFBB     GOTO 0x11576
115FA  F08A     NOP
15:            	return neg ? n : -n;
11654  500F     MOVF neg, W, ACCESS
11656  1010     IORWF fp, W, ACCESS
11658  A4D8     BTFSS 0xFD8, 2, ACCESS
1165A  EF31     GOTO 0x11662
1165C  F08B     NOP
1165E  EF33     GOTO 0x11666
11660  F08B     NOP
11662  EF45     GOTO 0x1168A
11664  F08B     NOP
11668  F058     NOP
1166A  F00B     NOP
1166E  F05C     NOP
11670  F00C     NOP
11672  1E0B     COMF 0xB, F, ACCESS
11674  1E0C     COMF 0xC, F, ACCESS
11676  4A0B     INFSNZ 0xB, F, ACCESS
11678  2A0C     INCF 0xC, F, ACCESS
1167C  F02C     NOP
1167E  F009     NOP
11682  F030     NOP
11684  F00A     NOP
11686  EF4B     GOTO 0x11696
11688  F08B     NOP
1168C  F058     NOP
1168E  F009     NOP
11692  F05C     NOP
11694  F00A     NOP
16:            }
11696  0012     RETURN 0
---  C:/Programs/Microchip/xc8/v2.10/pic/sources/c99/common/Umul16.c  -----------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
11F9A  5002     MOVF dividend, W, ACCESS
11F9C  0204     MULWF txData, ACCESS
11FA0  FFCC     NOP
11FA2  F006     NOP
11FA6  FFD0     NOP
11FA8  F007     NOP
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
11FAA  5002     MOVF dividend, W, ACCESS
11FAC  0205     MULWF c, ACCESS
11FAE  50F3     MOVF 0xFF3, W, ACCESS
11FB0  2607     ADDWF fp, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
11FB2  5003     MOVF uart_id, W, ACCESS
11FB4  0204     MULWF txData, ACCESS
11FB6  50F3     MOVF 0xFF3, W, ACCESS
11FB8  2607     ADDWF fp, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
11FBC  F018     NOP
11FBE  F002     NOP
11FC2  F01C     NOP
11FC4  F003     NOP
53:            }
11FC6  0012     RETURN 0
