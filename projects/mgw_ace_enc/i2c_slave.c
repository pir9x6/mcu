//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&&&   Author      :   Pierre BLACHÉ                                       &&&
//&&&   Version     :   v1.2                                                &&&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&&&   Description :   - Init i2c slave bus                                &&&
//&&&                   - handles interrupt                                 &&&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&&&   History     :                                                       &&&
//&&&   1.0 - 2014/09/05 - PBL - Creation                                   &&&
//&&&   1.1 - 2016/09/07 - PBL - Made library independant of Microchip's one&&&
//&&&   1.2 - 2016/09/12 - PBL - Removed clock stretching                   &&&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

#include "i2c_slave.h"
#include "i2c_registers.h"
#include <sys/attribs.h>
#include "hardware_profile.h"

u8 addr_flag = 0;  // Initialize AddFlag
u8 data_flag = 0;  // Initialize DataFlag

//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//------------------------- Init I2C slave bus --------------------------------
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
RESULT i2c1_slave_init(u8 slave_addr)
{
    // disable clock stretching
    I2C1CONbits.STREN = 0;

    // use 7-bit slave address
    I2C1CONbits.A10M = 0;

    // enable interface
    I2C1CONbits.ON = 1;

    // set the address of the slave module
    I2C1ADD = slave_addr; // 7 bits address;
    I2C1MSK = 0;

    // configure the interrupt priority for the I2C peripheral
    IPC6bits.I2C1IP = 3;

    // clear pending interrupts and enable I2C interrupts
    IFS0bits.I2C1SIF = 0;
    IEC0bits.I2C1SIE = 0;
    IEC0bits.I2C1SIE = 1;

    return SUCCESS;
}

RESULT i2c2_slave_init(u8 slave_addr)
{
    // disable clock stretching
    I2C2CONbits.STREN = 0;

    // use 7-bit slave address
    I2C2CONbits.A10M = 0;

    // enable interface
    I2C2CONbits.ON = 1;

    // set the address of the slave module
    I2C2ADD = slave_addr; // 7 bits address;
    I2C2MSK = 0;

    // configure the interrupt priority for the I2C peripheral
    IPC8bits.I2C2IP = 3;

    // clear pending interrupts and enable I2C interrupts
    IFS1bits.I2C2SIF = 0;
    IEC1bits.I2C2SIE = 0;
    IEC1bits.I2C2SIE = 1;

    return SUCCESS;
}



//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//-------------------- IT Generated by I2C Slave Module -----------------------
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
void __ISR(_I2C_1_VECTOR, IPL3AUTO) _SlaveI2CHandler(void)
{
    static u8 i2c_addr = 0;
    static u8 i2c_data = 0;
    u8 read_data = 0;

    // check for MASTER and Bus events and respond accordingly
    if (IFS0bits.I2C1MIF == 1) {
        IFS0bits.I2C1MIF = 0;
        return;
    }
    if (IFS0bits.I2C1BIF == 1) {
        IFS0bits.I2C1BIF = 0;
        return;
    }

    // handle the incoming message

    //===============================================================
    // write, last byte was address
    if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 0)) {

        // reset any state variables needed by a message sequence
        // perform a dummy read of the address
        I2C1RCV;

        // release the clock to restart I2C
        I2C1CONbits.SCLREL = 1; // release the clock

        addr_flag = 1;


    //===============================================================
    // write, last byte was data
    } else if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 1)) {

        if (addr_flag == 1)             // reception of the address of the register
        {
            addr_flag = 0;
            data_flag = 1;

            // get address from master
            i2c_addr = I2C1RCV;

            // release the clock to restart I2C
            I2C1CONbits.SCLREL = 1;
        }
        else if (data_flag == 1)        // reception of the data to write in the register
        {
            addr_flag = 0;
            data_flag = 0;

            // get address from master
            i2c_data = I2C1RCV;

            //Release SCL1 line
            I2C1CONbits.SCLREL = 1;

            i2c_write_from_master(i2c_addr, i2c_data);
        }


    //===============================================================
    // read, last byte was address
    } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 0)) {

        // read of the slave device, read the address
        I2C1RCV;
        i2c_read_to_master(i2c_addr, &read_data);
        I2C1TRN = read_data;
        I2C1CONbits.SCLREL = 1;     // release the clock;


    //===============================================================
    // read, last byte was data
    } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 1)) {

        I2C1TRN = 0;
        I2C1CONbits.SCLREL = 1;     // release the clock;

    }

    // finally clear the slave interrupt flag
    IFS0bits.I2C1SIF = 0;
}


