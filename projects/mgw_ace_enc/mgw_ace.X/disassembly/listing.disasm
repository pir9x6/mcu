Disassembly Listing for mgw_ace
Generated From:
D:/SVN/MGW-ACE-ENC/Trunk/pic32/mgw_ace.X/dist/default/production/mgw_ace.X.production.elf
12 sept. 2016 13:53:48

---  d:/svn/mgw-ace-enc/trunk/pic32/tmp75.c  ------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Company     :   VITEC                                               &&&
4:                   //&&&   Date        :   13 November 2013                                    &&&
5:                   //&&&   Version     :   v1.0                                                &&&
6:                   //&&&   File        :   tmp75.c                                             &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   //&&&   Description :   - Init temperature sensor                           &&&
9:                   //&&&                   - reads temperature from sensor                     &&&
10:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:                  //&&&   History     :   v1.0 - Creation                                     &&&
12:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:                  
14:                  #include "tmp75.h"
15:                  
16:                  
17:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
18:                  //-------------------------- Read temperature ---------------------------------
19:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
20:                  RESULT tmp75_read_temp(I2C_BUS bus_id, u8 chip_addr, u16 *temp)
21:                  {
9D0078E0  27BDFFE0   ADDIU SP, SP, -32
9D0078E4  AFBF001C   SW RA, 28(SP)
9D0078E8  AFBE0018   SW S8, 24(SP)
9D0078EC  03A0F021   ADDU S8, SP, ZERO
9D0078F0  AFC40020   SW A0, 32(S8)
9D0078F4  00A01021   ADDU V0, A1, ZERO
9D0078F8  AFC60028   SW A2, 40(S8)
9D0078FC  A3C20024   SB V0, 36(S8)
22:                      u16 tmp = 0;
9D007900  A7C00010   SH ZERO, 16(S8)
23:                      u8 i2cbyte1 = 0;
9D007904  A3C00012   SB ZERO, 18(S8)
24:                      u8 i2cbyte2 = 0;
9D007908  A3C00013   SB ZERO, 19(S8)
25:                  
26:                      i2c_start (bus_id);
9D00790C  8FC40020   LW A0, 32(S8)
9D007910  0F4006CC   JAL i2c_start
9D007914  00000000   NOP
27:                      i2c_write (bus_id, (chip_addr<<1) & 0xFE);     // address of the chip
9D007918  93C20024   LBU V0, 36(S8)
9D00791C  00021040   SLL V0, V0, 1
9D007920  304200FF   ANDI V0, V0, 255
9D007924  8FC40020   LW A0, 32(S8)
9D007928  00402821   ADDU A1, V0, ZERO
9D00792C  0F400961   JAL i2c_write
9D007930  00000000   NOP
28:                      i2c_write (bus_id, TMP75_REG_TEMPERATURE);     // address of the register
9D007934  8FC40020   LW A0, 32(S8)
9D007938  00002821   ADDU A1, ZERO, ZERO
9D00793C  0F400961   JAL i2c_write
9D007940  00000000   NOP
29:                      i2c_rstart (bus_id);
9D007944  8FC40020   LW A0, 32(S8)
9D007948  0F400713   JAL i2c_rstart
9D00794C  00000000   NOP
30:                      i2c_write (bus_id, (chip_addr<<1) | 0x01);     // next operation is a reading
9D007950  93C20024   LBU V0, 36(S8)
9D007954  00021040   SLL V0, V0, 1
9D007958  7C021420   SEB V0, V0
9D00795C  34420001   ORI V0, V0, 1
9D007960  7C021420   SEB V0, V0
9D007964  304200FF   ANDI V0, V0, 255
9D007968  8FC40020   LW A0, 32(S8)
9D00796C  00402821   ADDU A1, V0, ZERO
9D007970  0F400961   JAL i2c_write
9D007974  00000000   NOP
31:                      i2c_read (bus_id, &i2cbyte1, ACK);             // integer part of the temperature
9D007978  27C20012   ADDIU V0, S8, 18
9D00797C  8FC40020   LW A0, 32(S8)
9D007980  00402821   ADDU A1, V0, ZERO
9D007984  24060001   ADDIU A2, ZERO, 1
9D007988  0F4008A0   JAL i2c_read
9D00798C  00000000   NOP
32:                      i2c_read (bus_id, &i2cbyte2, NACK);            // decimal part of the temperature
9D007990  27C20013   ADDIU V0, S8, 19
9D007994  8FC40020   LW A0, 32(S8)
9D007998  00402821   ADDU A1, V0, ZERO
9D00799C  00003021   ADDU A2, ZERO, ZERO
9D0079A0  0F4008A0   JAL i2c_read
9D0079A4  00000000   NOP
33:                      i2c_stop (bus_id);
9D0079A8  8FC40020   LW A0, 32(S8)
9D0079AC  0F40075A   JAL i2c_stop
9D0079B0  00000000   NOP
34:                  
35:                      tmp = (s16) (i2cbyte1<<8);
9D0079B4  93C20012   LBU V0, 18(S8)
9D0079B8  00021200   SLL V0, V0, 8
9D0079BC  A7C20010   SH V0, 16(S8)
36:                      tmp = (tmp | i2cbyte2)>>4;
9D0079C0  97C30010   LHU V1, 16(S8)
9D0079C4  93C20013   LBU V0, 19(S8)
9D0079C8  00621025   OR V0, V1, V0
9D0079CC  00021103   SRA V0, V0, 4
9D0079D0  A7C20010   SH V0, 16(S8)
37:                  
38:                      *temp = tmp;
9D0079D4  8FC20028   LW V0, 40(S8)
9D0079D8  97C30010   LHU V1, 16(S8)
9D0079DC  A4430000   SH V1, 0(V0)
39:                  
40:                      return SUCCESS;
9D0079E0  00001021   ADDU V0, ZERO, ZERO
41:                  }
9D0079E4  03C0E821   ADDU SP, S8, ZERO
9D0079E8  8FBF001C   LW RA, 28(SP)
9D0079EC  8FBE0018   LW S8, 24(SP)
9D0079F0  27BD0020   ADDIU SP, SP, 32
9D0079F4  03E00008   JR RA
9D0079F8  00000000   NOP
42:                  
43:                  
44:                  
45:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
46:                  //-------------------------- Configure sensor ---------------------------------
47:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
48:                  RESULT tmp75_configure(I2C_BUS bus_id, u8 chip_addr)
49:                  {
9D0079FC  27BDFFD8   ADDIU SP, SP, -40
9D007A00  AFBF0024   SW RA, 36(SP)
9D007A04  AFBE0020   SW S8, 32(SP)
9D007A08  03A0F021   ADDU S8, SP, ZERO
9D007A0C  AFC40028   SW A0, 40(S8)
9D007A10  00A01021   ADDU V0, A1, ZERO
9D007A14  A3C2002C   SB V0, 44(S8)
50:                      u8 tmp;
51:                      u8 error = 0;
9D007A18  A3C00010   SB ZERO, 16(S8)
52:                      RESULT result = SUCCESS;
9D007A1C  AFC00014   SW ZERO, 20(S8)
53:                  
54:                      // resolutions 12 bits, 220 ms for one conversion
55:                      result = i2c_write_reg(bus_id, chip_addr, TMP75_REG_CONFIGURATION, 0x60);   // 44ms
9D007A20  93C2002C   LBU V0, 44(S8)
9D007A24  8FC40028   LW A0, 40(S8)
9D007A28  00402821   ADDU A1, V0, ZERO
9D007A2C  24060001   ADDIU A2, ZERO, 1
9D007A30  24070060   ADDIU A3, ZERO, 96
9D007A34  0F400AF0   JAL i2c_write_reg
9D007A38  00000000   NOP
9D007A3C  AFC20014   SW V0, 20(S8)
56:                      if (result != SUCCESS) error++;
9D007A40  8FC20014   LW V0, 20(S8)
9D007A44  10400004   BEQ V0, ZERO, 0x9D007A58
9D007A48  00000000   NOP
9D007A4C  93C20010   LBU V0, 16(S8)
9D007A50  24420001   ADDIU V0, V0, 1
9D007A54  A3C20010   SB V0, 16(S8)
57:                  
58:                      // low limit
59:                      result = i2c_write_reg(bus_id, chip_addr, TMP75_REG_LIMIT_LOW, 0x00);
9D007A58  93C2002C   LBU V0, 44(S8)
9D007A5C  8FC40028   LW A0, 40(S8)
9D007A60  00402821   ADDU A1, V0, ZERO
9D007A64  24060002   ADDIU A2, ZERO, 2
9D007A68  00003821   ADDU A3, ZERO, ZERO
9D007A6C  0F400AF0   JAL i2c_write_reg
9D007A70  00000000   NOP
9D007A74  AFC20014   SW V0, 20(S8)
60:                      if (result != SUCCESS) error++;
9D007A78  8FC20014   LW V0, 20(S8)
9D007A7C  10400004   BEQ V0, ZERO, 0x9D007A90
9D007A80  00000000   NOP
9D007A84  93C20010   LBU V0, 16(S8)
9D007A88  24420001   ADDIU V0, V0, 1
9D007A8C  A3C20010   SB V0, 16(S8)
61:                  
62:                      // high limit
63:                      result = i2c_write_reg(bus_id, chip_addr, TMP75_REG_LIMIT_HIGH, 0x30);
9D007A90  93C2002C   LBU V0, 44(S8)
9D007A94  8FC40028   LW A0, 40(S8)
9D007A98  00402821   ADDU A1, V0, ZERO
9D007A9C  24060003   ADDIU A2, ZERO, 3
9D007AA0  24070030   ADDIU A3, ZERO, 48
9D007AA4  0F400AF0   JAL i2c_write_reg
9D007AA8  00000000   NOP
9D007AAC  AFC20014   SW V0, 20(S8)
64:                      if (result != SUCCESS) error++;
9D007AB0  8FC20014   LW V0, 20(S8)
9D007AB4  10400004   BEQ V0, ZERO, 0x9D007AC8
9D007AB8  00000000   NOP
9D007ABC  93C20010   LBU V0, 16(S8)
9D007AC0  24420001   ADDIU V0, V0, 1
9D007AC4  A3C20010   SB V0, 16(S8)
65:                  
66:                      // check if the chip have been well configured
67:                      result = i2c_read_reg(bus_id, chip_addr, TMP75_REG_CONFIGURATION, &tmp);
9D007AC8  93C3002C   LBU V1, 44(S8)
9D007ACC  27C20018   ADDIU V0, S8, 24
9D007AD0  8FC40028   LW A0, 40(S8)
9D007AD4  00602821   ADDU A1, V1, ZERO
9D007AD8  24060001   ADDIU A2, ZERO, 1
9D007ADC  00403821   ADDU A3, V0, ZERO
9D007AE0  0F400A9E   JAL i2c_read_reg
9D007AE4  00000000   NOP
9D007AE8  AFC20014   SW V0, 20(S8)
68:                      if (tmp != 0x60 || result != SUCCESS) error++;
9D007AEC  93C30018   LBU V1, 24(S8)
9D007AF0  24020060   ADDIU V0, ZERO, 96
9D007AF4  14620004   BNE V1, V0, 0x9D007B08
9D007AF8  00000000   NOP
9D007AFC  8FC20014   LW V0, 20(S8)
9D007B00  10400004   BEQ V0, ZERO, 0x9D007B14
9D007B04  00000000   NOP
9D007B08  93C20010   LBU V0, 16(S8)
9D007B0C  24420001   ADDIU V0, V0, 1
9D007B10  A3C20010   SB V0, 16(S8)
69:                  
70:                      result = i2c_read_reg(bus_id, chip_addr, TMP75_REG_LIMIT_LOW, &tmp);
9D007B14  93C3002C   LBU V1, 44(S8)
9D007B18  27C20018   ADDIU V0, S8, 24
9D007B1C  8FC40028   LW A0, 40(S8)
9D007B20  00602821   ADDU A1, V1, ZERO
9D007B24  24060002   ADDIU A2, ZERO, 2
9D007B28  00403821   ADDU A3, V0, ZERO
9D007B2C  0F400A9E   JAL i2c_read_reg
9D007B30  00000000   NOP
9D007B34  AFC20014   SW V0, 20(S8)
71:                      if (tmp != 0x00 || result != SUCCESS) error++;
9D007B38  93C20018   LBU V0, 24(S8)
9D007B3C  14400004   BNE V0, ZERO, 0x9D007B50
9D007B40  00000000   NOP
9D007B44  8FC20014   LW V0, 20(S8)
9D007B48  10400004   BEQ V0, ZERO, 0x9D007B5C
9D007B4C  00000000   NOP
9D007B50  93C20010   LBU V0, 16(S8)
9D007B54  24420001   ADDIU V0, V0, 1
9D007B58  A3C20010   SB V0, 16(S8)
72:                  
73:                      result = i2c_read_reg(bus_id, chip_addr, TMP75_REG_LIMIT_HIGH, &tmp);
9D007B5C  93C3002C   LBU V1, 44(S8)
9D007B60  27C20018   ADDIU V0, S8, 24
9D007B64  8FC40028   LW A0, 40(S8)
9D007B68  00602821   ADDU A1, V1, ZERO
9D007B6C  24060003   ADDIU A2, ZERO, 3
9D007B70  00403821   ADDU A3, V0, ZERO
9D007B74  0F400A9E   JAL i2c_read_reg
9D007B78  00000000   NOP
9D007B7C  AFC20014   SW V0, 20(S8)
74:                      if (tmp != 0x30 || result != SUCCESS) error++;
9D007B80  93C30018   LBU V1, 24(S8)
9D007B84  24020030   ADDIU V0, ZERO, 48
9D007B88  14620004   BNE V1, V0, 0x9D007B9C
9D007B8C  00000000   NOP
9D007B90  8FC20014   LW V0, 20(S8)
9D007B94  10400004   BEQ V0, ZERO, 0x9D007BA8
9D007B98  00000000   NOP
9D007B9C  93C20010   LBU V0, 16(S8)
9D007BA0  24420001   ADDIU V0, V0, 1
9D007BA4  A3C20010   SB V0, 16(S8)
75:                  
76:                  
77:                      if (error != 0)
9D007BA8  93C20010   LBU V0, 16(S8)
9D007BAC  10400004   BEQ V0, ZERO, 0x9D007BC0
9D007BB0  00000000   NOP
78:                          return ERROR;
9D007BB4  24020001   ADDIU V0, ZERO, 1
9D007BB8  0B401EF1   J 0x9D007BC4
9D007BBC  00000000   NOP
79:                      else
80:                          return SUCCESS;
9D007BC0  00001021   ADDU V0, ZERO, ZERO
81:                  }
9D007BC4  03C0E821   ADDU SP, S8, ZERO
9D007BC8  8FBF0024   LW RA, 36(SP)
9D007BCC  8FBE0020   LW S8, 32(SP)
9D007BD0  27BD0028   ADDIU SP, SP, 40
9D007BD4  03E00008   JR RA
9D007BD8  00000000   NOP
9D007BDC  3C018000   LUI AT, -32768
---  d:/svn/mgw-ace-enc/trunk/pic32/timer.c  ------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Version     :   v1.1                                                &&&
4:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:                   //&&&   Description :   - Init timers (16b or 32b)                          &&&
6:                   //&&&                   - configure timers period                           &&&
7:                   //&&&                   - manages interrupts on timer events                &&&
8:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9:                   //&&&   Infos       :   - timer 1: 16b                                      &&&
10:                  //&&&                   - timer 2: 16b                                      &&&
11:                  //&&&                   - timer 3: 16b                                      &&&
12:                  //&&&                   - timer 4: 16b                                      &&&
13:                  //&&&                   - timer 5: 16b                                      &&&
14:                  //&&&                   - timer 23: 32b (combinaison of timer 2 & 3)        &&&
15:                  //&&&                   - timer 45: 32b (combinaison of timer 4 & 5)        &&&
16:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
17:                  //&&&   History     :                                                       &&&
18:                  //&&&   1.0 - 2014/09/05 - PBL - First release                              &&&
19:                  //&&&   1.1 - 2016/08/19 - PBL - Added 32 bits timers                       &&&
20:                  //&&&   1.2 - 2016/09/07 - PBL - Made library independant of Microchip's one&&&
21:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
22:                  
23:                  #include "timer.h"
24:                  #include <sys/attribs.h>
25:                  
26:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
27:                  //------------------------------ Init Timer -----------------------------------
28:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
29:                  RESULT timer_init(TIMER_ID timer, u32 period_ms)
30:                  {
9D003C20  27BDFFE8   ADDIU SP, SP, -24
9D003C24  AFBF0014   SW RA, 20(SP)
9D003C28  AFBE0010   SW S8, 16(SP)
9D003C2C  03A0F021   ADDU S8, SP, ZERO
9D003C30  AFC40018   SW A0, 24(S8)
9D003C34  AFC5001C   SW A1, 28(S8)
31:                      if (timer == TIMER_1){
9D003C38  8FC20018   LW V0, 24(S8)
9D003C3C  14400038   BNE V0, ZERO, 0x9D003D20
9D003C40  00000000   NOP
32:                          TIMER_1_INT_ENABLE(0);
9D003C44  3C02BF88   LUI V0, -16504
9D003C48  24030010   ADDIU V1, ZERO, 16
9D003C4C  AC431064   SW V1, 4196(V0)
9D003C50  3C02BF88   LUI V0, -16504
9D003C54  AC401068   SW ZERO, 4200(V0)
33:                          T1CON = 0;
9D003C58  3C02BF80   LUI V0, -16512
9D003C5C  AC400600   SW ZERO, 1536(V0)
34:                  
35:                          T1CONbits.ON = 0;
9D003C60  3C03BF80   LUI V1, -16512
9D003C64  94620600   LHU V0, 1536(V1)
9D003C68  7C027BC4   INS V0, ZERO, 15, 1
9D003C6C  A4620600   SH V0, 1536(V1)
36:                          T1CONbits.TCKPS = TIMER_1_PS_1_64;
9D003C70  3C03BF80   LUI V1, -16512
9D003C74  94620600   LHU V0, 1536(V1)
9D003C78  24040002   ADDIU A0, ZERO, 2
9D003C7C  7C822904   INS V0, A0, 4, 2
9D003C80  A4620600   SH V0, 1536(V1)
37:                          T1CONbits.TCS = TIMER_SOURCE_INT;
9D003C84  3C03BF80   LUI V1, -16512
9D003C88  94620600   LHU V0, 1536(V1)
9D003C8C  7C020844   INS V0, ZERO, 1, 1
9D003C90  A4620600   SH V0, 1536(V1)
38:                          TMR1 = 0;
9D003C94  3C02BF80   LUI V0, -16512
9D003C98  AC400610   SW ZERO, 1552(V0)
39:                          T1CONbits.ON = 1;
9D003C9C  3C03BF80   LUI V1, -16512
9D003CA0  94620600   LHU V0, 1536(V1)
9D003CA4  24040001   ADDIU A0, ZERO, 1
9D003CA8  7C827BC4   INS V0, A0, 15, 1
9D003CAC  A4620600   SH V0, 1536(V1)
40:                  
41:                          // clear interrupt flag
42:                          TIMER_1_CLEAR_INT_FLAG();
9D003CB0  3C02BF88   LUI V0, -16504
9D003CB4  24030010   ADDIU V1, ZERO, 16
9D003CB8  AC431034   SW V1, 4148(V0)
43:                  
44:                          // set interrupt priority
45:                          IPC1CLR = _IPC1_T1IP_MASK;
9D003CBC  3C02BF88   LUI V0, -16504
9D003CC0  2403001C   ADDIU V1, ZERO, 28
9D003CC4  AC4310A4   SW V1, 4260(V0)
46:                          IPC1bits.T1IP = TIMER_INT_PRIOR_2;
9D003CC8  3C03BF88   LUI V1, -16504
9D003CCC  8C6210A0   LW V0, 4256(V1)
9D003CD0  24040002   ADDIU A0, ZERO, 2
9D003CD4  7C822084   INS V0, A0, 2, 3
9D003CD8  AC6210A0   SW V0, 4256(V1)
47:                  
48:                          // set interrupt subpriority
49:                          IPC1CLR = _IPC1_T1IS_MASK;
9D003CDC  3C02BF88   LUI V0, -16504
9D003CE0  24030003   ADDIU V1, ZERO, 3
9D003CE4  AC4310A4   SW V1, 4260(V0)
50:                          IPC1bits.T1IS = TIMER_INT_SUB_PRIOR_0;
9D003CE8  3C03BF88   LUI V1, -16504
9D003CEC  8C6210A0   LW V0, 4256(V1)
9D003CF0  7C020804   INS V0, ZERO, 0, 2
9D003CF4  AC6210A0   SW V0, 4256(V1)
51:                  
52:                          // enable interrupt
53:                          IEC0CLR = _IEC0_T1IE_MASK;
9D003CF8  3C02BF88   LUI V0, -16504
9D003CFC  24030010   ADDIU V1, ZERO, 16
9D003D00  AC431064   SW V1, 4196(V0)
54:                          IEC0bits.T1IE = 1;
9D003D04  3C03BF88   LUI V1, -16504
9D003D08  8C621060   LW V0, 4192(V1)
9D003D0C  24040001   ADDIU A0, ZERO, 1
9D003D10  7C822104   INS V0, A0, 4, 1
9D003D14  AC621060   SW V0, 4192(V1)
9D003D18  0B4010C5   J 0x9D004314
9D003D1C  00000000   NOP
55:                  
56:                      }else if (timer == TIMER_2){
9D003D20  8FC30018   LW V1, 24(S8)
9D003D24  24020001   ADDIU V0, ZERO, 1
9D003D28  14620038   BNE V1, V0, 0x9D003E0C
9D003D2C  00000000   NOP
57:                          TIMER_2_INT_ENABLE(0);
9D003D30  3C02BF88   LUI V0, -16504
9D003D34  24030100   ADDIU V1, ZERO, 256
9D003D38  AC431064   SW V1, 4196(V0)
9D003D3C  3C02BF88   LUI V0, -16504
9D003D40  AC401068   SW ZERO, 4200(V0)
58:                          T2CON = 0;
9D003D44  3C02BF80   LUI V0, -16512
9D003D48  AC400800   SW ZERO, 2048(V0)
59:                  
60:                          T2CONbits.ON = 0;
9D003D4C  3C03BF80   LUI V1, -16512
9D003D50  94620800   LHU V0, 2048(V1)
9D003D54  7C027BC4   INS V0, ZERO, 15, 1
9D003D58  A4620800   SH V0, 2048(V1)
61:                          T2CONbits.TCKPS = TIMER_PS_1_64;
9D003D5C  3C03BF80   LUI V1, -16512
9D003D60  94620800   LHU V0, 2048(V1)
9D003D64  24040006   ADDIU A0, ZERO, 6
9D003D68  7C823104   INS V0, A0, 4, 3
9D003D6C  A4620800   SH V0, 2048(V1)
62:                          T2CONbits.TCS = TIMER_SOURCE_INT;
9D003D70  3C03BF80   LUI V1, -16512
9D003D74  94620800   LHU V0, 2048(V1)
9D003D78  7C020844   INS V0, ZERO, 1, 1
9D003D7C  A4620800   SH V0, 2048(V1)
63:                          TMR2 = 0;
9D003D80  3C02BF80   LUI V0, -16512
9D003D84  AC400810   SW ZERO, 2064(V0)
64:                          T2CONbits.ON = 1;
9D003D88  3C03BF80   LUI V1, -16512
9D003D8C  94620800   LHU V0, 2048(V1)
9D003D90  24040001   ADDIU A0, ZERO, 1
9D003D94  7C827BC4   INS V0, A0, 15, 1
9D003D98  A4620800   SH V0, 2048(V1)
65:                  
66:                          // clear interrupt flag
67:                          TIMER_2_CLEAR_INT_FLAG();
9D003D9C  3C02BF88   LUI V0, -16504
9D003DA0  24030100   ADDIU V1, ZERO, 256
9D003DA4  AC431034   SW V1, 4148(V0)
68:                  
69:                          // set interrupt priority
70:                          IPC2CLR = _IPC2_T2IP_MASK;
9D003DA8  3C02BF88   LUI V0, -16504
9D003DAC  2403001C   ADDIU V1, ZERO, 28
9D003DB0  AC4310B4   SW V1, 4276(V0)
71:                          IPC2bits.T2IP = TIMER_INT_PRIOR_4;
9D003DB4  3C03BF88   LUI V1, -16504
9D003DB8  8C6210B0   LW V0, 4272(V1)
9D003DBC  24040004   ADDIU A0, ZERO, 4
9D003DC0  7C822084   INS V0, A0, 2, 3
9D003DC4  AC6210B0   SW V0, 4272(V1)
72:                  
73:                          // set interrupt subpriority
74:                          IPC2CLR = _IPC2_T2IS_MASK;
9D003DC8  3C02BF88   LUI V0, -16504
9D003DCC  24030003   ADDIU V1, ZERO, 3
9D003DD0  AC4310B4   SW V1, 4276(V0)
75:                          IPC2bits.T2IS = TIMER_INT_SUB_PRIOR_0;
9D003DD4  3C03BF88   LUI V1, -16504
9D003DD8  8C6210B0   LW V0, 4272(V1)
9D003DDC  7C020804   INS V0, ZERO, 0, 2
9D003DE0  AC6210B0   SW V0, 4272(V1)
76:                  
77:                          // enable interrupt
78:                          IEC0CLR = _IEC0_T2IE_MASK;
9D003DE4  3C02BF88   LUI V0, -16504
9D003DE8  24030100   ADDIU V1, ZERO, 256
9D003DEC  AC431064   SW V1, 4196(V0)
79:                          IEC0bits.T2IE = 1;
9D003DF0  3C03BF88   LUI V1, -16504
9D003DF4  8C621060   LW V0, 4192(V1)
9D003DF8  24040001   ADDIU A0, ZERO, 1
9D003DFC  7C824204   INS V0, A0, 8, 1
9D003E00  AC621060   SW V0, 4192(V1)
9D003E04  0B4010C5   J 0x9D004314
9D003E08  00000000   NOP
80:                  
81:                      }else if (timer == TIMER_3){
9D003E0C  8FC30018   LW V1, 24(S8)
9D003E10  24020002   ADDIU V0, ZERO, 2
9D003E14  14620038   BNE V1, V0, 0x9D003EF8
9D003E18  00000000   NOP
82:                          TIMER_3_INT_ENABLE(0);
9D003E1C  3C02BF88   LUI V0, -16504
9D003E20  24031000   ADDIU V1, ZERO, 4096
9D003E24  AC431064   SW V1, 4196(V0)
9D003E28  3C02BF88   LUI V0, -16504
9D003E2C  AC401068   SW ZERO, 4200(V0)
83:                          T3CON = 0;
9D003E30  3C02BF80   LUI V0, -16512
9D003E34  AC400A00   SW ZERO, 2560(V0)
84:                  
85:                          T3CONbits.ON = 0;
9D003E38  3C03BF80   LUI V1, -16512
9D003E3C  94620A00   LHU V0, 2560(V1)
9D003E40  7C027BC4   INS V0, ZERO, 15, 1
9D003E44  A4620A00   SH V0, 2560(V1)
86:                          T3CONbits.TCKPS = TIMER_PS_1_64;
9D003E48  3C03BF80   LUI V1, -16512
9D003E4C  94620A00   LHU V0, 2560(V1)
9D003E50  24040006   ADDIU A0, ZERO, 6
9D003E54  7C823104   INS V0, A0, 4, 3
9D003E58  A4620A00   SH V0, 2560(V1)
87:                          T3CONbits.TCS = TIMER_SOURCE_INT;
9D003E5C  3C03BF80   LUI V1, -16512
9D003E60  94620A00   LHU V0, 2560(V1)
9D003E64  7C020844   INS V0, ZERO, 1, 1
9D003E68  A4620A00   SH V0, 2560(V1)
88:                          TMR3 = 0;
9D003E6C  3C02BF80   LUI V0, -16512
9D003E70  AC400A10   SW ZERO, 2576(V0)
89:                          T3CONbits.ON = 1;
9D003E74  3C03BF80   LUI V1, -16512
9D003E78  94620A00   LHU V0, 2560(V1)
9D003E7C  24040001   ADDIU A0, ZERO, 1
9D003E80  7C827BC4   INS V0, A0, 15, 1
9D003E84  A4620A00   SH V0, 2560(V1)
90:                  
91:                          // clear interrupt flag
92:                          TIMER_3_CLEAR_INT_FLAG();
9D003E88  3C02BF88   LUI V0, -16504
9D003E8C  24031000   ADDIU V1, ZERO, 4096
9D003E90  AC431034   SW V1, 4148(V0)
93:                  
94:                          // set interrupt priority
95:                          IPC3CLR = _IPC3_T3IP_MASK;
9D003E94  3C02BF88   LUI V0, -16504
9D003E98  2403001C   ADDIU V1, ZERO, 28
9D003E9C  AC4310C4   SW V1, 4292(V0)
96:                          IPC3bits.T3IP = TIMER_INT_PRIOR_6;
9D003EA0  3C03BF88   LUI V1, -16504
9D003EA4  8C6210C0   LW V0, 4288(V1)
9D003EA8  24040006   ADDIU A0, ZERO, 6
9D003EAC  7C822084   INS V0, A0, 2, 3
9D003EB0  AC6210C0   SW V0, 4288(V1)
97:                  
98:                          // set interrupt subpriority
99:                          IPC3CLR = _IPC3_T3IS_MASK;
9D003EB4  3C02BF88   LUI V0, -16504
9D003EB8  24030003   ADDIU V1, ZERO, 3
9D003EBC  AC4310C4   SW V1, 4292(V0)
100:                         IPC3bits.T3IS = TIMER_INT_SUB_PRIOR_0;
9D003EC0  3C03BF88   LUI V1, -16504
9D003EC4  8C6210C0   LW V0, 4288(V1)
9D003EC8  7C020804   INS V0, ZERO, 0, 2
9D003ECC  AC6210C0   SW V0, 4288(V1)
101:                 
102:                         // enable interrupt
103:                         IEC0CLR = _IEC0_T3IE_MASK;
9D003ED0  3C02BF88   LUI V0, -16504
9D003ED4  24031000   ADDIU V1, ZERO, 4096
9D003ED8  AC431064   SW V1, 4196(V0)
104:                         IEC0bits.T3IE = 1;
9D003EDC  3C03BF88   LUI V1, -16504
9D003EE0  8C621060   LW V0, 4192(V1)
9D003EE4  24040001   ADDIU A0, ZERO, 1
9D003EE8  7C826304   INS V0, A0, 12, 1
9D003EEC  AC621060   SW V0, 4192(V1)
9D003EF0  0B4010C5   J 0x9D004314
9D003EF4  00000000   NOP
105:                 
106:                     }else if (timer == TIMER_4){
9D003EF8  8FC30018   LW V1, 24(S8)
9D003EFC  24020003   ADDIU V0, ZERO, 3
9D003F00  14620038   BNE V1, V0, 0x9D003FE4
9D003F04  00000000   NOP
107:                         TIMER_4_INT_ENABLE(0);
9D003F08  3C02BF88   LUI V0, -16504
9D003F0C  3C030001   LUI V1, 1
9D003F10  AC431064   SW V1, 4196(V0)
9D003F14  3C02BF88   LUI V0, -16504
9D003F18  AC401068   SW ZERO, 4200(V0)
108:                         T4CON = 0;
9D003F1C  3C02BF80   LUI V0, -16512
9D003F20  AC400C00   SW ZERO, 3072(V0)
109:                 
110:                         T4CONbits.ON = 0;
9D003F24  3C03BF80   LUI V1, -16512
9D003F28  94620C00   LHU V0, 3072(V1)
9D003F2C  7C027BC4   INS V0, ZERO, 15, 1
9D003F30  A4620C00   SH V0, 3072(V1)
111:                         T4CONbits.TCKPS = TIMER_PS_1_64;
9D003F34  3C03BF80   LUI V1, -16512
9D003F38  94620C00   LHU V0, 3072(V1)
9D003F3C  24040006   ADDIU A0, ZERO, 6
9D003F40  7C823104   INS V0, A0, 4, 3
9D003F44  A4620C00   SH V0, 3072(V1)
112:                         T4CONbits.TCS = TIMER_SOURCE_INT;
9D003F48  3C03BF80   LUI V1, -16512
9D003F4C  94620C00   LHU V0, 3072(V1)
9D003F50  7C020844   INS V0, ZERO, 1, 1
9D003F54  A4620C00   SH V0, 3072(V1)
113:                         TMR4 = 0;
9D003F58  3C02BF80   LUI V0, -16512
9D003F5C  AC400C10   SW ZERO, 3088(V0)
114:                         T4CONbits.ON = 1;
9D003F60  3C03BF80   LUI V1, -16512
9D003F64  94620C00   LHU V0, 3072(V1)
9D003F68  24040001   ADDIU A0, ZERO, 1
9D003F6C  7C827BC4   INS V0, A0, 15, 1
9D003F70  A4620C00   SH V0, 3072(V1)
115:                 
116:                         // clear interrupt flag
117:                         TIMER_4_CLEAR_INT_FLAG();
9D003F74  3C02BF88   LUI V0, -16504
9D003F78  3C030001   LUI V1, 1
9D003F7C  AC431034   SW V1, 4148(V0)
118:                 
119:                         // set interrupt priority
120:                         IPC4CLR = _IPC4_T4IP_MASK;
9D003F80  3C02BF88   LUI V0, -16504
9D003F84  2403001C   ADDIU V1, ZERO, 28
9D003F88  AC4310D4   SW V1, 4308(V0)
121:                         IPC4bits.T4IP = TIMER_INT_PRIOR_7;
9D003F8C  3C03BF88   LUI V1, -16504
9D003F90  8C6210D0   LW V0, 4304(V1)
9D003F94  24040007   ADDIU A0, ZERO, 7
9D003F98  7C822084   INS V0, A0, 2, 3
9D003F9C  AC6210D0   SW V0, 4304(V1)
122:                 
123:                         // set interrupt subpriority
124:                         IPC4CLR = _IPC4_T4IS_MASK;
9D003FA0  3C02BF88   LUI V0, -16504
9D003FA4  24030003   ADDIU V1, ZERO, 3
9D003FA8  AC4310D4   SW V1, 4308(V0)
125:                         IPC4bits.T4IS = TIMER_INT_SUB_PRIOR_0;
9D003FAC  3C03BF88   LUI V1, -16504
9D003FB0  8C6210D0   LW V0, 4304(V1)
9D003FB4  7C020804   INS V0, ZERO, 0, 2
9D003FB8  AC6210D0   SW V0, 4304(V1)
126:                 
127:                         // enable interrupt
128:                         IEC0CLR = _IEC0_T4IE_MASK;
9D003FBC  3C02BF88   LUI V0, -16504
9D003FC0  3C030001   LUI V1, 1
9D003FC4  AC431064   SW V1, 4196(V0)
129:                         IEC0bits.T4IE = 1;
9D003FC8  3C03BF88   LUI V1, -16504
9D003FCC  8C621060   LW V0, 4192(V1)
9D003FD0  24040001   ADDIU A0, ZERO, 1
9D003FD4  7C828404   INS V0, A0, 16, 1
9D003FD8  AC621060   SW V0, 4192(V1)
9D003FDC  0B4010C5   J 0x9D004314
9D003FE0  00000000   NOP
130:                 
131:                     }else if (timer == TIMER_5){
9D003FE4  8FC30018   LW V1, 24(S8)
9D003FE8  24020004   ADDIU V0, ZERO, 4
9D003FEC  14620038   BNE V1, V0, 0x9D0040D0
9D003FF0  00000000   NOP
132:                         TIMER_5_INT_ENABLE(0);
9D003FF4  3C02BF88   LUI V0, -16504
9D003FF8  3C030010   LUI V1, 16
9D003FFC  AC431064   SW V1, 4196(V0)
9D004000  3C02BF88   LUI V0, -16504
9D004004  AC401068   SW ZERO, 4200(V0)
133:                         T5CON = 0;
9D004008  3C02BF80   LUI V0, -16512
9D00400C  AC400E00   SW ZERO, 3584(V0)
134:                 
135:                         T5CONbits.ON = 0;
9D004010  3C03BF80   LUI V1, -16512
9D004014  94620E00   LHU V0, 3584(V1)
9D004018  7C027BC4   INS V0, ZERO, 15, 1
9D00401C  A4620E00   SH V0, 3584(V1)
136:                         T5CONbits.TCKPS = TIMER_PS_1_64;
9D004020  3C03BF80   LUI V1, -16512
9D004024  94620E00   LHU V0, 3584(V1)
9D004028  24040006   ADDIU A0, ZERO, 6
9D00402C  7C823104   INS V0, A0, 4, 3
9D004030  A4620E00   SH V0, 3584(V1)
137:                         T5CONbits.TCS = TIMER_SOURCE_INT;
9D004034  3C03BF80   LUI V1, -16512
9D004038  94620E00   LHU V0, 3584(V1)
9D00403C  7C020844   INS V0, ZERO, 1, 1
9D004040  A4620E00   SH V0, 3584(V1)
138:                         TMR5 = 0;
9D004044  3C02BF80   LUI V0, -16512
9D004048  AC400E10   SW ZERO, 3600(V0)
139:                         T5CONbits.ON = 1;
9D00404C  3C03BF80   LUI V1, -16512
9D004050  94620E00   LHU V0, 3584(V1)
9D004054  24040001   ADDIU A0, ZERO, 1
9D004058  7C827BC4   INS V0, A0, 15, 1
9D00405C  A4620E00   SH V0, 3584(V1)
140:                 
141:                         // clear interrupt flag
142:                         TIMER_5_CLEAR_INT_FLAG();
9D004060  3C02BF88   LUI V0, -16504
9D004064  3C030010   LUI V1, 16
9D004068  AC431034   SW V1, 4148(V0)
143:                 
144:                         // set interrupt priority
145:                         IPC5CLR = _IPC5_T5IP_MASK;
9D00406C  3C02BF88   LUI V0, -16504
9D004070  2403001C   ADDIU V1, ZERO, 28
9D004074  AC4310E4   SW V1, 4324(V0)
146:                         IPC5bits.T5IP = TIMER_INT_PRIOR_5;
9D004078  3C03BF88   LUI V1, -16504
9D00407C  8C6210E0   LW V0, 4320(V1)
9D004080  24040005   ADDIU A0, ZERO, 5
9D004084  7C822084   INS V0, A0, 2, 3
9D004088  AC6210E0   SW V0, 4320(V1)
147:                 
148:                         // set interrupt subpriority
149:                         IPC5CLR = _IPC5_T5IS_MASK;
9D00408C  3C02BF88   LUI V0, -16504
9D004090  24030003   ADDIU V1, ZERO, 3
9D004094  AC4310E4   SW V1, 4324(V0)
150:                         IPC5bits.T5IS = TIMER_INT_SUB_PRIOR_0;
9D004098  3C03BF88   LUI V1, -16504
9D00409C  8C6210E0   LW V0, 4320(V1)
9D0040A0  7C020804   INS V0, ZERO, 0, 2
9D0040A4  AC6210E0   SW V0, 4320(V1)
151:                 
152:                         // enable interrupt
153:                         IEC0CLR = _IEC0_T5IE_MASK;
9D0040A8  3C02BF88   LUI V0, -16504
9D0040AC  3C030010   LUI V1, 16
9D0040B0  AC431064   SW V1, 4196(V0)
154:                         IEC0bits.T5IE = 1;
9D0040B4  3C03BF88   LUI V1, -16504
9D0040B8  8C621060   LW V0, 4192(V1)
9D0040BC  24040001   ADDIU A0, ZERO, 1
9D0040C0  7C82A504   INS V0, A0, 20, 1
9D0040C4  AC621060   SW V0, 4192(V1)
9D0040C8  0B4010C5   J 0x9D004314
9D0040CC  00000000   NOP
155:                 
156:                     }else if (timer == TIMER_23){
9D0040D0  8FC30018   LW V1, 24(S8)
9D0040D4  24020005   ADDIU V0, ZERO, 5
9D0040D8  14620044   BNE V1, V0, 0x9D0041EC
9D0040DC  00000000   NOP
157:                         TIMER_2_INT_ENABLE(0);
9D0040E0  3C02BF88   LUI V0, -16504
9D0040E4  24030100   ADDIU V1, ZERO, 256
9D0040E8  AC431064   SW V1, 4196(V0)
9D0040EC  3C02BF88   LUI V0, -16504
9D0040F0  AC401068   SW ZERO, 4200(V0)
158:                         T2CON = 0;
9D0040F4  3C02BF80   LUI V0, -16512
9D0040F8  AC400800   SW ZERO, 2048(V0)
159:                         TIMER_3_INT_ENABLE(0);
9D0040FC  3C02BF88   LUI V0, -16504
9D004100  24031000   ADDIU V1, ZERO, 4096
9D004104  AC431064   SW V1, 4196(V0)
9D004108  3C02BF88   LUI V0, -16504
9D00410C  AC401068   SW ZERO, 4200(V0)
160:                         T3CON = 0;
9D004110  3C02BF80   LUI V0, -16512
9D004114  AC400A00   SW ZERO, 2560(V0)
161:                 
162:                         T2CONbits.ON = 0;
9D004118  3C03BF80   LUI V1, -16512
9D00411C  94620800   LHU V0, 2048(V1)
9D004120  7C027BC4   INS V0, ZERO, 15, 1
9D004124  A4620800   SH V0, 2048(V1)
163:                         T2CONbits.TCKPS = TIMER_PS_1_64;
9D004128  3C03BF80   LUI V1, -16512
9D00412C  94620800   LHU V0, 2048(V1)
9D004130  24040006   ADDIU A0, ZERO, 6
9D004134  7C823104   INS V0, A0, 4, 3
9D004138  A4620800   SH V0, 2048(V1)
164:                         T2CONbits.TCS = TIMER_SOURCE_INT;
9D00413C  3C03BF80   LUI V1, -16512
9D004140  94620800   LHU V0, 2048(V1)
9D004144  7C020844   INS V0, ZERO, 1, 1
9D004148  A4620800   SH V0, 2048(V1)
165:                         T2CONbits.T32 = 1;
9D00414C  3C03BF80   LUI V1, -16512
9D004150  94620800   LHU V0, 2048(V1)
9D004154  24040001   ADDIU A0, ZERO, 1
9D004158  7C8218C4   INS V0, A0, 3, 1
9D00415C  A4620800   SH V0, 2048(V1)
166:                         TMR2 = 0;
9D004160  3C02BF80   LUI V0, -16512
9D004164  AC400810   SW ZERO, 2064(V0)
167:                         T2CONbits.ON = 1;
9D004168  3C03BF80   LUI V1, -16512
9D00416C  94620800   LHU V0, 2048(V1)
9D004170  24040001   ADDIU A0, ZERO, 1
9D004174  7C827BC4   INS V0, A0, 15, 1
9D004178  A4620800   SH V0, 2048(V1)
168:                 
169:                         // clear interrupt flag
170:                         TIMER_2_CLEAR_INT_FLAG();
9D00417C  3C02BF88   LUI V0, -16504
9D004180  24030100   ADDIU V1, ZERO, 256
9D004184  AC431034   SW V1, 4148(V0)
171:                 
172:                         // set interrupt priority
173:                         IPC2CLR = _IPC2_T2IP_MASK;
9D004188  3C02BF88   LUI V0, -16504
9D00418C  2403001C   ADDIU V1, ZERO, 28
9D004190  AC4310B4   SW V1, 4276(V0)
174:                         IPC2bits.T2IP = TIMER_INT_PRIOR_4;
9D004194  3C03BF88   LUI V1, -16504
9D004198  8C6210B0   LW V0, 4272(V1)
9D00419C  24040004   ADDIU A0, ZERO, 4
9D0041A0  7C822084   INS V0, A0, 2, 3
9D0041A4  AC6210B0   SW V0, 4272(V1)
175:                 
176:                         // set interrupt subpriority
177:                         IPC2CLR = _IPC2_T2IS_MASK;
9D0041A8  3C02BF88   LUI V0, -16504
9D0041AC  24030003   ADDIU V1, ZERO, 3
9D0041B0  AC4310B4   SW V1, 4276(V0)
178:                         IPC2bits.T2IS = TIMER_INT_SUB_PRIOR_0;
9D0041B4  3C03BF88   LUI V1, -16504
9D0041B8  8C6210B0   LW V0, 4272(V1)
9D0041BC  7C020804   INS V0, ZERO, 0, 2
9D0041C0  AC6210B0   SW V0, 4272(V1)
179:                 
180:                         // enable interrupt
181:                         IEC0CLR = _IEC0_T2IE_MASK;
9D0041C4  3C02BF88   LUI V0, -16504
9D0041C8  24030100   ADDIU V1, ZERO, 256
9D0041CC  AC431064   SW V1, 4196(V0)
182:                         IEC0bits.T2IE = 1;
9D0041D0  3C03BF88   LUI V1, -16504
9D0041D4  8C621060   LW V0, 4192(V1)
9D0041D8  24040001   ADDIU A0, ZERO, 1
9D0041DC  7C824204   INS V0, A0, 8, 1
9D0041E0  AC621060   SW V0, 4192(V1)
9D0041E4  0B4010C5   J 0x9D004314
9D0041E8  00000000   NOP
183:                 
184:                     }else if (timer == TIMER_45){
9D0041EC  8FC30018   LW V1, 24(S8)
9D0041F0  24020006   ADDIU V0, ZERO, 6
9D0041F4  14620044   BNE V1, V0, 0x9D004308
9D0041F8  00000000   NOP
185:                         TIMER_4_INT_ENABLE(0);
9D0041FC  3C02BF88   LUI V0, -16504
9D004200  3C030001   LUI V1, 1
9D004204  AC431064   SW V1, 4196(V0)
9D004208  3C02BF88   LUI V0, -16504
9D00420C  AC401068   SW ZERO, 4200(V0)
186:                         T4CON = 0;
9D004210  3C02BF80   LUI V0, -16512
9D004214  AC400C00   SW ZERO, 3072(V0)
187:                         TIMER_5_INT_ENABLE(0);
9D004218  3C02BF88   LUI V0, -16504
9D00421C  3C030010   LUI V1, 16
9D004220  AC431064   SW V1, 4196(V0)
9D004224  3C02BF88   LUI V0, -16504
9D004228  AC401068   SW ZERO, 4200(V0)
188:                         T5CON = 0;
9D00422C  3C02BF80   LUI V0, -16512
9D004230  AC400E00   SW ZERO, 3584(V0)
189:                 
190:                         T4CONbits.ON = 0;
9D004234  3C03BF80   LUI V1, -16512
9D004238  94620C00   LHU V0, 3072(V1)
9D00423C  7C027BC4   INS V0, ZERO, 15, 1
9D004240  A4620C00   SH V0, 3072(V1)
191:                         T4CONbits.TCKPS = TIMER_PS_1_64;
9D004244  3C03BF80   LUI V1, -16512
9D004248  94620C00   LHU V0, 3072(V1)
9D00424C  24040006   ADDIU A0, ZERO, 6
9D004250  7C823104   INS V0, A0, 4, 3
9D004254  A4620C00   SH V0, 3072(V1)
192:                         T4CONbits.TCS = TIMER_SOURCE_INT;
9D004258  3C03BF80   LUI V1, -16512
9D00425C  94620C00   LHU V0, 3072(V1)
9D004260  7C020844   INS V0, ZERO, 1, 1
9D004264  A4620C00   SH V0, 3072(V1)
193:                         T4CONbits.T32 = 1;
9D004268  3C03BF80   LUI V1, -16512
9D00426C  94620C00   LHU V0, 3072(V1)
9D004270  24040001   ADDIU A0, ZERO, 1
9D004274  7C8218C4   INS V0, A0, 3, 1
9D004278  A4620C00   SH V0, 3072(V1)
194:                         TMR4 = 0;
9D00427C  3C02BF80   LUI V0, -16512
9D004280  AC400C10   SW ZERO, 3088(V0)
195:                         T4CONbits.ON = 1;
9D004284  3C03BF80   LUI V1, -16512
9D004288  94620C00   LHU V0, 3072(V1)
9D00428C  24040001   ADDIU A0, ZERO, 1
9D004290  7C827BC4   INS V0, A0, 15, 1
9D004294  A4620C00   SH V0, 3072(V1)
196:                 
197:                         // clear interrupt flag
198:                         TIMER_4_CLEAR_INT_FLAG();
9D004298  3C02BF88   LUI V0, -16504
9D00429C  3C030001   LUI V1, 1
9D0042A0  AC431034   SW V1, 4148(V0)
199:                 
200:                         // set interrupt priority
201:                         IPC4CLR = _IPC4_T4IP_MASK;
9D0042A4  3C02BF88   LUI V0, -16504
9D0042A8  2403001C   ADDIU V1, ZERO, 28
9D0042AC  AC4310D4   SW V1, 4308(V0)
202:                         IPC4bits.T4IP = TIMER_INT_PRIOR_7;
9D0042B0  3C03BF88   LUI V1, -16504
9D0042B4  8C6210D0   LW V0, 4304(V1)
9D0042B8  24040007   ADDIU A0, ZERO, 7
9D0042BC  7C822084   INS V0, A0, 2, 3
9D0042C0  AC6210D0   SW V0, 4304(V1)
203:                 
204:                         // set interrupt subpriority
205:                         IPC4CLR = _IPC4_T4IS_MASK;
9D0042C4  3C02BF88   LUI V0, -16504
9D0042C8  24030003   ADDIU V1, ZERO, 3
9D0042CC  AC4310D4   SW V1, 4308(V0)
206:                         IPC4bits.T4IS = TIMER_INT_SUB_PRIOR_0;
9D0042D0  3C03BF88   LUI V1, -16504
9D0042D4  8C6210D0   LW V0, 4304(V1)
9D0042D8  7C020804   INS V0, ZERO, 0, 2
9D0042DC  AC6210D0   SW V0, 4304(V1)
207:                 
208:                         // enable interrupt
209:                         IEC0CLR = _IEC0_T4IE_MASK;
9D0042E0  3C02BF88   LUI V0, -16504
9D0042E4  3C030001   LUI V1, 1
9D0042E8  AC431064   SW V1, 4196(V0)
210:                         IEC0bits.T4IE = 1;
9D0042EC  3C03BF88   LUI V1, -16504
9D0042F0  8C621060   LW V0, 4192(V1)
9D0042F4  24040001   ADDIU A0, ZERO, 1
9D0042F8  7C828404   INS V0, A0, 16, 1
9D0042FC  AC621060   SW V0, 4192(V1)
9D004300  0B4010C5   J 0x9D004314
9D004304  00000000   NOP
211:                 
212:                     }else{
213:                         return ERROR;
9D004308  24020001   ADDIU V0, ZERO, 1
9D00430C  0B4010CA   J 0x9D004328
9D004310  00000000   NOP
214:                     }
215:                     timer_set_period(timer, period_ms);
9D004314  8FC40018   LW A0, 24(S8)
9D004318  8FC5001C   LW A1, 28(S8)
9D00431C  0F4010D0   JAL timer_set_period
9D004320  00000000   NOP
216:                 
217:                     return SUCCESS;
9D004324  00001021   ADDU V0, ZERO, ZERO
218:                 }
9D004328  03C0E821   ADDU SP, S8, ZERO
9D00432C  8FBF0014   LW RA, 20(SP)
9D004330  8FBE0010   LW S8, 16(SP)
9D004334  27BD0018   ADDIU SP, SP, 24
9D004338  03E00008   JR RA
9D00433C  00000000   NOP
219:                 
220:                 
221:                 
222:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
223:                 //-------------------------- Set Timers Period --------------------------------
224:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
225:                 // PRx = Period * PeriphClock / Prescaler
226:                 
227:                 RESULT timer_set_period(TIMER_ID timer, u32 period_ms)
228:                 {
9D004340  27BDFFF8   ADDIU SP, SP, -8
9D004344  AFBE0004   SW S8, 4(SP)
9D004348  03A0F021   ADDU S8, SP, ZERO
9D00434C  AFC40008   SW A0, 8(S8)
9D004350  AFC5000C   SW A1, 12(S8)
229:                     if (timer == TIMER_1){
9D004354  8FC20008   LW V0, 8(S8)
9D004358  14400006   BNE V0, ZERO, 0x9D004374
9D00435C  00000000   NOP
230:                         PR1 = period_ms;
9D004360  3C02BF80   LUI V0, -16512
9D004364  8FC3000C   LW V1, 12(S8)
9D004368  AC430620   SW V1, 1568(V0)
9D00436C  0B401116   J 0x9D004458
9D004370  00000000   NOP
231:                 
232:                     }else if (timer == TIMER_2){
9D004374  8FC30008   LW V1, 8(S8)
9D004378  24020001   ADDIU V0, ZERO, 1
9D00437C  14620006   BNE V1, V0, 0x9D004398
9D004380  00000000   NOP
233:                         PR2 = period_ms;
9D004384  3C02BF80   LUI V0, -16512
9D004388  8FC3000C   LW V1, 12(S8)
9D00438C  AC430820   SW V1, 2080(V0)
9D004390  0B401116   J 0x9D004458
9D004394  00000000   NOP
234:                 
235:                     }else if (timer == TIMER_3){
9D004398  8FC30008   LW V1, 8(S8)
9D00439C  24020002   ADDIU V0, ZERO, 2
9D0043A0  14620006   BNE V1, V0, 0x9D0043BC
9D0043A4  00000000   NOP
236:                         PR3 = period_ms;
9D0043A8  3C02BF80   LUI V0, -16512
9D0043AC  8FC3000C   LW V1, 12(S8)
9D0043B0  AC430A20   SW V1, 2592(V0)
9D0043B4  0B401116   J 0x9D004458
9D0043B8  00000000   NOP
237:                 
238:                     }else if (timer == TIMER_4){
9D0043BC  8FC30008   LW V1, 8(S8)
9D0043C0  24020003   ADDIU V0, ZERO, 3
9D0043C4  14620006   BNE V1, V0, 0x9D0043E0
9D0043C8  00000000   NOP
239:                         PR4 = period_ms;
9D0043CC  3C02BF80   LUI V0, -16512
9D0043D0  8FC3000C   LW V1, 12(S8)
9D0043D4  AC430C20   SW V1, 3104(V0)
9D0043D8  0B401116   J 0x9D004458
9D0043DC  00000000   NOP
240:                 
241:                     }else if (timer == TIMER_5){
9D0043E0  8FC30008   LW V1, 8(S8)
9D0043E4  24020004   ADDIU V0, ZERO, 4
9D0043E8  14620006   BNE V1, V0, 0x9D004404
9D0043EC  00000000   NOP
242:                         PR5 = period_ms;
9D0043F0  3C02BF80   LUI V0, -16512
9D0043F4  8FC3000C   LW V1, 12(S8)
9D0043F8  AC430E20   SW V1, 3616(V0)
9D0043FC  0B401116   J 0x9D004458
9D004400  00000000   NOP
243:                 
244:                     }else if (timer == TIMER_23){
9D004404  8FC30008   LW V1, 8(S8)
9D004408  24020005   ADDIU V0, ZERO, 5
9D00440C  14620006   BNE V1, V0, 0x9D004428
9D004410  00000000   NOP
245:                         PR2 = period_ms;
9D004414  3C02BF80   LUI V0, -16512
9D004418  8FC3000C   LW V1, 12(S8)
9D00441C  AC430820   SW V1, 2080(V0)
9D004420  0B401116   J 0x9D004458
9D004424  00000000   NOP
246:                 
247:                     }else if (timer == TIMER_45){
9D004428  8FC30008   LW V1, 8(S8)
9D00442C  24020006   ADDIU V0, ZERO, 6
9D004430  14620006   BNE V1, V0, 0x9D00444C
9D004434  00000000   NOP
248:                         PR4 = period_ms;
9D004438  3C02BF80   LUI V0, -16512
9D00443C  8FC3000C   LW V1, 12(S8)
9D004440  AC430C20   SW V1, 3104(V0)
9D004444  0B401116   J 0x9D004458
9D004448  00000000   NOP
249:                 
250:                     }else{
251:                         return ERROR;
9D00444C  24020001   ADDIU V0, ZERO, 1
9D004450  0B401117   J 0x9D00445C
9D004454  00000000   NOP
252:                     }
253:                 
254:                     return SUCCESS;
9D004458  00001021   ADDU V0, ZERO, ZERO
255:                 }
9D00445C  03C0E821   ADDU SP, S8, ZERO
9D004460  8FBE0004   LW S8, 4(SP)
9D004464  27BD0008   ADDIU SP, SP, 8
9D004468  03E00008   JR RA
9D00446C  00000000   NOP
256:                 
257:                 
258:                 
259:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
260:                 //-------------------------- interrupt handler --------------------------------
261:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
262:                 void __ISR(_TIMER_1_VECTOR, IPL2AUTO) Timer1Handler(void)
263:                 {
9D004470  415DE800   RDPGPR SP, SP
9D004474  401B7000   MFC0 K1, EPC
9D004478  401A6002   MFC0 K0, SRSCtl
9D00447C  27BDFF88   ADDIU SP, SP, -120
9D004480  AFBB0074   SW K1, 116(SP)
9D004484  401B6000   MFC0 K1, Status
9D004488  AFBA006C   SW K0, 108(SP)
9D00448C  AFBB0070   SW K1, 112(SP)
9D004490  7C1B7844   INS K1, ZERO, 1, 15
9D004494  377B0800   ORI K1, K1, 2048
9D004498  409B6000   MTC0 K1, Status
9D00449C  AFA3001C   SW V1, 28(SP)
9D0044A0  AFA20018   SW V0, 24(SP)
9D0044A4  8FA3006C   LW V1, 108(SP)
9D0044A8  3063000F   ANDI V1, V1, 15
9D0044AC  14600012   BNE V1, ZERO, 0x9D0044F8
9D0044B0  00000000   NOP
9D0044B4  AFBF005C   SW RA, 92(SP)
9D0044B8  AFBE0058   SW S8, 88(SP)
9D0044BC  AFB90054   SW T9, 84(SP)
9D0044C0  AFB80050   SW T8, 80(SP)
9D0044C4  AFAF004C   SW T7, 76(SP)
9D0044C8  AFAE0048   SW T6, 72(SP)
9D0044CC  AFAD0044   SW T5, 68(SP)
9D0044D0  AFAC0040   SW T4, 64(SP)
9D0044D4  AFAB003C   SW T3, 60(SP)
9D0044D8  AFAA0038   SW T2, 56(SP)
9D0044DC  AFA90034   SW T1, 52(SP)
9D0044E0  AFA80030   SW T0, 48(SP)
9D0044E4  AFA7002C   SW A3, 44(SP)
9D0044E8  AFA60028   SW A2, 40(SP)
9D0044EC  AFA50024   SW A1, 36(SP)
9D0044F0  AFA40020   SW A0, 32(SP)
9D0044F4  AFA10014   SW AT, 20(SP)
9D0044F8  00000000   NOP
9D0044FC  00001012   MFLO V0
9D004500  AFA20064   SW V0, 100(SP)
9D004504  00001810   MFHI V1
9D004508  AFA30060   SW V1, 96(SP)
9D00450C  03A0F021   ADDU S8, SP, ZERO
264:                     timer1_isr();
9D004510  0F402094   JAL timer1_isr
9D004514  00000000   NOP
265:                     TIMER_1_CLEAR_INT_FLAG();
9D004518  3C02BF88   LUI V0, -16504
9D00451C  24030010   ADDIU V1, ZERO, 16
9D004520  AC431034   SW V1, 4148(V0)
266:                 }
9D004524  03C0E821   ADDU SP, S8, ZERO
9D004528  8FA20064   LW V0, 100(SP)
9D00452C  00400013   MTLO V0
9D004530  8FA30060   LW V1, 96(SP)
9D004534  00600011   MTHI V1
9D004538  8FA2006C   LW V0, 108(SP)
9D00453C  3042000F   ANDI V0, V0, 15
9D004540  14400014   BNE V0, ZERO, 0x9D004594
9D004544  00000000   NOP
9D004548  8FBF005C   LW RA, 92(SP)
9D00454C  8FBE0058   LW S8, 88(SP)
9D004550  8FB90054   LW T9, 84(SP)
9D004554  8FB80050   LW T8, 80(SP)
9D004558  8FAF004C   LW T7, 76(SP)
9D00455C  8FAE0048   LW T6, 72(SP)
9D004560  8FAD0044   LW T5, 68(SP)
9D004564  8FAC0040   LW T4, 64(SP)
9D004568  8FAB003C   LW T3, 60(SP)
9D00456C  8FAA0038   LW T2, 56(SP)
9D004570  8FA90034   LW T1, 52(SP)
9D004574  8FA80030   LW T0, 48(SP)
9D004578  8FA7002C   LW A3, 44(SP)
9D00457C  8FA60028   LW A2, 40(SP)
9D004580  8FA50024   LW A1, 36(SP)
9D004584  8FA40020   LW A0, 32(SP)
9D004588  8FA3001C   LW V1, 28(SP)
9D00458C  8FA20018   LW V0, 24(SP)
9D004590  8FA10014   LW AT, 20(SP)
9D004594  00000000   NOP
9D004598  41606000   DI ZERO
9D00459C  000000C0   EHB
9D0045A0  8FBA0074   LW K0, 116(SP)
9D0045A4  8FBB0070   LW K1, 112(SP)
9D0045A8  409A7000   MTC0 K0, EPC
9D0045AC  8FBA006C   LW K0, 108(SP)
9D0045B0  27BD0078   ADDIU SP, SP, 120
9D0045B4  409A6002   MTC0 K0, SRSCtl
9D0045B8  41DDE800   WRPGPR SP, SP
9D0045BC  409B6000   MTC0 K1, Status
9D0045C0  42000018   ERET
267:                 
268:                 void __ISR(_TIMER_2_VECTOR, IPL4AUTO) Timer2Handler(void)
269:                 {
9D0045C4  415DE800   RDPGPR SP, SP
9D0045C8  401B7000   MFC0 K1, EPC
9D0045CC  401A6002   MFC0 K0, SRSCtl
9D0045D0  27BDFF88   ADDIU SP, SP, -120
9D0045D4  AFBB0074   SW K1, 116(SP)
9D0045D8  401B6000   MFC0 K1, Status
9D0045DC  AFBA006C   SW K0, 108(SP)
9D0045E0  AFBB0070   SW K1, 112(SP)
9D0045E4  7C1B7844   INS K1, ZERO, 1, 15
9D0045E8  377B1000   ORI K1, K1, 4096
9D0045EC  409B6000   MTC0 K1, Status
9D0045F0  AFA3001C   SW V1, 28(SP)
9D0045F4  AFA20018   SW V0, 24(SP)
9D0045F8  8FA3006C   LW V1, 108(SP)
9D0045FC  3063000F   ANDI V1, V1, 15
9D004600  14600012   BNE V1, ZERO, 0x9D00464C
9D004604  00000000   NOP
9D004608  AFBF005C   SW RA, 92(SP)
9D00460C  AFBE0058   SW S8, 88(SP)
9D004610  AFB90054   SW T9, 84(SP)
9D004614  AFB80050   SW T8, 80(SP)
9D004618  AFAF004C   SW T7, 76(SP)
9D00461C  AFAE0048   SW T6, 72(SP)
9D004620  AFAD0044   SW T5, 68(SP)
9D004624  AFAC0040   SW T4, 64(SP)
9D004628  AFAB003C   SW T3, 60(SP)
9D00462C  AFAA0038   SW T2, 56(SP)
9D004630  AFA90034   SW T1, 52(SP)
9D004634  AFA80030   SW T0, 48(SP)
9D004638  AFA7002C   SW A3, 44(SP)
9D00463C  AFA60028   SW A2, 40(SP)
9D004640  AFA50024   SW A1, 36(SP)
9D004644  AFA40020   SW A0, 32(SP)
9D004648  AFA10014   SW AT, 20(SP)
9D00464C  00000000   NOP
9D004650  00001012   MFLO V0
9D004654  AFA20064   SW V0, 100(SP)
9D004658  00001810   MFHI V1
9D00465C  AFA30060   SW V1, 96(SP)
9D004660  03A0F021   ADDU S8, SP, ZERO
270:                     timer2_isr();
9D004664  0F4020B3   JAL timer2_isr
9D004668  00000000   NOP
271:                     TIMER_2_CLEAR_INT_FLAG();
9D00466C  3C02BF88   LUI V0, -16504
9D004670  24030100   ADDIU V1, ZERO, 256
9D004674  AC431034   SW V1, 4148(V0)
272:                 }
9D004678  03C0E821   ADDU SP, S8, ZERO
9D00467C  8FA20064   LW V0, 100(SP)
9D004680  00400013   MTLO V0
9D004684  8FA30060   LW V1, 96(SP)
9D004688  00600011   MTHI V1
9D00468C  8FA2006C   LW V0, 108(SP)
9D004690  3042000F   ANDI V0, V0, 15
9D004694  14400014   BNE V0, ZERO, 0x9D0046E8
9D004698  00000000   NOP
9D00469C  8FBF005C   LW RA, 92(SP)
9D0046A0  8FBE0058   LW S8, 88(SP)
9D0046A4  8FB90054   LW T9, 84(SP)
9D0046A8  8FB80050   LW T8, 80(SP)
9D0046AC  8FAF004C   LW T7, 76(SP)
9D0046B0  8FAE0048   LW T6, 72(SP)
9D0046B4  8FAD0044   LW T5, 68(SP)
9D0046B8  8FAC0040   LW T4, 64(SP)
9D0046BC  8FAB003C   LW T3, 60(SP)
9D0046C0  8FAA0038   LW T2, 56(SP)
9D0046C4  8FA90034   LW T1, 52(SP)
9D0046C8  8FA80030   LW T0, 48(SP)
9D0046CC  8FA7002C   LW A3, 44(SP)
9D0046D0  8FA60028   LW A2, 40(SP)
9D0046D4  8FA50024   LW A1, 36(SP)
9D0046D8  8FA40020   LW A0, 32(SP)
9D0046DC  8FA3001C   LW V1, 28(SP)
9D0046E0  8FA20018   LW V0, 24(SP)
9D0046E4  8FA10014   LW AT, 20(SP)
9D0046E8  00000000   NOP
9D0046EC  41606000   DI ZERO
9D0046F0  000000C0   EHB
9D0046F4  8FBA0074   LW K0, 116(SP)
9D0046F8  8FBB0070   LW K1, 112(SP)
9D0046FC  409A7000   MTC0 K0, EPC
9D004700  8FBA006C   LW K0, 108(SP)
9D004704  27BD0078   ADDIU SP, SP, 120
9D004708  409A6002   MTC0 K0, SRSCtl
9D00470C  41DDE800   WRPGPR SP, SP
9D004710  409B6000   MTC0 K1, Status
9D004714  42000018   ERET
273:                 
274:                 #ifndef USE_TIMER_23
275:                 void __ISR(_TIMER_3_VECTOR, IPL6AUTO) Timer3Handler(void)
276:                 {
9D004718  415DE800   RDPGPR SP, SP
9D00471C  401B7000   MFC0 K1, EPC
9D004720  401A6002   MFC0 K0, SRSCtl
9D004724  27BDFF88   ADDIU SP, SP, -120
9D004728  AFBB0074   SW K1, 116(SP)
9D00472C  401B6000   MFC0 K1, Status
9D004730  AFBA006C   SW K0, 108(SP)
9D004734  AFBB0070   SW K1, 112(SP)
9D004738  7C1B7844   INS K1, ZERO, 1, 15
9D00473C  377B1800   ORI K1, K1, 6144
9D004740  409B6000   MTC0 K1, Status
9D004744  AFA3001C   SW V1, 28(SP)
9D004748  AFA20018   SW V0, 24(SP)
9D00474C  8FA3006C   LW V1, 108(SP)
9D004750  3063000F   ANDI V1, V1, 15
9D004754  14600012   BNE V1, ZERO, 0x9D0047A0
9D004758  00000000   NOP
9D00475C  AFBF005C   SW RA, 92(SP)
9D004760  AFBE0058   SW S8, 88(SP)
9D004764  AFB90054   SW T9, 84(SP)
9D004768  AFB80050   SW T8, 80(SP)
9D00476C  AFAF004C   SW T7, 76(SP)
9D004770  AFAE0048   SW T6, 72(SP)
9D004774  AFAD0044   SW T5, 68(SP)
9D004778  AFAC0040   SW T4, 64(SP)
9D00477C  AFAB003C   SW T3, 60(SP)
9D004780  AFAA0038   SW T2, 56(SP)
9D004784  AFA90034   SW T1, 52(SP)
9D004788  AFA80030   SW T0, 48(SP)
9D00478C  AFA7002C   SW A3, 44(SP)
9D004790  AFA60028   SW A2, 40(SP)
9D004794  AFA50024   SW A1, 36(SP)
9D004798  AFA40020   SW A0, 32(SP)
9D00479C  AFA10014   SW AT, 20(SP)
9D0047A0  00000000   NOP
9D0047A4  00001012   MFLO V0
9D0047A8  AFA20064   SW V0, 100(SP)
9D0047AC  00001810   MFHI V1
9D0047B0  AFA30060   SW V1, 96(SP)
9D0047B4  03A0F021   ADDU S8, SP, ZERO
277:                     timer3_isr();
9D0047B8  0F4020BC   JAL timer3_isr
9D0047BC  00000000   NOP
278:                     TIMER_3_CLEAR_INT_FLAG();
9D0047C0  3C02BF88   LUI V0, -16504
9D0047C4  24031000   ADDIU V1, ZERO, 4096
9D0047C8  AC431034   SW V1, 4148(V0)
279:                 }
9D0047CC  03C0E821   ADDU SP, S8, ZERO
9D0047D0  8FA20064   LW V0, 100(SP)
9D0047D4  00400013   MTLO V0
9D0047D8  8FA30060   LW V1, 96(SP)
9D0047DC  00600011   MTHI V1
9D0047E0  8FA2006C   LW V0, 108(SP)
9D0047E4  3042000F   ANDI V0, V0, 15
9D0047E8  14400014   BNE V0, ZERO, 0x9D00483C
9D0047EC  00000000   NOP
9D0047F0  8FBF005C   LW RA, 92(SP)
9D0047F4  8FBE0058   LW S8, 88(SP)
9D0047F8  8FB90054   LW T9, 84(SP)
9D0047FC  8FB80050   LW T8, 80(SP)
9D004800  8FAF004C   LW T7, 76(SP)
9D004804  8FAE0048   LW T6, 72(SP)
9D004808  8FAD0044   LW T5, 68(SP)
9D00480C  8FAC0040   LW T4, 64(SP)
9D004810  8FAB003C   LW T3, 60(SP)
9D004814  8FAA0038   LW T2, 56(SP)
9D004818  8FA90034   LW T1, 52(SP)
9D00481C  8FA80030   LW T0, 48(SP)
9D004820  8FA7002C   LW A3, 44(SP)
9D004824  8FA60028   LW A2, 40(SP)
9D004828  8FA50024   LW A1, 36(SP)
9D00482C  8FA40020   LW A0, 32(SP)
9D004830  8FA3001C   LW V1, 28(SP)
9D004834  8FA20018   LW V0, 24(SP)
9D004838  8FA10014   LW AT, 20(SP)
9D00483C  00000000   NOP
9D004840  41606000   DI ZERO
9D004844  000000C0   EHB
9D004848  8FBA0074   LW K0, 116(SP)
9D00484C  8FBB0070   LW K1, 112(SP)
9D004850  409A7000   MTC0 K0, EPC
9D004854  8FBA006C   LW K0, 108(SP)
9D004858  27BD0078   ADDIU SP, SP, 120
9D00485C  409A6002   MTC0 K0, SRSCtl
9D004860  41DDE800   WRPGPR SP, SP
9D004864  409B6000   MTC0 K1, Status
9D004868  42000018   ERET
280:                 #else
281:                 void __ISR(_TIMER_3_VECTOR, IPL6AUTO) Timer23Handler(void)
282:                 {
283:                     timer23_isr();
284:                     TIMER_23_CLEAR_INT_FLAG();
285:                 }
286:                 #endif
287:                 
288:                 void __ISR(_TIMER_4_VECTOR, IPL7AUTO) Timer4Handler(void)
289:                 {
9D00486C  415DE800   RDPGPR SP, SP
9D004870  401B7000   MFC0 K1, EPC
9D004874  401A6002   MFC0 K0, SRSCtl
9D004878  27BDFF88   ADDIU SP, SP, -120
9D00487C  401B6000   MFC0 K1, Status
9D004880  AFBA0070   SW K0, 112(SP)
9D004884  AFBB0074   SW K1, 116(SP)
9D004888  7C1B7844   INS K1, ZERO, 1, 15
9D00488C  377B1C00   ORI K1, K1, 7168
9D004890  409B6000   MTC0 K1, Status
9D004894  AFA3001C   SW V1, 28(SP)
9D004898  AFA20018   SW V0, 24(SP)
9D00489C  8FA30070   LW V1, 112(SP)
9D0048A0  3063000F   ANDI V1, V1, 15
9D0048A4  14600012   BNE V1, ZERO, 0x9D0048F0
9D0048A8  00000000   NOP
9D0048AC  AFBF005C   SW RA, 92(SP)
9D0048B0  AFBE0058   SW S8, 88(SP)
9D0048B4  AFB90054   SW T9, 84(SP)
9D0048B8  AFB80050   SW T8, 80(SP)
9D0048BC  AFAF004C   SW T7, 76(SP)
9D0048C0  AFAE0048   SW T6, 72(SP)
9D0048C4  AFAD0044   SW T5, 68(SP)
9D0048C8  AFAC0040   SW T4, 64(SP)
9D0048CC  AFAB003C   SW T3, 60(SP)
9D0048D0  AFAA0038   SW T2, 56(SP)
9D0048D4  AFA90034   SW T1, 52(SP)
9D0048D8  AFA80030   SW T0, 48(SP)
9D0048DC  AFA7002C   SW A3, 44(SP)
9D0048E0  AFA60028   SW A2, 40(SP)
9D0048E4  AFA50024   SW A1, 36(SP)
9D0048E8  AFA40020   SW A0, 32(SP)
9D0048EC  AFA10014   SW AT, 20(SP)
9D0048F0  00000000   NOP
9D0048F4  00001012   MFLO V0
9D0048F8  AFA20064   SW V0, 100(SP)
9D0048FC  00001810   MFHI V1
9D004900  AFA30060   SW V1, 96(SP)
9D004904  03A0F021   ADDU S8, SP, ZERO
290:                     timer4_isr();
9D004908  0F4020D6   JAL timer4_isr
9D00490C  00000000   NOP
291:                     TIMER_4_CLEAR_INT_FLAG();
9D004910  3C02BF88   LUI V0, -16504
9D004914  3C030001   LUI V1, 1
9D004918  AC431034   SW V1, 4148(V0)
292:                 }
9D00491C  03C0E821   ADDU SP, S8, ZERO
9D004920  8FA20064   LW V0, 100(SP)
9D004924  00400013   MTLO V0
9D004928  8FA30060   LW V1, 96(SP)
9D00492C  00600011   MTHI V1
9D004930  8FA20070   LW V0, 112(SP)
9D004934  3042000F   ANDI V0, V0, 15
9D004938  14400014   BNE V0, ZERO, 0x9D00498C
9D00493C  00000000   NOP
9D004940  8FBF005C   LW RA, 92(SP)
9D004944  8FBE0058   LW S8, 88(SP)
9D004948  8FB90054   LW T9, 84(SP)
9D00494C  8FB80050   LW T8, 80(SP)
9D004950  8FAF004C   LW T7, 76(SP)
9D004954  8FAE0048   LW T6, 72(SP)
9D004958  8FAD0044   LW T5, 68(SP)
9D00495C  8FAC0040   LW T4, 64(SP)
9D004960  8FAB003C   LW T3, 60(SP)
9D004964  8FAA0038   LW T2, 56(SP)
9D004968  8FA90034   LW T1, 52(SP)
9D00496C  8FA80030   LW T0, 48(SP)
9D004970  8FA7002C   LW A3, 44(SP)
9D004974  8FA60028   LW A2, 40(SP)
9D004978  8FA50024   LW A1, 36(SP)
9D00497C  8FA40020   LW A0, 32(SP)
9D004980  8FA3001C   LW V1, 28(SP)
9D004984  8FA20018   LW V0, 24(SP)
9D004988  8FA10014   LW AT, 20(SP)
9D00498C  00000000   NOP
9D004990  8FBB0074   LW K1, 116(SP)
9D004994  8FBA0070   LW K0, 112(SP)
9D004998  27BD0078   ADDIU SP, SP, 120
9D00499C  409A6002   MTC0 K0, SRSCtl
9D0049A0  41DDE800   WRPGPR SP, SP
9D0049A4  409B6000   MTC0 K1, Status
9D0049A8  42000018   ERET
293:                 
294:                 #ifndef USE_TIMER_45
295:                 void __ISR(_TIMER_5_VECTOR, IPL5AUTO) Timer5Handler(void)
296:                 {
9D0049AC  415DE800   RDPGPR SP, SP
9D0049B0  401B7000   MFC0 K1, EPC
9D0049B4  401A6002   MFC0 K0, SRSCtl
9D0049B8  27BDFF88   ADDIU SP, SP, -120
9D0049BC  AFBB0074   SW K1, 116(SP)
9D0049C0  401B6000   MFC0 K1, Status
9D0049C4  AFBA006C   SW K0, 108(SP)
9D0049C8  AFBB0070   SW K1, 112(SP)
9D0049CC  7C1B7844   INS K1, ZERO, 1, 15
9D0049D0  377B1400   ORI K1, K1, 5120
9D0049D4  409B6000   MTC0 K1, Status
9D0049D8  AFA3001C   SW V1, 28(SP)
9D0049DC  AFA20018   SW V0, 24(SP)
9D0049E0  8FA3006C   LW V1, 108(SP)
9D0049E4  3063000F   ANDI V1, V1, 15
9D0049E8  14600012   BNE V1, ZERO, 0x9D004A34
9D0049EC  00000000   NOP
9D0049F0  AFBF005C   SW RA, 92(SP)
9D0049F4  AFBE0058   SW S8, 88(SP)
9D0049F8  AFB90054   SW T9, 84(SP)
9D0049FC  AFB80050   SW T8, 80(SP)
9D004A00  AFAF004C   SW T7, 76(SP)
9D004A04  AFAE0048   SW T6, 72(SP)
9D004A08  AFAD0044   SW T5, 68(SP)
9D004A0C  AFAC0040   SW T4, 64(SP)
9D004A10  AFAB003C   SW T3, 60(SP)
9D004A14  AFAA0038   SW T2, 56(SP)
9D004A18  AFA90034   SW T1, 52(SP)
9D004A1C  AFA80030   SW T0, 48(SP)
9D004A20  AFA7002C   SW A3, 44(SP)
9D004A24  AFA60028   SW A2, 40(SP)
9D004A28  AFA50024   SW A1, 36(SP)
9D004A2C  AFA40020   SW A0, 32(SP)
9D004A30  AFA10014   SW AT, 20(SP)
9D004A34  00000000   NOP
9D004A38  00001012   MFLO V0
9D004A3C  AFA20064   SW V0, 100(SP)
9D004A40  00001810   MFHI V1
9D004A44  AFA30060   SW V1, 96(SP)
9D004A48  03A0F021   ADDU S8, SP, ZERO
297:                     timer5_isr();
9D004A4C  0F4020DF   JAL timer5_isr
9D004A50  00000000   NOP
298:                     TIMER_5_CLEAR_INT_FLAG();
9D004A54  3C02BF88   LUI V0, -16504
9D004A58  3C030010   LUI V1, 16
9D004A5C  AC431034   SW V1, 4148(V0)
299:                 }
9D004A60  03C0E821   ADDU SP, S8, ZERO
9D004A64  8FA20064   LW V0, 100(SP)
9D004A68  00400013   MTLO V0
9D004A6C  8FA30060   LW V1, 96(SP)
9D004A70  00600011   MTHI V1
9D004A74  8FA2006C   LW V0, 108(SP)
9D004A78  3042000F   ANDI V0, V0, 15
9D004A7C  14400014   BNE V0, ZERO, 0x9D004AD0
9D004A80  00000000   NOP
9D004A84  8FBF005C   LW RA, 92(SP)
9D004A88  8FBE0058   LW S8, 88(SP)
9D004A8C  8FB90054   LW T9, 84(SP)
9D004A90  8FB80050   LW T8, 80(SP)
9D004A94  8FAF004C   LW T7, 76(SP)
9D004A98  8FAE0048   LW T6, 72(SP)
9D004A9C  8FAD0044   LW T5, 68(SP)
9D004AA0  8FAC0040   LW T4, 64(SP)
9D004AA4  8FAB003C   LW T3, 60(SP)
9D004AA8  8FAA0038   LW T2, 56(SP)
9D004AAC  8FA90034   LW T1, 52(SP)
9D004AB0  8FA80030   LW T0, 48(SP)
9D004AB4  8FA7002C   LW A3, 44(SP)
9D004AB8  8FA60028   LW A2, 40(SP)
9D004ABC  8FA50024   LW A1, 36(SP)
9D004AC0  8FA40020   LW A0, 32(SP)
9D004AC4  8FA3001C   LW V1, 28(SP)
9D004AC8  8FA20018   LW V0, 24(SP)
9D004ACC  8FA10014   LW AT, 20(SP)
9D004AD0  00000000   NOP
9D004AD4  41606000   DI ZERO
9D004AD8  000000C0   EHB
9D004ADC  8FBA0074   LW K0, 116(SP)
9D004AE0  8FBB0070   LW K1, 112(SP)
9D004AE4  409A7000   MTC0 K0, EPC
9D004AE8  8FBA006C   LW K0, 108(SP)
9D004AEC  27BD0078   ADDIU SP, SP, 120
9D004AF0  409A6002   MTC0 K0, SRSCtl
9D004AF4  41DDE800   WRPGPR SP, SP
9D004AF8  409B6000   MTC0 K1, Status
9D004AFC  42000018   ERET
9D004B00  27BDFFE0   ADDIU SP, SP, -32
9D004B04  AFBF001C   SW RA, 28(SP)
9D004B08  AFBE0018   SW S8, 24(SP)
9D004B0C  03A0F021   ADDU S8, SP, ZERO
300:                 #else
301:                 void __ISR(_TIMER_5_VECTOR, IPL5AUTO) Timer45Handler(void)
302:                 {
303:                     timer45_isr();
304:                     TIMER_45_CLEAR_INT_FLAG();
305:                 }
306:                 #endif
---  d:/svn/mgw-ace-enc/trunk/pic32/temp_management.c  --------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   06 June 2014                                        &&&
6:                   //&&&   Description :   Manages temperature                                 &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   
9:                   
10:                  #include "common.h"
11:                  #include "delays.h"
12:                  #include "timer.h"
13:                  #include "io_control.h"
14:                  #include "hardware_profile.h"
15:                  #include "power_management.h"
16:                  #include "temp_management.h"
17:                  
18:                  extern CONTEXT g;
19:                  
20:                  #define TARGET_HYST     2
21:                  
22:                  
23:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
24:                  //-------------------------- Get min & max temperature ------------------------
25:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
26:                  s8 max_temp(s8 temp[])
27:                  {
9D0056AC  27BDFFF0   ADDIU SP, SP, -16
28:                      s8 max = temp[TMP75_BR];
9D0056BC  8FC20010   LW V0, 16(S8)
9D0056C0  90420000   LBU V0, 0(V0)
9D0056C4  A3C20000   SB V0, 0(S8)
29:                  
30:                      if (temp[TMP75_TM] > max) max = temp[TMP75_TM];
9D0056C8  8FC20010   LW V0, 16(S8)
9D0056CC  24420001   ADDIU V0, V0, 1
9D0056D0  80420000   LB V0, 0(V0)
9D0056D4  83C30000   LB V1, 0(S8)
9D0056D8  0062102A   SLT V0, V1, V0
9D0056DC  10400004   BEQ V0, ZERO, 0x9D0056F0
9D0056E0  00000000   NOP
9D0056E4  8FC20010   LW V0, 16(S8)
9D0056E8  90420001   LBU V0, 1(V0)
9D0056EC  A3C20000   SB V0, 0(S8)
31:                      if (temp[TMP75_MD] > max) max = temp[TMP75_MD];
9D0056F0  8FC20010   LW V0, 16(S8)
9D0056F4  24420002   ADDIU V0, V0, 2
9D0056F8  80420000   LB V0, 0(V0)
9D0056FC  83C30000   LB V1, 0(S8)
9D005700  0062102A   SLT V0, V1, V0
9D005704  10400004   BEQ V0, ZERO, 0x9D005718
9D005708  00000000   NOP
9D00570C  8FC20010   LW V0, 16(S8)
9D005710  90420002   LBU V0, 2(V0)
9D005714  A3C20000   SB V0, 0(S8)
32:                      if (temp[TMP75_LM] > max) max = temp[TMP75_LM];
9D005718  8FC20010   LW V0, 16(S8)
9D00571C  24420003   ADDIU V0, V0, 3
9D005720  80420000   LB V0, 0(V0)
9D005724  83C30000   LB V1, 0(S8)
9D005728  0062102A   SLT V0, V1, V0
9D00572C  10400004   BEQ V0, ZERO, 0x9D005740
9D005730  00000000   NOP
9D005734  8FC20010   LW V0, 16(S8)
9D005738  90420003   LBU V0, 3(V0)
9D00573C  A3C20000   SB V0, 0(S8)
33:                  //    if (temp[FPGA_ENC] > max) max = temp[FPGA_ENC];
34:                  //    if (temp[FPGA_IO]  > max) max = temp[FPGA_IO];
35:                  
36:                      return max;
9D005740  83C20000   LB V0, 0(S8)
37:                  }
9D005744  03C0E821   ADDU SP, S8, ZERO
9D005748  8FBE000C   LW S8, 12(SP)
9D00574C  27BD0010   ADDIU SP, SP, 16
9D005750  03E00008   JR RA
9D005754  00000000   NOP
38:                  
39:                  s8 min_temp(s8 temp[])
40:                  {
9D005758  27BDFFF0   ADDIU SP, SP, -16
9D00575C  AFBE000C   SW S8, 12(SP)
9D005760  03A0F021   ADDU S8, SP, ZERO
9D005764  AFC40010   SW A0, 16(S8)
41:                      s8 min = temp[TMP75_BR];
9D005768  8FC20010   LW V0, 16(S8)
9D00576C  90420000   LBU V0, 0(V0)
9D005770  A3C20000   SB V0, 0(S8)
42:                  
43:                      if (temp[TMP75_TM] < min) min = temp[TMP75_TM];
9D005774  8FC20010   LW V0, 16(S8)
9D005778  24420001   ADDIU V0, V0, 1
9D00577C  80420000   LB V0, 0(V0)
9D005780  83C30000   LB V1, 0(S8)
9D005784  0043102A   SLT V0, V0, V1
9D005788  10400004   BEQ V0, ZERO, 0x9D00579C
9D00578C  00000000   NOP
9D005790  8FC20010   LW V0, 16(S8)
9D005794  90420001   LBU V0, 1(V0)
9D005798  A3C20000   SB V0, 0(S8)
44:                      if (temp[TMP75_MD] < min) min = temp[TMP75_MD];
9D00579C  8FC20010   LW V0, 16(S8)
9D0057A0  24420002   ADDIU V0, V0, 2
9D0057A4  80420000   LB V0, 0(V0)
9D0057A8  83C30000   LB V1, 0(S8)
9D0057AC  0043102A   SLT V0, V0, V1
9D0057B0  10400004   BEQ V0, ZERO, 0x9D0057C4
9D0057B4  00000000   NOP
9D0057B8  8FC20010   LW V0, 16(S8)
9D0057BC  90420002   LBU V0, 2(V0)
9D0057C0  A3C20000   SB V0, 0(S8)
45:                      if (temp[TMP75_LM] < min) min = temp[TMP75_LM];
9D0057C4  8FC20010   LW V0, 16(S8)
9D0057C8  24420003   ADDIU V0, V0, 3
9D0057CC  80420000   LB V0, 0(V0)
9D0057D0  83C30000   LB V1, 0(S8)
9D0057D4  0043102A   SLT V0, V0, V1
9D0057D8  10400004   BEQ V0, ZERO, 0x9D0057EC
9D0057DC  00000000   NOP
9D0057E0  8FC20010   LW V0, 16(S8)
9D0057E4  90420003   LBU V0, 3(V0)
9D0057E8  A3C20000   SB V0, 0(S8)
46:                  //    if (temp[FPGA_ENC] < min) min = temp[FPGA_ENC];
47:                  //    if (temp[FPGA_IO]  < min) min = temp[FPGA_IO];
48:                  
49:                      return min;
9D0057EC  83C20000   LB V0, 0(S8)
50:                  }
9D0057F0  03C0E821   ADDU SP, S8, ZERO
9D0057F4  8FBE000C   LW S8, 12(SP)
9D0057F8  27BD0010   ADDIU SP, SP, 16
9D0057FC  03E00008   JR RA
9D005800  00000000   NOP
51:                  
52:                  
53:                  
54:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
55:                  //-------------------------- Temperature Management ---------------------------
56:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
57:                  RESULT temperature_management(u16 temp[])
58:                  {
9D005804  27BDFFD8   ADDIU SP, SP, -40
9D005808  AFBF0024   SW RA, 36(SP)
9D00580C  AFBE0020   SW S8, 32(SP)
9D005810  03A0F021   ADDU S8, SP, ZERO
9D005814  AFC40028   SW A0, 40(S8)
59:                      s8 t[NB_SENSORS];
60:                      u8 fan_speed = 0;
9D005818  A3C00010   SB ZERO, 16(S8)
61:                      static u8 use_regul = 0;
62:                      s8 target_high = g.temp_target + TARGET_HYST / 2;
9D00581C  3C02A000   LUI V0, -24576
9D005820  8042000C   LB V0, 12(V0)
9D005824  304200FF   ANDI V0, V0, 255
9D005828  24420001   ADDIU V0, V0, 1
9D00582C  304200FF   ANDI V0, V0, 255
9D005830  A3C20011   SB V0, 17(S8)
63:                      s8 target_low  = g.temp_target - TARGET_HYST / 2;
9D005834  3C02A000   LUI V0, -24576
9D005838  8042000C   LB V0, 12(V0)
9D00583C  304200FF   ANDI V0, V0, 255
9D005840  2442FFFF   ADDIU V0, V0, -1
9D005844  304200FF   ANDI V0, V0, 255
9D005848  A3C20012   SB V0, 18(S8)
64:                      s8 temp_reg_max = g.temp_warning;
9D00584C  3C02A000   LUI V0, -24576
9D005850  2442000C   ADDIU V0, V0, 12
9D005854  90420002   LBU V0, 2(V0)
9D005858  A3C20013   SB V0, 19(S8)
65:                      s8 temp_reg_min = target_low;
9D00585C  93C20012   LBU V0, 18(S8)
9D005860  A3C20014   SB V0, 20(S8)
66:                  
67:                      // convert s16 to s8 and remove decimal part
68:                      t[TMP75_BR] = temp2celsius(temp[TMP75_BR]);
9D005864  8FC20028   LW V0, 40(S8)
9D005868  94420000   LHU V0, 0(V0)
9D00586C  00021102   SRL V0, V0, 4
9D005870  3042FFFF   ANDI V0, V0, -1
9D005874  7C021420   SEB V0, V0
9D005878  A3C20018   SB V0, 24(S8)
69:                      t[TMP75_TM] = temp2celsius(temp[TMP75_TM]);
9D00587C  8FC20028   LW V0, 40(S8)
9D005880  24420002   ADDIU V0, V0, 2
9D005884  94420000   LHU V0, 0(V0)
9D005888  00021102   SRL V0, V0, 4
9D00588C  3042FFFF   ANDI V0, V0, -1
9D005890  7C021420   SEB V0, V0
9D005894  A3C20019   SB V0, 25(S8)
70:                      t[TMP75_MD] = temp2celsius(temp[TMP75_MD]);
9D005898  8FC20028   LW V0, 40(S8)
9D00589C  24420004   ADDIU V0, V0, 4
9D0058A0  94420000   LHU V0, 0(V0)
9D0058A4  00021102   SRL V0, V0, 4
9D0058A8  3042FFFF   ANDI V0, V0, -1
9D0058AC  7C021420   SEB V0, V0
9D0058B0  A3C2001A   SB V0, 26(S8)
71:                      t[TMP75_LM] = temp2celsius(temp[TMP75_LM]);
9D0058B4  8FC20028   LW V0, 40(S8)
9D0058B8  24420006   ADDIU V0, V0, 6
9D0058BC  94420000   LHU V0, 0(V0)
9D0058C0  00021102   SRL V0, V0, 4
9D0058C4  3042FFFF   ANDI V0, V0, -1
9D0058C8  7C021420   SEB V0, V0
9D0058CC  A3C2001B   SB V0, 27(S8)
72:                      t[FPGA_ENC] = temp[FPGA_ENC];
9D0058D0  8FC20028   LW V0, 40(S8)
9D0058D4  24420008   ADDIU V0, V0, 8
9D0058D8  94420000   LHU V0, 0(V0)
9D0058DC  7C021420   SEB V0, V0
9D0058E0  A3C2001C   SB V0, 28(S8)
73:                      t[FPGA_IO]  = temp[FPGA_IO];
9D0058E4  8FC20028   LW V0, 40(S8)
9D0058E8  2442000A   ADDIU V0, V0, 10
9D0058EC  94420000   LHU V0, 0(V0)
9D0058F0  7C021420   SEB V0, V0
9D0058F4  A3C2001D   SB V0, 29(S8)
74:                  
75:                      // get min and max temperature of the 4 sensors
76:                  //    g.temp_max = max_temp(t);
77:                      g.temp_max = t[TMP75_MD];
9D0058F8  83C3001A   LB V1, 26(S8)
9D0058FC  3C02A000   LUI V0, -24576
9D005900  2442000C   ADDIU V0, V0, 12
9D005904  A0430017   SB V1, 23(V0)
78:                      g.temp_min = min_temp(t);
9D005908  27C20018   ADDIU V0, S8, 24
9D00590C  00402021   ADDU A0, V0, ZERO
9D005910  0F4015D6   JAL min_temp
9D005914  00000000   NOP
9D005918  00401821   ADDU V1, V0, ZERO
9D00591C  3C02A000   LUI V0, -24576
9D005920  2442000C   ADDIU V0, V0, 12
9D005924  A0430016   SB V1, 22(V0)
79:                  
80:                  
81:                      // determine if the regulation must be activated or not
82:                      if ((g.temp_max >= target_high) || (use_regul == 1 && g.temp_max >= target_low)){
9D005928  3C02A000   LUI V0, -24576
9D00592C  2442000C   ADDIU V0, V0, 12
9D005930  80420017   LB V0, 23(V0)
9D005934  83C30011   LB V1, 17(S8)
9D005938  0043102A   SLT V0, V0, V1
9D00593C  1040000C   BEQ V0, ZERO, 0x9D005970
9D005940  00000000   NOP
9D005944  93838014   LBU V1, -32748(GP)
9D005948  24020001   ADDIU V0, ZERO, 1
9D00594C  1462000C   BNE V1, V0, 0x9D005980
9D005950  00000000   NOP
9D005954  3C02A000   LUI V0, -24576
9D005958  2442000C   ADDIU V0, V0, 12
9D00595C  80420017   LB V0, 23(V0)
9D005960  83C30012   LB V1, 18(S8)
9D005964  0043102A   SLT V0, V0, V1
9D005968  14400005   BNE V0, ZERO, 0x9D005980
9D00596C  00000000   NOP
83:                          use_regul = 1;
9D005970  24020001   ADDIU V0, ZERO, 1
9D005974  A3828014   SB V0, -32748(GP)
9D005978  0B401661   J 0x9D005984
9D00597C  00000000   NOP
84:                      }else{
85:                          use_regul = 0;
9D005980  A3808014   SB ZERO, -32748(GP)
86:                      }
87:                  
88:                      g.debug1 = use_regul;
9D005984  93838014   LBU V1, -32748(GP)
9D005988  3C02A000   LUI V0, -24576
9D00598C  2442000C   ADDIU V0, V0, 12
9D005990  A0430085   SB V1, 133(V0)
89:                      g.debug2 = temp_reg_min;
9D005994  93C30014   LBU V1, 20(S8)
9D005998  3C02A000   LUI V0, -24576
9D00599C  2442000C   ADDIU V0, V0, 12
9D0059A0  A0430086   SB V1, 134(V0)
90:                      g.debug5 = g.temp_max;
9D0059A4  3C02A000   LUI V0, -24576
9D0059A8  2442000C   ADDIU V0, V0, 12
9D0059AC  80420017   LB V0, 23(V0)
9D0059B0  304300FF   ANDI V1, V0, 255
9D0059B4  3C02A000   LUI V0, -24576
9D0059B8  2442000C   ADDIU V0, V0, 12
9D0059BC  A0430089   SB V1, 137(V0)
91:                      g.debug6 = PWM_FAN_MAX;
9D0059C0  3C02A000   LUI V0, -24576
9D0059C4  2442000C   ADDIU V0, V0, 12
9D0059C8  24030064   ADDIU V1, ZERO, 100
9D0059CC  A043008A   SB V1, 138(V0)
92:                      g.debug7 = PWM_FAN_MIN;
9D0059D0  3C02A000   LUI V0, -24576
9D0059D4  2442000C   ADDIU V0, V0, 12
9D0059D8  24030019   ADDIU V1, ZERO, 25
9D0059DC  A043008B   SB V1, 139(V0)
93:                      g.debug8 = g.critical_state;
9D0059E0  3C02A000   LUI V0, -24576
9D0059E4  2442000C   ADDIU V0, V0, 12
9D0059E8  8C420018   LW V0, 24(V0)
9D0059EC  304300FF   ANDI V1, V0, 255
9D0059F0  3C02A000   LUI V0, -24576
9D0059F4  2442000C   ADDIU V0, V0, 12
9D0059F8  A043008C   SB V1, 140(V0)
94:                  
95:                      // the temperature is really too hot -> critical
96:                      if (g.temp_max >= g.temp_critical)
9D0059FC  3C02A000   LUI V0, -24576
9D005A00  2442000C   ADDIU V0, V0, 12
9D005A04  80430017   LB V1, 23(V0)
9D005A08  3C02A000   LUI V0, -24576
9D005A0C  2442000C   ADDIU V0, V0, 12
9D005A10  80420004   LB V0, 4(V0)
9D005A14  0062102A   SLT V0, V1, V0
9D005A18  14400069   BNE V0, ZERO, 0x9D005BC0
9D005A1C  00000000   NOP
97:                      {
98:                          g.debug3 = 1;
9D005A20  3C02A000   LUI V0, -24576
9D005A24  2442000C   ADDIU V0, V0, 12
9D005A28  24030001   ADDIU V1, ZERO, 1
9D005A2C  A0430087   SB V1, 135(V0)
99:                          // generate an IT to the SoC
100:                         if (g.it_en.temp_critical)
9D005A30  3C02A000   LUI V0, -24576
9D005A34  2442000C   ADDIU V0, V0, 12
9D005A38  8C430048   LW V1, 72(V0)
9D005A3C  3C020100   LUI V0, 256
9D005A40  00621024   AND V0, V1, V0
9D005A44  10400007   BEQ V0, ZERO, 0x9D005A64
9D005A48  00000000   NOP
101:                             g.it_cause.temp_critical = 1;
9D005A4C  3C02A000   LUI V0, -24576
9D005A50  2443000C   ADDIU V1, V0, 12
9D005A54  9062004A   LBU V0, 74(V1)
9D005A58  24040001   ADDIU A0, ZERO, 1
9D005A5C  7C820004   INS V0, A0, 0, 1
9D005A60  A062004A   SB V0, 74(V1)
102:                 
103:                         // set the fan at its maximum speed
104:                         if (g.fan_spin_up == false && g.fan_speed_by_soc != true){
9D005A64  3C02A000   LUI V0, -24576
9D005A68  2442000C   ADDIU V0, V0, 12
9D005A6C  8C420024   LW V0, 36(V0)
9D005A70  1440000B   BNE V0, ZERO, 0x9D005AA0
9D005A74  00000000   NOP
9D005A78  3C02A000   LUI V0, -24576
9D005A7C  2442000C   ADDIU V0, V0, 12
9D005A80  8C430044   LW V1, 68(V0)
9D005A84  24020001   ADDIU V0, ZERO, 1
9D005A88  10620005   BEQ V1, V0, 0x9D005AA0
9D005A8C  00000000   NOP
105:                             set_fan_speed(PWM_FAN_MAX);
9D005A90  00002021   ADDU A0, ZERO, ZERO
9D005A94  240503E8   ADDIU A1, ZERO, 1000
9D005A98  0F40205A   JAL pwm_set_duty_cycle
9D005A9C  00000000   NOP
106:                         }
107:                 
108:                         // disable arria power supply
109:                         if (g.critical_state == false){
9D005AA0  3C02A000   LUI V0, -24576
9D005AA4  2442000C   ADDIU V0, V0, 12
9D005AA8  8C420018   LW V0, 24(V0)
9D005AAC  14400113   BNE V0, ZERO, 0x9D005EFC
9D005AB0  00000000   NOP
110:                 
111:                             #if defined (_PCB3_) || defined (_PCB4_)
112:                                 PIN_PWR_EN_ARRIA_3 = 0;
113:                                 PIN_PWR_ARRIA_DIS_3 = 1;
114:                                 delay_ms(2);
115:                                 PIN_PWR_EN_ARRIA_2 = 0;
116:                                 PIN_PWR_ARRIA_DIS_2 = 1;
117:                                 delay_ms(2);
118:                                 PIN_PWR_ARRIA_DIS_2 = 0;
119:                                 PIN_PWR_ARRIA_DIS_3 = 0;
120:                             #elif defined (_PCB5_)
121:                                 PIN_PWR_EN_1V5 = 0;
9D005AB4  3C03BF88   LUI V1, -16504
9D005AB8  946260E0   LHU V0, 24800(V1)
9D005ABC  7C026304   INS V0, ZERO, 12, 1
9D005AC0  A46260E0   SH V0, 24800(V1)
122:                                 PIN_PWR_DIS_1V5 = 1;
9D005AC4  3C03BF88   LUI V1, -16504
9D005AC8  946260A0   LHU V0, 24736(V1)
9D005ACC  24040001   ADDIU A0, ZERO, 1
9D005AD0  7C821084   INS V0, A0, 2, 1
9D005AD4  A46260A0   SH V0, 24736(V1)
123:                                 delay_ms(2);
9D005AD8  24040002   ADDIU A0, ZERO, 2
9D005ADC  0F40218B   JAL delay_ms
9D005AE0  00000000   NOP
124:                                 PIN_PWR_EN_1V8 = 0;
9D005AE4  3C03BF88   LUI V1, -16504
9D005AE8  946260E0   LHU V0, 24800(V1)
9D005AEC  7C026B44   INS V0, ZERO, 13, 1
9D005AF0  A46260E0   SH V0, 24800(V1)
125:                                 PIN_PWR_DIS_1V8 = 1;
9D005AF4  3C03BF88   LUI V1, -16504
9D005AF8  946260A0   LHU V0, 24736(V1)
9D005AFC  24040001   ADDIU A0, ZERO, 1
9D005B00  7C820844   INS V0, A0, 1, 1
9D005B04  A46260A0   SH V0, 24736(V1)
126:                                 delay_ms(2);
9D005B08  24040002   ADDIU A0, ZERO, 2
9D005B0C  0F40218B   JAL delay_ms
9D005B10  00000000   NOP
127:                                 PIN_PWR_EN_0V9_ENC = 0;
9D005B14  3C03BF88   LUI V1, -16504
9D005B18  946260E0   LHU V0, 24800(V1)
9D005B1C  7C022944   INS V0, ZERO, 5, 1
9D005B20  A46260E0   SH V0, 24800(V1)
128:                                 PIN_PWR_DIS_0V9_ENC = 1;
9D005B24  3C03BF88   LUI V1, -16504
9D005B28  946260A0   LHU V0, 24736(V1)
9D005B2C  24040001   ADDIU A0, ZERO, 1
9D005B30  7C8218C4   INS V0, A0, 3, 1
9D005B34  A46260A0   SH V0, 24736(V1)
129:                                 PIN_PWR_EN_0V9_IO = 0;
9D005B38  3C03BF88   LUI V1, -16504
9D005B3C  946260E0   LHU V0, 24800(V1)
9D005B40  7C022104   INS V0, ZERO, 4, 1
9D005B44  A46260E0   SH V0, 24800(V1)
130:                                 PIN_PWR_DIS_0V9_IO = 1;
9D005B48  3C03BF88   LUI V1, -16504
9D005B4C  94626120   LHU V0, 24864(V1)
9D005B50  24040001   ADDIU A0, ZERO, 1
9D005B54  7C823184   INS V0, A0, 6, 1
9D005B58  A4626120   SH V0, 24864(V1)
131:                                 delay_ms(5);
9D005B5C  24040005   ADDIU A0, ZERO, 5
9D005B60  0F40218B   JAL delay_ms
9D005B64  00000000   NOP
132:                                 PIN_PWR_DIS_1V5 = 0;
9D005B68  3C03BF88   LUI V1, -16504
9D005B6C  946260A0   LHU V0, 24736(V1)
9D005B70  7C021084   INS V0, ZERO, 2, 1
9D005B74  A46260A0   SH V0, 24736(V1)
133:                                 PIN_PWR_DIS_1V8 = 0;
9D005B78  3C03BF88   LUI V1, -16504
9D005B7C  946260A0   LHU V0, 24736(V1)
9D005B80  7C020844   INS V0, ZERO, 1, 1
9D005B84  A46260A0   SH V0, 24736(V1)
134:                                 PIN_PWR_DIS_0V9_ENC = 0;
9D005B88  3C03BF88   LUI V1, -16504
9D005B8C  946260A0   LHU V0, 24736(V1)
9D005B90  7C0218C4   INS V0, ZERO, 3, 1
9D005B94  A46260A0   SH V0, 24736(V1)
135:                                 PIN_PWR_DIS_0V9_IO = 0;
9D005B98  3C03BF88   LUI V1, -16504
9D005B9C  94626120   LHU V0, 24864(V1)
9D005BA0  7C023184   INS V0, ZERO, 6, 1
9D005BA4  A4626120   SH V0, 24864(V1)
136:                             #endif
137:                 
138:                             g.critical_state = true;
9D005BA8  3C02A000   LUI V0, -24576
9D005BAC  2442000C   ADDIU V0, V0, 12
9D005BB0  24030001   ADDIU V1, ZERO, 1
9D005BB4  AC430018   SW V1, 24(V0)
9D005BB8  0B4017BF   J 0x9D005EFC
9D005BBC  00000000   NOP
139:                         }
140:                     }
141:                 
142:                     // the temperature is too hot -> fan is at its maximum speed + IT
143:                     else if (g.temp_max >= g.temp_warning)
9D005BC0  3C02A000   LUI V0, -24576
9D005BC4  2442000C   ADDIU V0, V0, 12
9D005BC8  80430017   LB V1, 23(V0)
9D005BCC  3C02A000   LUI V0, -24576
9D005BD0  2442000C   ADDIU V0, V0, 12
9D005BD4  80420002   LB V0, 2(V0)
9D005BD8  0062102A   SLT V0, V1, V0
9D005BDC  14400024   BNE V0, ZERO, 0x9D005C70
9D005BE0  00000000   NOP
144:                     {
145:                         g.debug3 = 2;
9D005BE4  3C02A000   LUI V0, -24576
9D005BE8  2442000C   ADDIU V0, V0, 12
9D005BEC  24030002   ADDIU V1, ZERO, 2
9D005BF0  A0430087   SB V1, 135(V0)
146:                         // generate an IT to the SoC
147:                         if (g.it_en.temp_hot)
9D005BF4  3C02A000   LUI V0, -24576
9D005BF8  2442000C   ADDIU V0, V0, 12
9D005BFC  8C430048   LW V1, 72(V0)
9D005C00  3C020200   LUI V0, 512
9D005C04  00621024   AND V0, V1, V0
9D005C08  10400007   BEQ V0, ZERO, 0x9D005C28
9D005C0C  00000000   NOP
148:                             g.it_cause.temp_hot = 1;
9D005C10  3C02A000   LUI V0, -24576
9D005C14  2443000C   ADDIU V1, V0, 12
9D005C18  9062004A   LBU V0, 74(V1)
9D005C1C  24040001   ADDIU A0, ZERO, 1
9D005C20  7C820844   INS V0, A0, 1, 1
9D005C24  A062004A   SB V0, 74(V1)
149:                 
150:                         if (g.fan_spin_up == false && g.fan_speed_by_soc != true){
9D005C28  3C02A000   LUI V0, -24576
9D005C2C  2442000C   ADDIU V0, V0, 12
9D005C30  8C420024   LW V0, 36(V0)
9D005C34  1440000B   BNE V0, ZERO, 0x9D005C64
9D005C38  00000000   NOP
9D005C3C  3C02A000   LUI V0, -24576
9D005C40  2442000C   ADDIU V0, V0, 12
9D005C44  8C430044   LW V1, 68(V0)
9D005C48  24020001   ADDIU V0, ZERO, 1
9D005C4C  10620005   BEQ V1, V0, 0x9D005C64
9D005C50  00000000   NOP
151:                             set_fan_speed(PWM_FAN_MAX);                             // fan at maximum speed
9D005C54  00002021   ADDU A0, ZERO, ZERO
9D005C58  240503E8   ADDIU A1, ZERO, 1000
9D005C5C  0F40205A   JAL pwm_set_duty_cycle
9D005C60  00000000   NOP
152:                         }
153:                 
154:                         return ERROR;
9D005C64  24020001   ADDIU V0, ZERO, 1
9D005C68  0B4017C0   J 0x9D005F00
9D005C6C  00000000   NOP
155:                     }
156:                 
157:                     // the temperature is good -> regulation mode
158:                     else if (g.temp_max > g.temp_fan_off && g.temp_max < g.temp_warning)
9D005C70  3C02A000   LUI V0, -24576
9D005C74  2442000C   ADDIU V0, V0, 12
9D005C78  80430017   LB V1, 23(V0)
9D005C7C  3C02A000   LUI V0, -24576
9D005C80  2442000C   ADDIU V0, V0, 12
9D005C84  80420003   LB V0, 3(V0)
9D005C88  0043102A   SLT V0, V0, V1
9D005C8C  10400064   BEQ V0, ZERO, 0x9D005E20
9D005C90  00000000   NOP
9D005C94  3C02A000   LUI V0, -24576
9D005C98  2442000C   ADDIU V0, V0, 12
9D005C9C  80430017   LB V1, 23(V0)
9D005CA0  3C02A000   LUI V0, -24576
9D005CA4  2442000C   ADDIU V0, V0, 12
9D005CA8  80420002   LB V0, 2(V0)
9D005CAC  0062102A   SLT V0, V1, V0
9D005CB0  1040005B   BEQ V0, ZERO, 0x9D005E20
9D005CB4  00000000   NOP
159:                     {
160:                         g.debug3 = 3;
9D005CB8  3C02A000   LUI V0, -24576
9D005CBC  2442000C   ADDIU V0, V0, 12
9D005CC0  24030003   ADDIU V1, ZERO, 3
9D005CC4  A0430087   SB V1, 135(V0)
161:                         if (g.fan_spin_up == false && g.fan_speed_by_soc != true){
9D005CC8  3C02A000   LUI V0, -24576
9D005CCC  2442000C   ADDIU V0, V0, 12
9D005CD0  8C420024   LW V0, 36(V0)
9D005CD4  1440004F   BNE V0, ZERO, 0x9D005E14
9D005CD8  00000000   NOP
9D005CDC  3C02A000   LUI V0, -24576
9D005CE0  2442000C   ADDIU V0, V0, 12
9D005CE4  8C430044   LW V1, 68(V0)
9D005CE8  24020001   ADDIU V0, ZERO, 1
9D005CEC  10620049   BEQ V1, V0, 0x9D005E14
9D005CF0  00000000   NOP
162:                 
163:                             if (use_regul){
9D005CF4  93828014   LBU V0, -32748(GP)
9D005CF8  1040003E   BEQ V0, ZERO, 0x9D005DF4
9D005CFC  00000000   NOP
164:                                 g.debug3 = 4;
9D005D00  3C02A000   LUI V0, -24576
9D005D04  2442000C   ADDIU V0, V0, 12
9D005D08  24030004   ADDIU V1, ZERO, 4
9D005D0C  A0430087   SB V1, 135(V0)
165:                                 fan_speed = ((g.temp_max-temp_reg_min)*(PWM_FAN_MAX-PWM_FAN_MIN)/(temp_reg_max-temp_reg_min))+PWM_FAN_MIN;
9D005D10  3C02A000   LUI V0, -24576
9D005D14  2442000C   ADDIU V0, V0, 12
9D005D18  80420017   LB V0, 23(V0)
9D005D1C  00401821   ADDU V1, V0, ZERO
9D005D20  83C20014   LB V0, 20(S8)
9D005D24  00621823   SUBU V1, V1, V0
9D005D28  00601021   ADDU V0, V1, ZERO
9D005D2C  00021080   SLL V0, V0, 2
9D005D30  00431021   ADDU V0, V0, V1
9D005D34  00021900   SLL V1, V0, 4
9D005D38  00621823   SUBU V1, V1, V0
9D005D3C  83C40013   LB A0, 19(S8)
9D005D40  83C20014   LB V0, 20(S8)
9D005D44  00821023   SUBU V0, A0, V0
9D005D48  0062001A   DIV V1, V0
9D005D4C  004001F4   TEQ V0, ZERO
9D005D50  00001010   MFHI V0
9D005D54  00001012   MFLO V0
9D005D58  304200FF   ANDI V0, V0, 255
9D005D5C  24420019   ADDIU V0, V0, 25
9D005D60  A3C20010   SB V0, 16(S8)
166:                                 if (fan_speed > PWM_FAN_MAX){
9D005D64  93C20010   LBU V0, 16(S8)
9D005D68  2C420065   SLTIU V0, V0, 101
9D005D6C  14400005   BNE V0, ZERO, 0x9D005D84
9D005D70  00000000   NOP
167:                                     fan_speed = PWM_FAN_MAX;
9D005D74  24020064   ADDIU V0, ZERO, 100
9D005D78  A3C20010   SB V0, 16(S8)
9D005D7C  0B401767   J 0x9D005D9C
9D005D80  00000000   NOP
168:                                 }else if (fan_speed < PWM_FAN_MIN){
9D005D84  93C20010   LBU V0, 16(S8)
9D005D88  2C420019   SLTIU V0, V0, 25
9D005D8C  10400003   BEQ V0, ZERO, 0x9D005D9C
9D005D90  00000000   NOP
169:                                     fan_speed = PWM_FAN_MIN;
9D005D94  24020019   ADDIU V0, ZERO, 25
9D005D98  A3C20010   SB V0, 16(S8)
170:                                 }
171:                                 g.debug0 = fan_speed;
9D005D9C  3C02A000   LUI V0, -24576
9D005DA0  2442000C   ADDIU V0, V0, 12
9D005DA4  93C30010   LBU V1, 16(S8)
9D005DA8  A0430084   SB V1, 132(V0)
172:                                 set_fan_speed(fan_lut[fan_speed]);
9D005DAC  93C30010   LBU V1, 16(S8)
9D005DB0  3C029D01   LUI V0, -25343
9D005DB4  244288E0   ADDIU V0, V0, -30496
9D005DB8  00621021   ADDU V0, V1, V0
9D005DBC  90420000   LBU V0, 0(V0)
9D005DC0  00021040   SLL V0, V0, 1
9D005DC4  00021880   SLL V1, V0, 2
9D005DC8  00431021   ADDU V0, V0, V1
9D005DCC  00002021   ADDU A0, ZERO, ZERO
9D005DD0  00402821   ADDU A1, V0, ZERO
9D005DD4  0F40205A   JAL pwm_set_duty_cycle
9D005DD8  00000000   NOP
173:                                 g.debug9 = fan_speed;
9D005DDC  3C02A000   LUI V0, -24576
9D005DE0  2442000C   ADDIU V0, V0, 12
9D005DE4  93C30010   LBU V1, 16(S8)
9D005DE8  A043008D   SB V1, 141(V0)
9D005DEC  0B401785   J 0x9D005E14
9D005DF0  00000000   NOP
174:                             }else{
175:                                 set_fan_speed(PWM_FAN_MIN);
9D005DF4  00002021   ADDU A0, ZERO, ZERO
9D005DF8  240500FA   ADDIU A1, ZERO, 250
9D005DFC  0F40205A   JAL pwm_set_duty_cycle
9D005E00  00000000   NOP
176:                                 g.debug9 = PWM_FAN_MIN;
9D005E04  3C02A000   LUI V0, -24576
9D005E08  2442000C   ADDIU V0, V0, 12
9D005E0C  24030019   ADDIU V1, ZERO, 25
9D005E10  A043008D   SB V1, 141(V0)
177:                             }
178:                         }
179:                         return SUCCESS;
9D005E14  00001021   ADDU V0, ZERO, ZERO
9D005E18  0B4017C0   J 0x9D005F00
9D005E1C  00000000   NOP
180:                     }
181:                 
182:                     // the temperature is too cold
183:                     else if (g.temp_max <= g.temp_too_low)
9D005E20  3C02A000   LUI V0, -24576
9D005E24  2442000C   ADDIU V0, V0, 12
9D005E28  80430017   LB V1, 23(V0)
9D005E2C  3C02A000   LUI V0, -24576
9D005E30  2442000C   ADDIU V0, V0, 12
9D005E34  80420001   LB V0, 1(V0)
9D005E38  0043102A   SLT V0, V0, V1
9D005E3C  14400019   BNE V0, ZERO, 0x9D005EA4
9D005E40  00000000   NOP
184:                     {
185:                         g.debug3 = 5;
9D005E44  3C02A000   LUI V0, -24576
9D005E48  2442000C   ADDIU V0, V0, 12
9D005E4C  24030005   ADDIU V1, ZERO, 5
9D005E50  A0430087   SB V1, 135(V0)
186:                         set_fan_speed(PWM_FAN_OFF);
9D005E54  00002021   ADDU A0, ZERO, ZERO
9D005E58  00002821   ADDU A1, ZERO, ZERO
9D005E5C  0F40205A   JAL pwm_set_duty_cycle
9D005E60  00000000   NOP
187:                         if (g.it_en.temp_cold)
9D005E64  3C02A000   LUI V0, -24576
9D005E68  2442000C   ADDIU V0, V0, 12
9D005E6C  8C430048   LW V1, 72(V0)
9D005E70  3C020400   LUI V0, 1024
9D005E74  00621024   AND V0, V1, V0
9D005E78  10400007   BEQ V0, ZERO, 0x9D005E98
9D005E7C  00000000   NOP
188:                             g.it_cause.temp_cold = 1;
9D005E80  3C02A000   LUI V0, -24576
9D005E84  2443000C   ADDIU V1, V0, 12
9D005E88  9062004A   LBU V0, 74(V1)
9D005E8C  24040001   ADDIU A0, ZERO, 1
9D005E90  7C821084   INS V0, A0, 2, 1
9D005E94  A062004A   SB V0, 74(V1)
189:                         #if USE_HEAT_RESISTORS
190:                         power_resistors_control(PWR_RES_ALL_ON);                // power heat resistors
191:                         #endif
192:                         return ERROR;
9D005E98  24020001   ADDIU V0, ZERO, 1
9D005E9C  0B4017C0   J 0x9D005F00
9D005EA0  00000000   NOP
193:                     }
194:                 
195:                     // the temperature is good and there is no need of the fan
196:                     else
197:                     {
198:                         g.debug3 = 6;
9D005EA4  3C02A000   LUI V0, -24576
9D005EA8  2442000C   ADDIU V0, V0, 12
9D005EAC  24030006   ADDIU V1, ZERO, 6
9D005EB0  A0430087   SB V1, 135(V0)
199:                         if (g.fan_spin_up == false && g.fan_speed_by_soc != true){
9D005EB4  3C02A000   LUI V0, -24576
9D005EB8  2442000C   ADDIU V0, V0, 12
9D005EBC  8C420024   LW V0, 36(V0)
9D005EC0  1440000B   BNE V0, ZERO, 0x9D005EF0
9D005EC4  00000000   NOP
9D005EC8  3C02A000   LUI V0, -24576
9D005ECC  2442000C   ADDIU V0, V0, 12
9D005ED0  8C430044   LW V1, 68(V0)
9D005ED4  24020001   ADDIU V0, ZERO, 1
9D005ED8  10620005   BEQ V1, V0, 0x9D005EF0
9D005EDC  00000000   NOP
200:                             set_fan_speed(PWM_FAN_OFF);         // fan is stopped
9D005EE0  00002021   ADDU A0, ZERO, ZERO
9D005EE4  00002821   ADDU A1, ZERO, ZERO
9D005EE8  0F40205A   JAL pwm_set_duty_cycle
9D005EEC  00000000   NOP
201:                         }
202:                         return SUCCESS;
9D005EF0  00001021   ADDU V0, ZERO, ZERO
9D005EF4  0B4017C0   J 0x9D005F00
9D005EF8  00000000   NOP
203:                     }
204:                 
205:                     return SUCCESS;
9D005EFC  00001021   ADDU V0, ZERO, ZERO
206:                 }
9D005F00  03C0E821   ADDU SP, S8, ZERO
9D005F04  8FBF0024   LW RA, 36(SP)
9D005F08  8FBE0020   LW S8, 32(SP)
9D005F0C  27BD0028   ADDIU SP, SP, 40
9D005F10  03E00008   JR RA
9D005F14  00000000   NOP
207:                 
208:                 
209:                 
210:                 
211:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
212:                 //------------ Set the speed of the fan at maximum durring boot ---------------
213:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
214:                 void fan_spin_up()
215:                 {
9D005F18  27BDFFE8   ADDIU SP, SP, -24
9D005F1C  AFBF0014   SW RA, 20(SP)
9D005F20  AFBE0010   SW S8, 16(SP)
9D005F24  03A0F021   ADDU S8, SP, ZERO
216:                     // the fan runs at full speed for 4 seconds at start-up
217:                     // then, it enters in regulation mode
218:                     static u8 count = 0;
219:                 
220:                     if (count++ >= SPIN_UP_TIME-1){
9D005F28  93828015   LBU V0, -32747(GP)
9D005F2C  24430001   ADDIU V1, V0, 1
9D005F30  306300FF   ANDI V1, V1, 255
9D005F34  A3838015   SB V1, -32747(GP)
9D005F38  2C420003   SLTIU V0, V0, 3
9D005F3C  1440000F   BNE V0, ZERO, 0x9D005F7C
9D005F40  00000000   NOP
221:                         set_fan_speed(PWM_FAN_MIN);
9D005F44  00002021   ADDU A0, ZERO, ZERO
9D005F48  240500FA   ADDIU A1, ZERO, 250
9D005F4C  0F40205A   JAL pwm_set_duty_cycle
9D005F50  00000000   NOP
222:                         g.fan_spin_up = false;
9D005F54  3C02A000   LUI V0, -24576
9D005F58  2442000C   ADDIU V0, V0, 12
9D005F5C  AC400024   SW ZERO, 36(V0)
223:                 
224:                         // close timer 5
225:                         TIMER_5_INT_ENABLE(0);
9D005F60  3C02BF88   LUI V0, -16504
9D005F64  3C030010   LUI V1, 16
9D005F68  AC431064   SW V1, 4196(V0)
9D005F6C  3C02BF88   LUI V0, -16504
9D005F70  AC401068   SW ZERO, 4200(V0)
226:                         T5CON = 0;
9D005F74  3C02BF80   LUI V0, -16512
9D005F78  AC400E00   SW ZERO, 3584(V0)
227:                     }
228:                 }
9D005F7C  03C0E821   ADDU SP, S8, ZERO
9D005F80  8FBF0014   LW RA, 20(SP)
9D005F84  8FBE0010   LW S8, 16(SP)
9D005F88  27BD0018   ADDIU SP, SP, 24
9D005F8C  03E00008   JR RA
9D005F90  00000000   NOP
9D005F94  27BDFFD8   ADDIU SP, SP, -40
229:                 
---  d:/svn/mgw-ace-enc/trunk/pic32/pwm.c  --------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Version     :   v1.2                                                &&&
4:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:                   //&&&   Description :   - Init pwm                                          &&&
6:                   //&&&                   - Set duty cycle                                    &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   //&&&   Infos       :   -                                                   &&&
9:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
10:                  //&&&   Versions    :                                                       &&&
11:                  //&&&   1.0 - 2014/06/14 - PBL - First release                              &&&
12:                  //&&&   1.1 - 2015/01/26 - PBL - Modified range from 0 to 100               &&&
13:                  //&&&   1.2 - 2016/08/22 - PBL - Rebuild module                             &&&
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  
16:                  #include "pwm.h"
17:                  #include "timer.h"
18:                  #include "types.h"
19:                  #include "hardware_profile.h"
20:                  
21:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
22:                  //------------------------------- Init PWM ------------------------------------
23:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
24:                  RESULT pwm_init(PWM_MODULE module, u32 period)
25:                  {
9D008084  27BDFFF8   ADDIU SP, SP, -8
9D008088  AFBE0004   SW S8, 4(SP)
9D00808C  03A0F021   ADDU S8, SP, ZERO
9D008090  AFC40008   SW A0, 8(S8)
9D008094  AFC5000C   SW A1, 12(S8)
26:                      // Configure Output Compare module
27:                      if (module == PWM_1){
9D008098  8FC20008   LW V0, 8(S8)
9D00809C  1440002C   BNE V0, ZERO, 0x9D008150
9D0080A0  00000000   NOP
28:                          // init OC1 module in PWM mode clocked by timer 2
29:                          OC1RS = 0;
9D0080A4  3C02BF80   LUI V0, -16512
9D0080A8  AC403020   SW ZERO, 12320(V0)
30:                          OC1R = 0;
9D0080AC  3C02BF80   LUI V0, -16512
9D0080B0  AC403010   SW ZERO, 12304(V0)
31:                          OC1CONbits.OCTSEL = PWM_TIMER2_SRC;
9D0080B4  3C03BF80   LUI V1, -16512
9D0080B8  94623000   LHU V0, 12288(V1)
9D0080BC  7C0218C4   INS V0, ZERO, 3, 1
9D0080C0  A4623000   SH V0, 12288(V1)
32:                          OC1CONbits.OCM = PWM_PWM_FAULT_PIN_DISABLE;
9D0080C4  3C03BF80   LUI V1, -16512
9D0080C8  94623000   LHU V0, 12288(V1)
9D0080CC  24040006   ADDIU A0, ZERO, 6
9D0080D0  7C821004   INS V0, A0, 0, 3
9D0080D4  A4623000   SH V0, 12288(V1)
33:                          OC1CONbits.ON = PWM_ON;
9D0080D8  3C03BF80   LUI V1, -16512
9D0080DC  94623000   LHU V0, 12288(V1)
9D0080E0  24040001   ADDIU A0, ZERO, 1
9D0080E4  7C827BC4   INS V0, A0, 15, 1
9D0080E8  A4623000   SH V0, 12288(V1)
34:                  
35:                      }else{
36:                          return ERROR;
9D008150  24020001   ADDIU V0, ZERO, 1
37:                      }
38:                  
39:                      // Configure Timer associated with Output Compare module
40:                      // Disable Timer
41:                      T2CONbits.ON = TIMER_OFF;
9D0080EC  3C03BF80   LUI V1, -16512
9D0080F0  94620800   LHU V0, 2048(V1)
9D0080F4  7C027BC4   INS V0, ZERO, 15, 1
9D0080F8  A4620800   SH V0, 2048(V1)
42:                  
43:                      // Set prescaler to 1:1
44:                      T2CONbits.TCKPS = TIMER_PS_1_1;
9D0080FC  3C03BF80   LUI V1, -16512
9D008100  94620800   LHU V0, 2048(V1)
9D008104  7C023104   INS V0, ZERO, 4, 3
9D008108  A4620800   SH V0, 2048(V1)
45:                  
46:                      // Use internal clock source (pbclk)
47:                      T2CONbits.TCS = TIMER_SOURCE_INT;
9D00810C  3C03BF80   LUI V1, -16512
9D008110  94620800   LHU V0, 2048(V1)
9D008114  7C020844   INS V0, ZERO, 1, 1
9D008118  A4620800   SH V0, 2048(V1)
48:                  
49:                      // reset counter
50:                      TMR2 = 0;
9D00811C  3C02BF80   LUI V0, -16512
9D008120  AC400810   SW ZERO, 2064(V0)
51:                  
52:                      // set timer period
53:                      PR2 = period;
9D008124  3C02BF80   LUI V0, -16512
9D008128  8FC3000C   LW V1, 12(S8)
9D00812C  AC430820   SW V1, 2080(V0)
54:                  
55:                      // Enable timer
56:                      T2CONbits.ON = TIMER_ON;
9D008130  3C03BF80   LUI V1, -16512
9D008134  94620800   LHU V0, 2048(V1)
9D008138  24040001   ADDIU A0, ZERO, 1
9D00813C  7C827BC4   INS V0, A0, 15, 1
9D008140  A4620800   SH V0, 2048(V1)
57:                  
58:                      return SUCCESS;
9D008144  00001021   ADDU V0, ZERO, ZERO
9D008148  0B402055   J 0x9D008154
9D00814C  00000000   NOP
59:                  }
9D008154  03C0E821   ADDU SP, S8, ZERO
9D008158  8FBE0004   LW S8, 4(SP)
9D00815C  27BD0008   ADDIU SP, SP, 8
9D008160  03E00008   JR RA
9D008164  00000000   NOP
60:                  
61:                  
62:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
63:                  //------------------------- Set PWM Duty Cycle --------------------------------
64:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
65:                  RESULT pwm_set_duty_cycle(PWM_MODULE module, u32 duty)
66:                  {
9D008168  27BDFFF8   ADDIU SP, SP, -8
9D00816C  AFBE0004   SW S8, 4(SP)
9D008170  03A0F021   ADDU S8, SP, ZERO
9D008174  AFC40008   SW A0, 8(S8)
9D008178  AFC5000C   SW A1, 12(S8)
67:                  #ifdef _OCMP1
68:                      if       (module == PWM_1){
9D00817C  8FC20008   LW V0, 8(S8)
9D008180  14400006   BNE V0, ZERO, 0x9D00819C
9D008184  00000000   NOP
69:                          OC1RS = duty;
9D008188  3C02BF80   LUI V0, -16512
9D00818C  8FC3000C   LW V1, 12(S8)
9D008190  AC433020   SW V1, 12320(V0)
9D008194  0B40208E   J 0x9D008238
9D008198  00000000   NOP
70:                  #endif
71:                  #ifdef _OCMP2
72:                      }else if (module == PWM_2){
9D00819C  8FC30008   LW V1, 8(S8)
9D0081A0  24020001   ADDIU V0, ZERO, 1
9D0081A4  14620006   BNE V1, V0, 0x9D0081C0
9D0081A8  00000000   NOP
73:                          OC2RS = duty;
9D0081AC  3C02BF80   LUI V0, -16512
9D0081B0  8FC3000C   LW V1, 12(S8)
9D0081B4  AC433220   SW V1, 12832(V0)
9D0081B8  0B40208E   J 0x9D008238
9D0081BC  00000000   NOP
74:                  #endif
75:                  #ifdef _OCMP3
76:                      }else if (module == PWM_3){
9D0081C0  8FC30008   LW V1, 8(S8)
9D0081C4  24020002   ADDIU V0, ZERO, 2
9D0081C8  14620006   BNE V1, V0, 0x9D0081E4
9D0081CC  00000000   NOP
77:                          OC3RS = duty;
9D0081D0  3C02BF80   LUI V0, -16512
9D0081D4  8FC3000C   LW V1, 12(S8)
9D0081D8  AC433420   SW V1, 13344(V0)
9D0081DC  0B40208E   J 0x9D008238
9D0081E0  00000000   NOP
78:                  #endif
79:                  #ifdef _OCMP4
80:                      }else if (module == PWM_4){
9D0081E4  8FC30008   LW V1, 8(S8)
9D0081E8  24020003   ADDIU V0, ZERO, 3
9D0081EC  14620006   BNE V1, V0, 0x9D008208
9D0081F0  00000000   NOP
81:                          OC4RS = duty;
9D0081F4  3C02BF80   LUI V0, -16512
9D0081F8  8FC3000C   LW V1, 12(S8)
9D0081FC  AC433620   SW V1, 13856(V0)
9D008200  0B40208E   J 0x9D008238
9D008204  00000000   NOP
82:                  #endif
83:                  #ifdef _OCMP5
84:                      }else if (module == PWM_5){
9D008208  8FC30008   LW V1, 8(S8)
9D00820C  24020004   ADDIU V0, ZERO, 4
9D008210  14620006   BNE V1, V0, 0x9D00822C
9D008214  00000000   NOP
85:                          OC5RS = duty;
9D008218  3C02BF80   LUI V0, -16512
9D00821C  8FC3000C   LW V1, 12(S8)
9D008220  AC433820   SW V1, 14368(V0)
9D008224  0B40208E   J 0x9D008238
9D008228  00000000   NOP
86:                  #endif
87:                      }else{
88:                          return ERROR;
9D00822C  24020001   ADDIU V0, ZERO, 1
9D008230  0B40208F   J 0x9D00823C
9D008234  00000000   NOP
89:                      }
90:                  
91:                      return SUCCESS;
9D008238  00001021   ADDU V0, ZERO, ZERO
92:                  }
9D00823C  03C0E821   ADDU SP, S8, ZERO
9D008240  8FBE0004   LW S8, 4(SP)
9D008244  27BD0008   ADDIU SP, SP, 8
9D008248  03E00008   JR RA
9D00824C  00000000   NOP
9D008250  27BDFFE8   ADDIU SP, SP, -24
9D008254  AFBF0014   SW RA, 20(SP)
9D008258  AFBE0010   SW S8, 16(SP)
9D00825C  03A0F021   ADDU S8, SP, ZERO
93:                  
94:                  
---  d:/svn/mgw-ace-enc/trunk/pic32/power_management.c  -------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   06 June 2014                                        &&&
6:                   //&&&   Description :   Manages all power supplies                          &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   
9:                   #include "power_management.h"
10:                  #include "delays.h"
11:                  #include "common.h"
12:                  #include "io_control.h"
13:                  
14:                  #define TIMEOUT_LIMIT   500    // in milli seconds
15:                  
16:                  extern CONTEXT g;
17:                  
18:                  
19:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
20:                  //------------------------- Power Supplies Management -------------------------
21:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
22:                  RESULT power_supplies_management()
23:                  {
9D004B00  27BDFFE0   ADDIU SP, SP, -32
24:                      u16 timeout;
25:                  
26:                  #if defined (_PCB1_)
27:                      PIN_PWR_EN_5V = 1;
28:                      delay_ms(100);
29:                      PIN_PWR_EN_1V2 = 1;
30:                      delay_ms(100);
31:                      PIN_PWR_EN_1V05 = 1;
32:                      delay_ms(100);
33:                      PIN_PWR_EN_1V8 = 1;
34:                      delay_ms(100);
35:                      PIN_PWR_EN_1V5 = 1;
36:                      delay_ms(100);
37:                      PIN_PWR_EN_3V3 = 1;
38:                      delay_ms(100);
39:                      PIN_PWR_EN_1V35 = 1;
40:                      delay_ms(100);
41:                      PIN_PWR_EN_1V = 1;
42:                      delay_ms(100);
43:                      PIN_PWR_EN_ARRIA_1 = 1;
44:                      
45:                      return SUCCESS;
46:                  
47:                  #elif defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
48:                  
49:                      /*============= 5V =============*/
50:                      PIN_PWR_EN_5V = 1;
51:                      do{
52:                          delay_ms(1);
53:                          if (timeout++ >= TIMEOUT_LIMIT)
54:                              return ERROR;
55:                      }while(PIN_PWR_GD_5V == 0);
56:                  
57:                      /*============ ARRIA ===========*/
58:                      PIN_PWR_EN_ARRIA_1 = 1;
59:                      delay_ms (2);
60:                      PIN_PWR_EN_ARRIA_2 = 1;
61:                      delay_ms (1);
62:                      PIN_PWR_EN_ARRIA_3 = 1;
63:                      delay_ms (10);
64:                  
65:                      /*============= 1V2 ============*/
66:                      PIN_PWR_EN_1V2 = 1;
67:                      timeout = 0;
68:                      do{
69:                          delay_ms(1);
70:                          if (timeout++ >= TIMEOUT_LIMIT)
71:                              return ERROR;
72:                      }while(PIN_PWR_GD_1V2 == 0);
73:                  
74:                      /*============ 1V05 ============*/
75:                      PIN_PWR_EN_1V05 = 1;
76:                      timeout = 0;
77:                      do{
78:                          delay_ms(1);
79:                          if (timeout++ >= TIMEOUT_LIMIT)
80:                              return ERROR;
81:                      }while(PIN_PWR_GD_1V05 == 0);
82:                  
83:                      /*============= 1V8 ============*/
84:                      PIN_PWR_EN_1V8 = 1;
85:                      timeout = 0;
86:                      do{
87:                          delay_ms(1);
88:                          if (timeout++ >= TIMEOUT_LIMIT)
89:                              return ERROR;
90:                      }while(PIN_PWR_GD_1V8 == 0);
91:                  
92:                      /*============= 1V5 ============*/
93:                      PIN_PWR_EN_1V5 = 1;
94:                      timeout = 0;
95:                      do{
96:                          delay_ms(1);
97:                          if (timeout++ >= TIMEOUT_LIMIT)
98:                              return ERROR;
99:                      }while(PIN_PWR_GD_1V5 == 0);
100:                 
101:                     /*============= 3V3 ============*/
102:                     PIN_PWR_EN_3V3 = 1;
103:                     timeout = 0;
104:                     do{
105:                         delay_ms(1);
106:                         if (timeout++ >= TIMEOUT_LIMIT)
107:                             return ERROR;
108:                     }while(PIN_PWR_GD_3V3 == 0);
109:                 
110:                     /*============= 1V35 ===========*/
111:                     PIN_PWR_EN_1V35 = 1;
112:                     timeout = 0;
113:                     do{
114:                         delay_ms(1);
115:                         if (timeout++ >= TIMEOUT_LIMIT)
116:                             return ERROR;
117:                     }while(PIN_PWR_GD_1V35 == 0);
118:                 
119:                     /*============= 1V =============*/
120:                     PIN_PWR_EN_1V = 1;
121:                     timeout = 0;
122:                     do{
123:                         delay_ms(1);
124:                         if (timeout++ >= TIMEOUT_LIMIT)
125:                             return ERROR;
126:                     }while(PIN_PWR_GD_1V == 0);
127:                 
128:                 #elif defined (_PCB5_)
129:                 
130:                     PIN_SOC_RSTN = 1;
9D004B10  3C03BF88   LUI V1, -16504
9D004B14  94626020   LHU V0, 24608(V1)
9D004B18  24040001   ADDIU A0, ZERO, 1
9D004B1C  7C824A44   INS V0, A0, 9, 1
9D004B20  A4626020   SH V0, 24608(V1)
131:                 
132:                     //============= FAN =============
133:                     PIN_PWR_EN_FAN = 1;
9D004B24  3C03BF88   LUI V1, -16504
9D004B28  94626160   LHU V0, 24928(V1)
9D004B2C  24040001   ADDIU A0, ZERO, 1
9D004B30  7C820004   INS V0, A0, 0, 1
9D004B34  A4626160   SH V0, 24928(V1)
134:                     timeout = 0;
9D004B38  A7C00010   SH ZERO, 16(S8)
135:                     do{
136:                         delay_ms(1);
9D004B3C  24040001   ADDIU A0, ZERO, 1
9D004B40  0F40218B   JAL delay_ms
9D004B44  00000000   NOP
137:                         if (timeout >= TIMEOUT_LIMIT){
9D004B48  97C20010   LHU V0, 16(S8)
9D004B4C  2C4201F4   SLTIU V0, V0, 500
9D004B50  14400007   BNE V0, ZERO, 0x9D004B70
9D004B54  00000000   NOP
138:                             timeout++;
9D004B58  97C20010   LHU V0, 16(S8)
9D004B5C  24420001   ADDIU V0, V0, 1
9D004B60  A7C20010   SH V0, 16(S8)
139:                             return ERROR;
9D004B64  24020001   ADDIU V0, ZERO, 1
9D004B68  0B4013EC   J 0x9D004FB0
9D004B6C  00000000   NOP
140:                         }
141:                     }while(PIN_PWR_GD_FAN == 0);
9D004B70  3C02BF88   LUI V0, -16504
9D004B74  8C426190   LW V0, 24976(V0)
9D004B78  30420002   ANDI V0, V0, 2
9D004B7C  1040FFEF   BEQ V0, ZERO, 0x9D004B3C
9D004B80  00000000   NOP
142:                 
143:                     //============= 12V =============
144:                     PIN_PWR_EN_12V = 1;
9D004B84  3C03BF88   LUI V1, -16504
9D004B88  94626160   LHU V0, 24928(V1)
9D004B8C  24040001   ADDIU A0, ZERO, 1
9D004B90  7C820844   INS V0, A0, 1, 1
9D004B94  A4626160   SH V0, 24928(V1)
145:                     timeout = 0;
9D004B98  A7C00010   SH ZERO, 16(S8)
146:                     do{
147:                         delay_ms(1);
9D004B9C  24040001   ADDIU A0, ZERO, 1
9D004BA0  0F40218B   JAL delay_ms
9D004BA4  00000000   NOP
148:                         if (timeout >= TIMEOUT_LIMIT){
9D004BA8  97C20010   LHU V0, 16(S8)
9D004BAC  2C4201F4   SLTIU V0, V0, 500
9D004BB0  14400007   BNE V0, ZERO, 0x9D004BD0
9D004BB4  00000000   NOP
149:                             timeout++;
9D004BB8  97C20010   LHU V0, 16(S8)
9D004BBC  24420001   ADDIU V0, V0, 1
9D004BC0  A7C20010   SH V0, 16(S8)
150:                             return ERROR;
9D004BC4  24020001   ADDIU V0, ZERO, 1
9D004BC8  0B4013EC   J 0x9D004FB0
9D004BCC  00000000   NOP
151:                         }
152:                     }while(PIN_PWR_GD_12V == 0);
9D004BD0  3C02BF88   LUI V0, -16504
9D004BD4  8C426190   LW V0, 24976(V0)
9D004BD8  30420001   ANDI V0, V0, 1
9D004BDC  1040FFEF   BEQ V0, ZERO, 0x9D004B9C
9D004BE0  00000000   NOP
153:                 
154:                     //============= 5V =============
155:                     PIN_PWR_EN_5V = 1;
9D004BE4  3C03BF88   LUI V1, -16504
9D004BE8  94626020   LHU V0, 24608(V1)
9D004BEC  24040001   ADDIU A0, ZERO, 1
9D004BF0  7C8239C4   INS V0, A0, 7, 1
9D004BF4  A4626020   SH V0, 24608(V1)
156:                     timeout = 0;
9D004BF8  A7C00010   SH ZERO, 16(S8)
157:                     do{
158:                         delay_ms(1);
9D004BFC  24040001   ADDIU A0, ZERO, 1
9D004C00  0F40218B   JAL delay_ms
9D004C04  00000000   NOP
159:                         if (timeout >= TIMEOUT_LIMIT){
9D004C08  97C20010   LHU V0, 16(S8)
9D004C0C  2C4201F4   SLTIU V0, V0, 500
9D004C10  14400007   BNE V0, ZERO, 0x9D004C30
9D004C14  00000000   NOP
160:                             timeout++;
9D004C18  97C20010   LHU V0, 16(S8)
9D004C1C  24420001   ADDIU V0, V0, 1
9D004C20  A7C20010   SH V0, 16(S8)
161:                             return ERROR;
9D004C24  24020001   ADDIU V0, ZERO, 1
9D004C28  0B4013EC   J 0x9D004FB0
9D004C2C  00000000   NOP
162:                         }
163:                     }while(PIN_PWR_GD_5V == 0);
9D004C30  3C02BF88   LUI V0, -16504
9D004C34  8C426110   LW V0, 24848(V0)
9D004C38  30420010   ANDI V0, V0, 16
9D004C3C  1040FFEF   BEQ V0, ZERO, 0x9D004BFC
9D004C40  00000000   NOP
164:                 
165:                     //============= 0V9 =============
166:                     PIN_PWR_EN_0V9_IO = 1;
9D004C44  3C03BF88   LUI V1, -16504
9D004C48  946260E0   LHU V0, 24800(V1)
9D004C4C  24040001   ADDIU A0, ZERO, 1
9D004C50  7C822104   INS V0, A0, 4, 1
9D004C54  A46260E0   SH V0, 24800(V1)
167:                     timeout = 0;
9D004C58  A7C00010   SH ZERO, 16(S8)
168:                     do{
169:                         delay_ms(1);
9D004C5C  24040001   ADDIU A0, ZERO, 1
9D004C60  0F40218B   JAL delay_ms
9D004C64  00000000   NOP
170:                         if (timeout >= TIMEOUT_LIMIT){
9D004C68  97C20010   LHU V0, 16(S8)
9D004C6C  2C4201F4   SLTIU V0, V0, 500
9D004C70  14400007   BNE V0, ZERO, 0x9D004C90
9D004C74  00000000   NOP
171:                             timeout++;
9D004C78  97C20010   LHU V0, 16(S8)
9D004C7C  24420001   ADDIU V0, V0, 1
9D004C80  A7C20010   SH V0, 16(S8)
172:                             return ERROR;
9D004C84  24020001   ADDIU V0, ZERO, 1
9D004C88  0B4013EC   J 0x9D004FB0
9D004C8C  00000000   NOP
173:                         }
174:                     }while(PIN_PWR_GD_0V9_IO == 0);
9D004C90  3C02BF88   LUI V0, -16504
9D004C94  8C4260D0   LW V0, 24784(V0)
9D004C98  30420800   ANDI V0, V0, 2048
9D004C9C  1040FFEF   BEQ V0, ZERO, 0x9D004C5C
9D004CA0  00000000   NOP
175:                 
176:                     PIN_PWR_EN_0V9_ENC = 1;
9D004CA4  3C03BF88   LUI V1, -16504
9D004CA8  946260E0   LHU V0, 24800(V1)
9D004CAC  24040001   ADDIU A0, ZERO, 1
9D004CB0  7C822944   INS V0, A0, 5, 1
9D004CB4  A46260E0   SH V0, 24800(V1)
177:                     timeout = 0;
9D004CB8  A7C00010   SH ZERO, 16(S8)
178:                     do{
179:                         delay_ms(1);
9D004CBC  24040001   ADDIU A0, ZERO, 1
9D004CC0  0F40218B   JAL delay_ms
9D004CC4  00000000   NOP
180:                         if (timeout >= TIMEOUT_LIMIT){
9D004CC8  97C20010   LHU V0, 16(S8)
9D004CCC  2C4201F4   SLTIU V0, V0, 500
9D004CD0  14400007   BNE V0, ZERO, 0x9D004CF0
9D004CD4  00000000   NOP
181:                             timeout++;
9D004CD8  97C20010   LHU V0, 16(S8)
9D004CDC  24420001   ADDIU V0, V0, 1
9D004CE0  A7C20010   SH V0, 16(S8)
182:                             return ERROR;
9D004CE4  24020001   ADDIU V0, ZERO, 1
9D004CE8  0B4013EC   J 0x9D004FB0
9D004CEC  00000000   NOP
183:                         }
184:                     }while(PIN_PWR_GD_0V9_ENC == 0);
9D004CF0  3C02BF88   LUI V0, -16504
9D004CF4  8C4260D0   LW V0, 24784(V0)
9D004CF8  30420400   ANDI V0, V0, 1024
9D004CFC  1040FFEF   BEQ V0, ZERO, 0x9D004CBC
9D004D00  00000000   NOP
185:                 
186:                     //============= 1V8 =============
187:                     PIN_PWR_EN_1V8 = 1;
9D004D04  3C03BF88   LUI V1, -16504
9D004D08  946260E0   LHU V0, 24800(V1)
9D004D0C  24040001   ADDIU A0, ZERO, 1
9D004D10  7C826B44   INS V0, A0, 13, 1
9D004D14  A46260E0   SH V0, 24800(V1)
188:                     timeout = 0;
9D004D18  A7C00010   SH ZERO, 16(S8)
189:                     do{
190:                         delay_ms(1);
9D004D1C  24040001   ADDIU A0, ZERO, 1
9D004D20  0F40218B   JAL delay_ms
9D004D24  00000000   NOP
191:                         if (timeout >= TIMEOUT_LIMIT){
9D004D28  97C20010   LHU V0, 16(S8)
9D004D2C  2C4201F4   SLTIU V0, V0, 500
9D004D30  14400007   BNE V0, ZERO, 0x9D004D50
9D004D34  00000000   NOP
192:                             timeout++;
9D004D38  97C20010   LHU V0, 16(S8)
9D004D3C  24420001   ADDIU V0, V0, 1
9D004D40  A7C20010   SH V0, 16(S8)
193:                             return ERROR;
9D004D44  24020001   ADDIU V0, ZERO, 1
9D004D48  0B4013EC   J 0x9D004FB0
9D004D4C  00000000   NOP
194:                         }
195:                     }while(PIN_PWR_GD_1V8 == 0);
9D004D50  3C02BF88   LUI V0, -16504
9D004D54  8C426110   LW V0, 24848(V0)
9D004D58  30420004   ANDI V0, V0, 4
9D004D5C  1040FFEF   BEQ V0, ZERO, 0x9D004D1C
9D004D60  00000000   NOP
196:                 
197:                     //============= 1V5 =============
198:                     PIN_PWR_EN_1V5 = 1;
9D004D64  3C03BF88   LUI V1, -16504
9D004D68  946260E0   LHU V0, 24800(V1)
9D004D6C  24040001   ADDIU A0, ZERO, 1
9D004D70  7C826304   INS V0, A0, 12, 1
9D004D74  A46260E0   SH V0, 24800(V1)
199:                     timeout = 0;
9D004D78  A7C00010   SH ZERO, 16(S8)
200:                     do{
201:                         delay_ms(1);
9D004D7C  24040001   ADDIU A0, ZERO, 1
9D004D80  0F40218B   JAL delay_ms
9D004D84  00000000   NOP
202:                         if (timeout >= TIMEOUT_LIMIT){
9D004D88  97C20010   LHU V0, 16(S8)
9D004D8C  2C4201F4   SLTIU V0, V0, 500
9D004D90  14400007   BNE V0, ZERO, 0x9D004DB0
9D004D94  00000000   NOP
203:                             timeout++;
9D004D98  97C20010   LHU V0, 16(S8)
9D004D9C  24420001   ADDIU V0, V0, 1
9D004DA0  A7C20010   SH V0, 16(S8)
204:                             return ERROR;
9D004DA4  24020001   ADDIU V0, ZERO, 1
9D004DA8  0B4013EC   J 0x9D004FB0
9D004DAC  00000000   NOP
205:                         }
206:                     }while(PIN_PWR_GD_1V5 == 0);
9D004DB0  3C02BF88   LUI V0, -16504
9D004DB4  8C426190   LW V0, 24976(V0)
9D004DB8  30422000   ANDI V0, V0, 8192
9D004DBC  1040FFEF   BEQ V0, ZERO, 0x9D004D7C
9D004DC0  00000000   NOP
207:                 
208:                     //============= 1V05 =============
209:                     PIN_PWR_EN_1V05 = 1;
9D004DC4  3C03BF88   LUI V1, -16504
9D004DC8  946260E0   LHU V0, 24800(V1)
9D004DCC  24040001   ADDIU A0, ZERO, 1
9D004DD0  7C823184   INS V0, A0, 6, 1
9D004DD4  A46260E0   SH V0, 24800(V1)
210:                     timeout = 0;
9D004DD8  A7C00010   SH ZERO, 16(S8)
211:                     do{
212:                         delay_ms(1);
9D004DDC  24040001   ADDIU A0, ZERO, 1
9D004DE0  0F40218B   JAL delay_ms
9D004DE4  00000000   NOP
213:                         if (timeout >= TIMEOUT_LIMIT){
9D004DE8  97C20010   LHU V0, 16(S8)
9D004DEC  2C4201F4   SLTIU V0, V0, 500
9D004DF0  14400007   BNE V0, ZERO, 0x9D004E10
9D004DF4  00000000   NOP
214:                             timeout++;
9D004DF8  97C20010   LHU V0, 16(S8)
9D004DFC  24420001   ADDIU V0, V0, 1
9D004E00  A7C20010   SH V0, 16(S8)
215:                             return ERROR;
9D004E04  24020001   ADDIU V0, ZERO, 1
9D004E08  0B4013EC   J 0x9D004FB0
9D004E0C  00000000   NOP
216:                         }
217:                     }while(PIN_PWR_GD_1V05 == 0);
9D004E10  3C02BF88   LUI V0, -16504
9D004E14  8C426110   LW V0, 24848(V0)
9D004E18  30420002   ANDI V0, V0, 2
9D004E1C  1040FFEF   BEQ V0, ZERO, 0x9D004DDC
9D004E20  00000000   NOP
218:                 
219:                     //============= 0V75 =============
220:                     PIN_PWR_EN_0V75 = 1;        // no power good
9D004E24  3C03BF88   LUI V1, -16504
9D004E28  946260A0   LHU V0, 24736(V1)
9D004E2C  24040001   ADDIU A0, ZERO, 1
9D004E30  7C826B44   INS V0, A0, 13, 1
9D004E34  A46260A0   SH V0, 24736(V1)
221:                     delay_ms(1);
9D004E38  24040001   ADDIU A0, ZERO, 1
9D004E3C  0F40218B   JAL delay_ms
9D004E40  00000000   NOP
222:                 
223:                     //============= 1V0 ==============
224:                     PIN_PWR_EN_1V0 = 1;
9D004E44  3C03BF88   LUI V1, -16504
9D004E48  946260E0   LHU V0, 24800(V1)
9D004E4C  24040001   ADDIU A0, ZERO, 1
9D004E50  7C8239C4   INS V0, A0, 7, 1
9D004E54  A46260E0   SH V0, 24800(V1)
225:                     timeout = 0;
9D004E58  A7C00010   SH ZERO, 16(S8)
226:                     do{
227:                         delay_ms(1);
9D004E5C  24040001   ADDIU A0, ZERO, 1
9D004E60  0F40218B   JAL delay_ms
9D004E64  00000000   NOP
228:                         if (timeout >= TIMEOUT_LIMIT){
9D004E68  97C20010   LHU V0, 16(S8)
9D004E6C  2C4201F4   SLTIU V0, V0, 500
9D004E70  14400007   BNE V0, ZERO, 0x9D004E90
9D004E74  00000000   NOP
229:                             timeout++;
9D004E78  97C20010   LHU V0, 16(S8)
9D004E7C  24420001   ADDIU V0, V0, 1
9D004E80  A7C20010   SH V0, 16(S8)
230:                             return ERROR;
9D004E84  24020001   ADDIU V0, ZERO, 1
9D004E88  0B4013EC   J 0x9D004FB0
9D004E8C  00000000   NOP
231:                         }
232:                     }while(PIN_PWR_GD_1V0 == 0);
9D004E90  3C02BF88   LUI V0, -16504
9D004E94  8C426110   LW V0, 24848(V0)
9D004E98  30420001   ANDI V0, V0, 1
9D004E9C  1040FFEF   BEQ V0, ZERO, 0x9D004E5C
9D004EA0  00000000   NOP
233:                 
234:                     //============= 3V3 ==============
235:                     PIN_PWR_EN_3V3 = 1;
9D004EA4  3C03BF88   LUI V1, -16504
9D004EA8  946260E0   LHU V0, 24800(V1)
9D004EAC  24040001   ADDIU A0, ZERO, 1
9D004EB0  7C8218C4   INS V0, A0, 3, 1
9D004EB4  A46260E0   SH V0, 24800(V1)
236:                     timeout = 0;
9D004EB8  A7C00010   SH ZERO, 16(S8)
237:                     do{
238:                         delay_ms(1);
9D004EBC  24040001   ADDIU A0, ZERO, 1
9D004EC0  0F40218B   JAL delay_ms
9D004EC4  00000000   NOP
239:                         if (timeout >= TIMEOUT_LIMIT){
9D004EC8  97C20010   LHU V0, 16(S8)
9D004ECC  2C4201F4   SLTIU V0, V0, 500
9D004ED0  14400007   BNE V0, ZERO, 0x9D004EF0
9D004ED4  00000000   NOP
240:                             timeout++;
9D004ED8  97C20010   LHU V0, 16(S8)
9D004EDC  24420001   ADDIU V0, V0, 1
9D004EE0  A7C20010   SH V0, 16(S8)
241:                             return ERROR;
9D004EE4  24020001   ADDIU V0, ZERO, 1
9D004EE8  0B4013EC   J 0x9D004FB0
9D004EEC  00000000   NOP
242:                         }
243:                     }while(PIN_PWR_GD_3V3 == 0);
9D004EF0  3C02BF88   LUI V0, -16504
9D004EF4  8C426110   LW V0, 24848(V0)
9D004EF8  30420008   ANDI V0, V0, 8
9D004EFC  1040FFEF   BEQ V0, ZERO, 0x9D004EBC
9D004F00  00000000   NOP
244:                 
245:                     //=========== 1V8_DLY ============
246:                     PIN_PWR_EN_1V8_DLY = 1;        // no power good
9D004F04  3C03BF88   LUI V1, -16504
9D004F08  946260E0   LHU V0, 24800(V1)
9D004F0C  24040001   ADDIU A0, ZERO, 1
9D004F10  7C824204   INS V0, A0, 8, 1
9D004F14  A46260E0   SH V0, 24800(V1)
247:                     delay_ms(1);
9D004F18  24040001   ADDIU A0, ZERO, 1
9D004F1C  0F40218B   JAL delay_ms
9D004F20  00000000   NOP
248:                 
249:                     //============= SoC ==============
250:                     PIN_PWR_EN_0V9_CPU = 1;
9D004F24  3C03BF88   LUI V1, -16504
9D004F28  946260A0   LHU V0, 24736(V1)
9D004F2C  24040001   ADDIU A0, ZERO, 1
9D004F30  7C827384   INS V0, A0, 14, 1
9D004F34  A46260A0   SH V0, 24736(V1)
251:                     PIN_PWR_EN_1V1_CPU = 1;
9D004F38  3C03BF88   LUI V1, -16504
9D004F3C  946260E0   LHU V0, 24800(V1)
9D004F40  24040001   ADDIU A0, ZERO, 1
9D004F44  7C821084   INS V0, A0, 2, 1
9D004F48  A46260E0   SH V0, 24800(V1)
252:                     timeout = 0;
9D004F4C  A7C00010   SH ZERO, 16(S8)
253:                     do{
254:                         delay_ms(1);
9D004F50  24040001   ADDIU A0, ZERO, 1
9D004F54  0F40218B   JAL delay_ms
9D004F58  00000000   NOP
255:                         if (timeout >= TIMEOUT_LIMIT){
9D004F5C  97C20010   LHU V0, 16(S8)
9D004F60  2C4201F4   SLTIU V0, V0, 500
9D004F64  14400007   BNE V0, ZERO, 0x9D004F84
9D004F68  00000000   NOP
256:                             timeout++;
9D004F6C  97C20010   LHU V0, 16(S8)
9D004F70  24420001   ADDIU V0, V0, 1
9D004F74  A7C20010   SH V0, 16(S8)
257:                             return ERROR;
9D004F78  24020001   ADDIU V0, ZERO, 1
9D004F7C  0B4013EC   J 0x9D004FB0
9D004F80  00000000   NOP
258:                         }
259:                     }while((PIN_PWR_GD_1V1_CPU == 0) || (PIN_PWR_GD_0V9_CPU == 0));
9D004F84  3C02BF88   LUI V0, -16504
9D004F88  8C426190   LW V0, 24976(V0)
9D004F8C  30421000   ANDI V0, V0, 4096
9D004F90  1040FFEF   BEQ V0, ZERO, 0x9D004F50
9D004F94  00000000   NOP
9D004F98  3C02BF88   LUI V0, -16504
9D004F9C  8C426190   LW V0, 24976(V0)
9D004FA0  30424000   ANDI V0, V0, 16384
9D004FA4  1040FFEA   BEQ V0, ZERO, 0x9D004F50
9D004FA8  00000000   NOP
260:                 
261:                 #endif
262:                 
263:                     return SUCCESS;
9D004FAC  00001021   ADDU V0, ZERO, ZERO
264:                 }
9D004FB0  03C0E821   ADDU SP, S8, ZERO
9D004FB4  8FBF001C   LW RA, 28(SP)
9D004FB8  8FBE0018   LW S8, 24(SP)
9D004FBC  27BD0020   ADDIU SP, SP, 32
9D004FC0  03E00008   JR RA
9D004FC4  00000000   NOP
265:                 
266:                 
267:                 
268:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
269:                 //------------------------- Power Supplies Management -------------------------
270:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
271:                 RESULT power_supplies_check()
272:                 {
9D004FC8  27BDFFF0   ADDIU SP, SP, -16
9D004FCC  AFBE000C   SW S8, 12(SP)
9D004FD0  03A0F021   ADDU S8, SP, ZERO
273:                     u32 err = 0;
9D004FD4  AFC00000   SW ZERO, 0(S8)
274:                     g.pwr_status = 0;
9D004FD8  3C02A000   LUI V0, -24576
9D004FDC  2442000C   ADDIU V0, V0, 12
9D004FE0  A440007A   SH ZERO, 122(V0)
275:                 
276:                 #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
277:                 
278:                     if (!PIN_PWR_GD_0V9_ARRIA) err++; else g.pwr_status |= 0x0100;
279:                     if (!PIN_PWR_GD_5V)        err++; else g.pwr_status |= 0x0080;
280:                     if (!PIN_PWR_GD_1V2)       err++; else g.pwr_status |= 0x0040;
281:                     if (!PIN_PWR_GD_1V05)      err++; else g.pwr_status |= 0x0020;
282:                     if (!PIN_PWR_GD_1V8)       err++; else g.pwr_status |= 0x0010;
283:                     if (!PIN_PWR_GD_1V5)       err++; else g.pwr_status |= 0x0008;
284:                     if (!PIN_PWR_GD_3V3)       err++; else g.pwr_status |= 0x0004;
285:                     if (!PIN_PWR_GD_1V35)      err++; else g.pwr_status |= 0x0002;
286:                     if (!PIN_PWR_GD_1V)        err++; else g.pwr_status |= 0x0001;
287:                 
288:                 #elif defined (_PCB5_)
289:                 
290:                     if (!PIN_PWR_GD_FAN)        err++; else g.pwr_status |= 0x0800;
9D004FE4  3C02BF88   LUI V0, -16504
9D004FE8  8C426190   LW V0, 24976(V0)
9D004FEC  30420002   ANDI V0, V0, 2
9D004FF0  14400006   BNE V0, ZERO, 0x9D00500C
9D004FF4  00000000   NOP
9D004FF8  8FC20000   LW V0, 0(S8)
9D004FFC  24420001   ADDIU V0, V0, 1
9D005000  AFC20000   SW V0, 0(S8)
9D005004  0B40140B   J 0x9D00502C
9D005008  00000000   NOP
9D00500C  3C02A000   LUI V0, -24576
9D005010  2442000C   ADDIU V0, V0, 12
9D005014  9442007A   LHU V0, 122(V0)
9D005018  34420800   ORI V0, V0, 2048
9D00501C  3043FFFF   ANDI V1, V0, -1
9D005020  3C02A000   LUI V0, -24576
9D005024  2442000C   ADDIU V0, V0, 12
9D005028  A443007A   SH V1, 122(V0)
291:                     if (!PIN_PWR_GD_12V)        err++; else g.pwr_status |= 0x0400;
9D00502C  3C02BF88   LUI V0, -16504
9D005030  8C426190   LW V0, 24976(V0)
9D005034  30420001   ANDI V0, V0, 1
9D005038  14400006   BNE V0, ZERO, 0x9D005054
9D00503C  00000000   NOP
9D005040  8FC20000   LW V0, 0(S8)
9D005044  24420001   ADDIU V0, V0, 1
9D005048  AFC20000   SW V0, 0(S8)
9D00504C  0B40141D   J 0x9D005074
9D005050  00000000   NOP
9D005054  3C02A000   LUI V0, -24576
9D005058  2442000C   ADDIU V0, V0, 12
9D00505C  9442007A   LHU V0, 122(V0)
9D005060  34420400   ORI V0, V0, 1024
9D005064  3043FFFF   ANDI V1, V0, -1
9D005068  3C02A000   LUI V0, -24576
9D00506C  2442000C   ADDIU V0, V0, 12
9D005070  A443007A   SH V1, 122(V0)
292:                     if (!PIN_PWR_GD_5V)         err++; else g.pwr_status |= 0x0200;
9D005074  3C02BF88   LUI V0, -16504
9D005078  8C426110   LW V0, 24848(V0)
9D00507C  30420010   ANDI V0, V0, 16
9D005080  14400006   BNE V0, ZERO, 0x9D00509C
9D005084  00000000   NOP
9D005088  8FC20000   LW V0, 0(S8)
9D00508C  24420001   ADDIU V0, V0, 1
9D005090  AFC20000   SW V0, 0(S8)
9D005094  0B40142F   J 0x9D0050BC
9D005098  00000000   NOP
9D00509C  3C02A000   LUI V0, -24576
9D0050A0  2442000C   ADDIU V0, V0, 12
9D0050A4  9442007A   LHU V0, 122(V0)
9D0050A8  34420200   ORI V0, V0, 512
9D0050AC  3043FFFF   ANDI V1, V0, -1
9D0050B0  3C02A000   LUI V0, -24576
9D0050B4  2442000C   ADDIU V0, V0, 12
9D0050B8  A443007A   SH V1, 122(V0)
293:                     if (!PIN_PWR_GD_3V3)        err++; else g.pwr_status |= 0x0100;
9D0050BC  3C02BF88   LUI V0, -16504
9D0050C0  8C426110   LW V0, 24848(V0)
9D0050C4  30420008   ANDI V0, V0, 8
9D0050C8  14400006   BNE V0, ZERO, 0x9D0050E4
9D0050CC  00000000   NOP
9D0050D0  8FC20000   LW V0, 0(S8)
9D0050D4  24420001   ADDIU V0, V0, 1
9D0050D8  AFC20000   SW V0, 0(S8)
9D0050DC  0B401441   J 0x9D005104
9D0050E0  00000000   NOP
9D0050E4  3C02A000   LUI V0, -24576
9D0050E8  2442000C   ADDIU V0, V0, 12
9D0050EC  9442007A   LHU V0, 122(V0)
9D0050F0  34420100   ORI V0, V0, 256
9D0050F4  3043FFFF   ANDI V1, V0, -1
9D0050F8  3C02A000   LUI V0, -24576
9D0050FC  2442000C   ADDIU V0, V0, 12
9D005100  A443007A   SH V1, 122(V0)
294:                     if (!PIN_PWR_GD_1V8)        err++; else g.pwr_status |= 0x0080;
9D005104  3C02BF88   LUI V0, -16504
9D005108  8C426110   LW V0, 24848(V0)
9D00510C  30420004   ANDI V0, V0, 4
9D005110  14400006   BNE V0, ZERO, 0x9D00512C
9D005114  00000000   NOP
9D005118  8FC20000   LW V0, 0(S8)
9D00511C  24420001   ADDIU V0, V0, 1
9D005120  AFC20000   SW V0, 0(S8)
9D005124  0B401453   J 0x9D00514C
9D005128  00000000   NOP
9D00512C  3C02A000   LUI V0, -24576
9D005130  2442000C   ADDIU V0, V0, 12
9D005134  9442007A   LHU V0, 122(V0)
9D005138  34420080   ORI V0, V0, 128
9D00513C  3043FFFF   ANDI V1, V0, -1
9D005140  3C02A000   LUI V0, -24576
9D005144  2442000C   ADDIU V0, V0, 12
9D005148  A443007A   SH V1, 122(V0)
295:                     if (!PIN_PWR_GD_1V5)        err++; else g.pwr_status |= 0x0040;
9D00514C  3C02BF88   LUI V0, -16504
9D005150  8C426190   LW V0, 24976(V0)
9D005154  30422000   ANDI V0, V0, 8192
9D005158  14400006   BNE V0, ZERO, 0x9D005174
9D00515C  00000000   NOP
9D005160  8FC20000   LW V0, 0(S8)
9D005164  24420001   ADDIU V0, V0, 1
9D005168  AFC20000   SW V0, 0(S8)
9D00516C  0B401465   J 0x9D005194
9D005170  00000000   NOP
9D005174  3C02A000   LUI V0, -24576
9D005178  2442000C   ADDIU V0, V0, 12
9D00517C  9442007A   LHU V0, 122(V0)
9D005180  34420040   ORI V0, V0, 64
9D005184  3043FFFF   ANDI V1, V0, -1
9D005188  3C02A000   LUI V0, -24576
9D00518C  2442000C   ADDIU V0, V0, 12
9D005190  A443007A   SH V1, 122(V0)
296:                     if (!PIN_PWR_GD_1V1_CPU)    err++; else g.pwr_status |= 0x0020;
9D005194  3C02BF88   LUI V0, -16504
9D005198  8C426190   LW V0, 24976(V0)
9D00519C  30421000   ANDI V0, V0, 4096
9D0051A0  14400006   BNE V0, ZERO, 0x9D0051BC
9D0051A4  00000000   NOP
9D0051A8  8FC20000   LW V0, 0(S8)
9D0051AC  24420001   ADDIU V0, V0, 1
9D0051B0  AFC20000   SW V0, 0(S8)
9D0051B4  0B401477   J 0x9D0051DC
9D0051B8  00000000   NOP
9D0051BC  3C02A000   LUI V0, -24576
9D0051C0  2442000C   ADDIU V0, V0, 12
9D0051C4  9442007A   LHU V0, 122(V0)
9D0051C8  34420020   ORI V0, V0, 32
9D0051CC  3043FFFF   ANDI V1, V0, -1
9D0051D0  3C02A000   LUI V0, -24576
9D0051D4  2442000C   ADDIU V0, V0, 12
9D0051D8  A443007A   SH V1, 122(V0)
297:                     if (!PIN_PWR_GD_1V05)       err++; else g.pwr_status |= 0x0010;
9D0051DC  3C02BF88   LUI V0, -16504
9D0051E0  8C426110   LW V0, 24848(V0)
9D0051E4  30420002   ANDI V0, V0, 2
9D0051E8  14400006   BNE V0, ZERO, 0x9D005204
9D0051EC  00000000   NOP
9D0051F0  8FC20000   LW V0, 0(S8)
9D0051F4  24420001   ADDIU V0, V0, 1
9D0051F8  AFC20000   SW V0, 0(S8)
9D0051FC  0B401489   J 0x9D005224
9D005200  00000000   NOP
9D005204  3C02A000   LUI V0, -24576
9D005208  2442000C   ADDIU V0, V0, 12
9D00520C  9442007A   LHU V0, 122(V0)
9D005210  34420010   ORI V0, V0, 16
9D005214  3043FFFF   ANDI V1, V0, -1
9D005218  3C02A000   LUI V0, -24576
9D00521C  2442000C   ADDIU V0, V0, 12
9D005220  A443007A   SH V1, 122(V0)
298:                     if (!PIN_PWR_GD_1V0)        err++; else g.pwr_status |= 0x0008;
9D005224  3C02BF88   LUI V0, -16504
9D005228  8C426110   LW V0, 24848(V0)
9D00522C  30420001   ANDI V0, V0, 1
9D005230  14400006   BNE V0, ZERO, 0x9D00524C
9D005234  00000000   NOP
9D005238  8FC20000   LW V0, 0(S8)
9D00523C  24420001   ADDIU V0, V0, 1
9D005240  AFC20000   SW V0, 0(S8)
9D005244  0B40149B   J 0x9D00526C
9D005248  00000000   NOP
9D00524C  3C02A000   LUI V0, -24576
9D005250  2442000C   ADDIU V0, V0, 12
9D005254  9442007A   LHU V0, 122(V0)
9D005258  34420008   ORI V0, V0, 8
9D00525C  3043FFFF   ANDI V1, V0, -1
9D005260  3C02A000   LUI V0, -24576
9D005264  2442000C   ADDIU V0, V0, 12
9D005268  A443007A   SH V1, 122(V0)
299:                     if (!PIN_PWR_GD_0V9_IO)     err++; else g.pwr_status |= 0x0004;
9D00526C  3C02BF88   LUI V0, -16504
9D005270  8C4260D0   LW V0, 24784(V0)
9D005274  30420800   ANDI V0, V0, 2048
9D005278  14400006   BNE V0, ZERO, 0x9D005294
9D00527C  00000000   NOP
9D005280  8FC20000   LW V0, 0(S8)
9D005284  24420001   ADDIU V0, V0, 1
9D005288  AFC20000   SW V0, 0(S8)
9D00528C  0B4014AD   J 0x9D0052B4
9D005290  00000000   NOP
9D005294  3C02A000   LUI V0, -24576
9D005298  2442000C   ADDIU V0, V0, 12
9D00529C  9442007A   LHU V0, 122(V0)
9D0052A0  34420004   ORI V0, V0, 4
9D0052A4  3043FFFF   ANDI V1, V0, -1
9D0052A8  3C02A000   LUI V0, -24576
9D0052AC  2442000C   ADDIU V0, V0, 12
9D0052B0  A443007A   SH V1, 122(V0)
300:                     if (!PIN_PWR_GD_0V9_ENC)    err++; else g.pwr_status |= 0x0002;
9D0052B4  3C02BF88   LUI V0, -16504
9D0052B8  8C4260D0   LW V0, 24784(V0)
9D0052BC  30420400   ANDI V0, V0, 1024
9D0052C0  14400006   BNE V0, ZERO, 0x9D0052DC
9D0052C4  00000000   NOP
9D0052C8  8FC20000   LW V0, 0(S8)
9D0052CC  24420001   ADDIU V0, V0, 1
9D0052D0  AFC20000   SW V0, 0(S8)
9D0052D4  0B4014BF   J 0x9D0052FC
9D0052D8  00000000   NOP
9D0052DC  3C02A000   LUI V0, -24576
9D0052E0  2442000C   ADDIU V0, V0, 12
9D0052E4  9442007A   LHU V0, 122(V0)
9D0052E8  34420002   ORI V0, V0, 2
9D0052EC  3043FFFF   ANDI V1, V0, -1
9D0052F0  3C02A000   LUI V0, -24576
9D0052F4  2442000C   ADDIU V0, V0, 12
9D0052F8  A443007A   SH V1, 122(V0)
301:                     if (!PIN_PWR_GD_0V9_CPU)    err++; else g.pwr_status |= 0x0001;
9D0052FC  3C02BF88   LUI V0, -16504
9D005300  8C426190   LW V0, 24976(V0)
9D005304  30424000   ANDI V0, V0, 16384
9D005308  14400006   BNE V0, ZERO, 0x9D005324
9D00530C  00000000   NOP
9D005310  8FC20000   LW V0, 0(S8)
9D005314  24420001   ADDIU V0, V0, 1
9D005318  AFC20000   SW V0, 0(S8)
9D00531C  0B4014D1   J 0x9D005344
9D005320  00000000   NOP
9D005324  3C02A000   LUI V0, -24576
9D005328  2442000C   ADDIU V0, V0, 12
9D00532C  9442007A   LHU V0, 122(V0)
9D005330  34420001   ORI V0, V0, 1
9D005334  3043FFFF   ANDI V1, V0, -1
9D005338  3C02A000   LUI V0, -24576
9D00533C  2442000C   ADDIU V0, V0, 12
9D005340  A443007A   SH V1, 122(V0)
302:                 
303:                 #endif
304:                     
305:                     if (err) return ERROR;
9D005344  8FC20000   LW V0, 0(S8)
9D005348  10400004   BEQ V0, ZERO, 0x9D00535C
9D00534C  00000000   NOP
9D005350  24020001   ADDIU V0, ZERO, 1
9D005354  0B4014D8   J 0x9D005360
9D005358  00000000   NOP
306:                     else     return SUCCESS;
9D00535C  00001021   ADDU V0, ZERO, ZERO
307:                 }
9D005360  03C0E821   ADDU SP, S8, ZERO
9D005364  8FBE000C   LW S8, 12(SP)
9D005368  27BD0010   ADDIU SP, SP, 16
9D00536C  03E00008   JR RA
9D005370  00000000   NOP
308:                 
309:                 
310:                 
311:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
312:                 //--------------------------- Power Down Sequence -----------------------------
313:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
314:                 void power_down_sequence()
315:                 {
9D005374  27BDFFE8   ADDIU SP, SP, -24
9D005378  AFBF0014   SW RA, 20(SP)
9D00537C  AFBE0010   SW S8, 16(SP)
9D005380  03A0F021   ADDU S8, SP, ZERO
316:                 #if defined (_PCB1_)
317:                     // reset all chips
318:                     PIN_SOC_RSTN       = 0;
319:                     PIN_CVBS_RSTN      = 0;
320:                     PIN_ANX_HDMI_RSTN  = 0;
321:                     PIN_ANX_DVI_RSTN   = 0;
322:                     PIN_DIR9001_1_RSTN = 0;
323:                     PIN_DIR9001_2_RSTN = 0;
324:                     PIN_VM4400_RSTN    = 0;
325:                     PIN_TLV320_A_RSTN  = 0;
326:                     PIN_TLV320_B_RSTN  = 0;
327:                 
328:                 #elif defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
329:                 
330:                     // reset all chips
331:                     PIN_SOC_RSTN       = 0;
332:                     PIN_CVBS_RSTN      = 0;
333:                     PIN_ANX_HDMI_RSTN  = 0;
334:                     PIN_ANX_DVI_RSTN   = 0;
335:                     PIN_DIR9001_1_RSTN = 0;
336:                     PIN_DIR9001_2_RSTN = 0;
337:                     PIN_TLV320_A_RSTN  = 0;
338:                     PIN_TLV320_B_RSTN  = 0;
339:                 
340:                     // disable arria power supply
341:                     PIN_PWR_EN_ARRIA_3 = 0;
342:                     PIN_PWR_ARRIA_DIS_3 = 1;
343:                     delay_ms(2);
344:                     PIN_PWR_EN_ARRIA_2 = 0;
345:                     PIN_PWR_ARRIA_DIS_2 = 1;
346:                 
347:                 #elif defined (_PCB5_)
348:                     
349:                     // reset all chips
350:                     PIN_SOC_RSTN       = 1;
9D005384  3C03BF88   LUI V1, -16504
9D005388  94626020   LHU V0, 24608(V1)
9D00538C  24040001   ADDIU A0, ZERO, 1
9D005390  7C824A44   INS V0, A0, 9, 1
9D005394  A4626020   SH V0, 24608(V1)
351:                     PIN_CVBS_RSTN      = 0;
9D005398  3C03BF88   LUI V1, -16504
9D00539C  946260E0   LHU V0, 24800(V1)
9D0053A0  7C027BC4   INS V0, ZERO, 15, 1
9D0053A4  A46260E0   SH V0, 24800(V1)
352:                     PIN_ANX_HDMI_RSTN  = 0;
9D0053A8  3C03BF88   LUI V1, -16504
9D0053AC  94626060   LHU V0, 24672(V1)
9D0053B0  7C026B44   INS V0, ZERO, 13, 1
9D0053B4  A4626060   SH V0, 24672(V1)
353:                     PIN_ANX_DVI_RSTN   = 0;
9D0053B8  3C03BF88   LUI V1, -16504
9D0053BC  94626060   LHU V0, 24672(V1)
9D0053C0  7C026304   INS V0, ZERO, 12, 1
9D0053C4  A4626060   SH V0, 24672(V1)
354:                     PIN_DIR9001_1_RSTN = 0;
9D0053C8  3C03BF88   LUI V1, -16504
9D0053CC  94626120   LHU V0, 24864(V1)
9D0053D0  7C024204   INS V0, ZERO, 8, 1
9D0053D4  A4626120   SH V0, 24864(V1)
355:                     PIN_DIR9001_2_RSTN = 0;
9D0053D8  3C03BF88   LUI V1, -16504
9D0053DC  94626120   LHU V0, 24864(V1)
9D0053E0  7C024A44   INS V0, ZERO, 9, 1
9D0053E4  A4626120   SH V0, 24864(V1)
356:                     PIN_TLV320_A_RSTN  = 0;
9D0053E8  3C03BF88   LUI V1, -16504
9D0053EC  94626060   LHU V0, 24672(V1)
9D0053F0  7C027384   INS V0, ZERO, 14, 1
9D0053F4  A4626060   SH V0, 24672(V1)
357:                     PIN_TLV320_B_RSTN  = 0;
9D0053F8  3C03BF88   LUI V1, -16504
9D0053FC  94626060   LHU V0, 24672(V1)
9D005400  7C027BC4   INS V0, ZERO, 15, 1
9D005404  A4626060   SH V0, 24672(V1)
358:                 
359:                     // disable arria power supply
360:                     PIN_PWR_EN_1V5 = 0;
9D005408  3C03BF88   LUI V1, -16504
9D00540C  946260E0   LHU V0, 24800(V1)
9D005410  7C026304   INS V0, ZERO, 12, 1
9D005414  A46260E0   SH V0, 24800(V1)
361:                     PIN_PWR_DIS_1V5 = 1;
9D005418  3C03BF88   LUI V1, -16504
9D00541C  946260A0   LHU V0, 24736(V1)
9D005420  24040001   ADDIU A0, ZERO, 1
9D005424  7C821084   INS V0, A0, 2, 1
9D005428  A46260A0   SH V0, 24736(V1)
362:                     delay_ms(2);
9D00542C  24040002   ADDIU A0, ZERO, 2
9D005430  0F40218B   JAL delay_ms
9D005434  00000000   NOP
363:                     PIN_PWR_EN_1V8 = 0;
9D005438  3C03BF88   LUI V1, -16504
9D00543C  946260E0   LHU V0, 24800(V1)
9D005440  7C026B44   INS V0, ZERO, 13, 1
9D005444  A46260E0   SH V0, 24800(V1)
364:                     PIN_PWR_DIS_1V8 = 1;
9D005448  3C03BF88   LUI V1, -16504
9D00544C  946260A0   LHU V0, 24736(V1)
9D005450  24040001   ADDIU A0, ZERO, 1
9D005454  7C820844   INS V0, A0, 1, 1
9D005458  A46260A0   SH V0, 24736(V1)
365:                     
366:                 #endif
367:                 }
9D00545C  03C0E821   ADDU SP, S8, ZERO
9D005460  8FBF0014   LW RA, 20(SP)
9D005464  8FBE0010   LW S8, 16(SP)
9D005468  27BD0018   ADDIU SP, SP, 24
9D00546C  03E00008   JR RA
9D005470  00000000   NOP
368:                 
369:                 
370:                 
371:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
372:                 //--------------------------- Power down all DC/DC ----------------------------
373:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
374:                 void power_down_dc_dc()
375:                 {
9D005474  27BDFFF8   ADDIU SP, SP, -8
9D005478  AFBE0004   SW S8, 4(SP)
9D00547C  03A0F021   ADDU S8, SP, ZERO
376:                 #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
377:                 
378:                     PIN_PWR_EN_5V       = 0;
379:                     PIN_PWR_EN_3V3      = 0;
380:                     PIN_PWR_EN_1V8      = 0;
381:                     PIN_PWR_EN_1V5      = 0;
382:                     PIN_PWR_EN_1V35     = 0;
383:                     PIN_PWR_EN_1V2      = 0;
384:                     PIN_PWR_EN_1V05     = 0;
385:                     PIN_PWR_EN_1V       = 0;
386:                     PIN_PWR_EN_ARRIA_3  = 0;
387:                     PIN_PWR_EN_ARRIA_2  = 0;
388:                     PIN_PWR_EN_ARRIA_1  = 0;
389:                 
390:                 #elif defined (_PCB5_)
391:                 
392:                     PIN_PWR_EN_FAN      = 0;
9D005480  3C03BF88   LUI V1, -16504
9D005484  94626160   LHU V0, 24928(V1)
9D005488  7C020004   INS V0, ZERO, 0, 1
9D00548C  A4626160   SH V0, 24928(V1)
393:                     PIN_PWR_EN_12V      = 0;
9D005490  3C03BF88   LUI V1, -16504
9D005494  94626160   LHU V0, 24928(V1)
9D005498  7C020844   INS V0, ZERO, 1, 1
9D00549C  A4626160   SH V0, 24928(V1)
394:                     PIN_PWR_EN_5V       = 0;
9D0054A0  3C03BF88   LUI V1, -16504
9D0054A4  94626020   LHU V0, 24608(V1)
9D0054A8  7C0239C4   INS V0, ZERO, 7, 1
9D0054AC  A4626020   SH V0, 24608(V1)
395:                     PIN_PWR_EN_3V3      = 0;
9D0054B0  3C03BF88   LUI V1, -16504
9D0054B4  946260E0   LHU V0, 24800(V1)
9D0054B8  7C0218C4   INS V0, ZERO, 3, 1
9D0054BC  A46260E0   SH V0, 24800(V1)
396:                     PIN_PWR_EN_1V8      = 0;
9D0054C0  3C03BF88   LUI V1, -16504
9D0054C4  946260E0   LHU V0, 24800(V1)
9D0054C8  7C026B44   INS V0, ZERO, 13, 1
9D0054CC  A46260E0   SH V0, 24800(V1)
397:                     PIN_PWR_EN_1V8_DLY  = 0;
9D0054D0  3C03BF88   LUI V1, -16504
9D0054D4  946260E0   LHU V0, 24800(V1)
9D0054D8  7C024204   INS V0, ZERO, 8, 1
9D0054DC  A46260E0   SH V0, 24800(V1)
398:                     PIN_PWR_EN_1V5      = 0;
9D0054E0  3C03BF88   LUI V1, -16504
9D0054E4  946260E0   LHU V0, 24800(V1)
9D0054E8  7C026304   INS V0, ZERO, 12, 1
9D0054EC  A46260E0   SH V0, 24800(V1)
399:                     PIN_PWR_EN_1V1_CPU  = 0;
9D0054F0  3C03BF88   LUI V1, -16504
9D0054F4  946260E0   LHU V0, 24800(V1)
9D0054F8  7C021084   INS V0, ZERO, 2, 1
9D0054FC  A46260E0   SH V0, 24800(V1)
400:                     PIN_PWR_EN_1V05     = 0;
9D005500  3C03BF88   LUI V1, -16504
9D005504  946260E0   LHU V0, 24800(V1)
9D005508  7C023184   INS V0, ZERO, 6, 1
9D00550C  A46260E0   SH V0, 24800(V1)
401:                     PIN_PWR_EN_1V0      = 0;
9D005510  3C03BF88   LUI V1, -16504
9D005514  946260E0   LHU V0, 24800(V1)
9D005518  7C0239C4   INS V0, ZERO, 7, 1
9D00551C  A46260E0   SH V0, 24800(V1)
402:                     PIN_PWR_EN_0V9_IO   = 0;
9D005520  3C03BF88   LUI V1, -16504
9D005524  946260E0   LHU V0, 24800(V1)
9D005528  7C022104   INS V0, ZERO, 4, 1
9D00552C  A46260E0   SH V0, 24800(V1)
403:                     PIN_PWR_EN_0V9_ENC  = 0;
9D005530  3C03BF88   LUI V1, -16504
9D005534  946260E0   LHU V0, 24800(V1)
9D005538  7C022944   INS V0, ZERO, 5, 1
9D00553C  A46260E0   SH V0, 24800(V1)
404:                     PIN_PWR_EN_0V9_CPU  = 0;
9D005540  3C03BF88   LUI V1, -16504
9D005544  946260A0   LHU V0, 24736(V1)
9D005548  7C027384   INS V0, ZERO, 14, 1
9D00554C  A46260A0   SH V0, 24736(V1)
405:                     PIN_PWR_EN_0V75     = 0;
9D005550  3C03BF88   LUI V1, -16504
9D005554  946260A0   LHU V0, 24736(V1)
9D005558  7C026B44   INS V0, ZERO, 13, 1
9D00555C  A46260A0   SH V0, 24736(V1)
406:                     
407:                 #endif
408:                 }
9D005560  03C0E821   ADDU SP, S8, ZERO
9D005564  8FBE0004   LW S8, 4(SP)
9D005568  27BD0008   ADDIU SP, SP, 8
9D00556C  03E00008   JR RA
9D005570  00000000   NOP
409:                 
410:                 
411:                 
412:                 void power_up_dc_dc()
413:                 {
9D005574  27BDFFF8   ADDIU SP, SP, -8
9D005578  AFBE0004   SW S8, 4(SP)
9D00557C  03A0F021   ADDU S8, SP, ZERO
414:                 #if defined (_PCB5_)
415:                     PIN_PWR_EN_FAN = 1;
9D005580  3C03BF88   LUI V1, -16504
9D005584  94626160   LHU V0, 24928(V1)
9D005588  24040001   ADDIU A0, ZERO, 1
9D00558C  7C820004   INS V0, A0, 0, 1
9D005590  A4626160   SH V0, 24928(V1)
416:                     PIN_PWR_EN_12V = 1;
9D005594  3C03BF88   LUI V1, -16504
9D005598  94626160   LHU V0, 24928(V1)
9D00559C  24040001   ADDIU A0, ZERO, 1
9D0055A0  7C820844   INS V0, A0, 1, 1
9D0055A4  A4626160   SH V0, 24928(V1)
417:                     PIN_PWR_EN_5V = 1;
9D0055A8  3C03BF88   LUI V1, -16504
9D0055AC  94626020   LHU V0, 24608(V1)
9D0055B0  24040001   ADDIU A0, ZERO, 1
9D0055B4  7C8239C4   INS V0, A0, 7, 1
9D0055B8  A4626020   SH V0, 24608(V1)
418:                     PIN_PWR_EN_0V9_IO = 1;
9D0055BC  3C03BF88   LUI V1, -16504
9D0055C0  946260E0   LHU V0, 24800(V1)
9D0055C4  24040001   ADDIU A0, ZERO, 1
9D0055C8  7C822104   INS V0, A0, 4, 1
9D0055CC  A46260E0   SH V0, 24800(V1)
419:                     PIN_PWR_EN_0V9_ENC = 1;
9D0055D0  3C03BF88   LUI V1, -16504
9D0055D4  946260E0   LHU V0, 24800(V1)
9D0055D8  24040001   ADDIU A0, ZERO, 1
9D0055DC  7C822944   INS V0, A0, 5, 1
9D0055E0  A46260E0   SH V0, 24800(V1)
420:                     PIN_PWR_EN_1V8 = 1;
9D0055E4  3C03BF88   LUI V1, -16504
9D0055E8  946260E0   LHU V0, 24800(V1)
9D0055EC  24040001   ADDIU A0, ZERO, 1
9D0055F0  7C826B44   INS V0, A0, 13, 1
9D0055F4  A46260E0   SH V0, 24800(V1)
421:                     PIN_PWR_EN_1V5 = 1;
9D0055F8  3C03BF88   LUI V1, -16504
9D0055FC  946260E0   LHU V0, 24800(V1)
9D005600  24040001   ADDIU A0, ZERO, 1
9D005604  7C826304   INS V0, A0, 12, 1
9D005608  A46260E0   SH V0, 24800(V1)
422:                     PIN_PWR_EN_1V05 = 1;
9D00560C  3C03BF88   LUI V1, -16504
9D005610  946260E0   LHU V0, 24800(V1)
9D005614  24040001   ADDIU A0, ZERO, 1
9D005618  7C823184   INS V0, A0, 6, 1
9D00561C  A46260E0   SH V0, 24800(V1)
423:                     PIN_PWR_EN_0V75 = 1;
9D005620  3C03BF88   LUI V1, -16504
9D005624  946260A0   LHU V0, 24736(V1)
9D005628  24040001   ADDIU A0, ZERO, 1
9D00562C  7C826B44   INS V0, A0, 13, 1
9D005630  A46260A0   SH V0, 24736(V1)
424:                     PIN_PWR_EN_1V0 = 1;
9D005634  3C03BF88   LUI V1, -16504
9D005638  946260E0   LHU V0, 24800(V1)
9D00563C  24040001   ADDIU A0, ZERO, 1
9D005640  7C8239C4   INS V0, A0, 7, 1
9D005644  A46260E0   SH V0, 24800(V1)
425:                     PIN_PWR_EN_3V3 = 1;
9D005648  3C03BF88   LUI V1, -16504
9D00564C  946260E0   LHU V0, 24800(V1)
9D005650  24040001   ADDIU A0, ZERO, 1
9D005654  7C8218C4   INS V0, A0, 3, 1
9D005658  A46260E0   SH V0, 24800(V1)
426:                     PIN_PWR_EN_1V8_DLY = 1;
9D00565C  3C03BF88   LUI V1, -16504
9D005660  946260E0   LHU V0, 24800(V1)
9D005664  24040001   ADDIU A0, ZERO, 1
9D005668  7C824204   INS V0, A0, 8, 1
9D00566C  A46260E0   SH V0, 24800(V1)
427:                     PIN_PWR_EN_0V9_CPU = 1;
9D005670  3C03BF88   LUI V1, -16504
9D005674  946260A0   LHU V0, 24736(V1)
9D005678  24040001   ADDIU A0, ZERO, 1
9D00567C  7C827384   INS V0, A0, 14, 1
9D005680  A46260A0   SH V0, 24736(V1)
428:                     PIN_PWR_EN_1V1_CPU = 1;
9D005684  3C03BF88   LUI V1, -16504
9D005688  946260E0   LHU V0, 24800(V1)
9D00568C  24040001   ADDIU A0, ZERO, 1
9D005690  7C821084   INS V0, A0, 2, 1
9D005694  A46260E0   SH V0, 24800(V1)
429:                 #endif
430:                 }
9D005698  03C0E821   ADDU SP, S8, ZERO
9D00569C  8FBE0004   LW S8, 4(SP)
9D0056A0  27BD0008   ADDIU SP, SP, 8
9D0056A4  03E00008   JR RA
9D0056A8  00000000   NOP
9D0056AC  27BDFFF0   ADDIU SP, SP, -16
9D0056B0  AFBE000C   SW S8, 12(SP)
9D0056B4  03A0F021   ADDU S8, SP, ZERO
9D0056B8  AFC40010   SW A0, 16(S8)
---  d:/svn/mgw-ace-enc/trunk/pic32/main.c  -------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE-ENC                                         &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   30 June 2015                                        &&&
6:                   //&&&   Version     :   v3.5                                                &&&
7:                   //&&&   File        :   main.c                                              &&&
8:                   //&&&   IDE         :   MPLAB X v3.26                                       &&&
9:                   //&&&   Compiler    :   XC32 v1.40 + PIC32 legacy peripheral libraries      &&&
10:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:                  //&&&   Description :   - Read Temperatures                                 &&&
12:                  //&&&                   - Power Supplies Management                         &&&
13:                  //&&&                   - Fan Management                                    &&&
14:                  //&&&                   - Reset Management                                  &&&
15:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
16:                  //&&&   Infos       :   It uses internal 8MHz RC oscillator                 &&&
17:                  //&&&                   SYS_FREQ = RC / 2 * 20 / 4 = 20 MHz see pic32mx_cfg &&&
18:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
19:                  //&&&   History     :                                                       &&& 
20:                  //&&&   1.0 - PBL - First release                                           &&&
21:                  //&&&   1.1 - PBL - Added ADC and i2c slave                                 &&&
22:                  //&&&               Decrease sys_clk from 80 to 20 MHz                      &&&
23:                  //&&&   1.2 - PBL - Added i2c master interface                              &&&
24:                  //&&&   1.3 - PBL - Handled fan controller                                  &&&
25:                  //&&&               Added interrupts                                        &&&
26:                  //&&&   1.4 - PBL - Added debug counter in every states                     &&&
27:                  //&&&               Added temperature handling                              &&&
28:                  //&&&   1.5 - PBL - Added some registers (debug, led, ps)                   &&&
29:                  //&&&   1.6 - PBL - Added possibility to disable Arria PS                   &&&
30:                  //&&&   1.7 - PBL - Added several speed for the blinking led in function    &&&
31:                  //&&&               of the detected error                                   &&&
32:                  //&&&               Reworked power management                               &&&
33:                  //&&&   1.8 - PBL - Reworked temperature management                         &&&
34:                  //&&&               Added timers interrupts                                 &&&
35:                  //&&&   1.9 - PBL - Removed heat mechanism                                  &&&
36:                  //&&&   1.A - PBL - Improved power management                               &&&
37:                  //&&&   1.B - PBL - Added PWM for the control of the FAN                    &&&
38:                  //&&&   1.C - PBL - Reworked temperature management                         &&&
39:                  //&&&               Added watchdog                                          &&&
40:                  //&&&   1.D - PBL - Added support for PCB3                                  &&&
41:                  //&&&   1.E - PBL - Fixed power down sequencing                             &&&
42:                  //&&&   1.F - PBL - Changed temperature thresholds                          &&&
43:                  //&&&   2.0 - PBL - Added different pattern for the blinking led            &&&
44:                  //&&&   2.1 - PBL - Modified the power sequencing                           &&&
45:                  //&&&   2.2 - PBL - Improved power down sequencing of ARRIA                 &&&
46:                  //&&&   2.3 - PBL - Added temperature from ARRIA                            &&&
47:                  //&&&   2.4 - PBL - Increased default speed of fan                          &&&
48:                  //&&&   2.5 - PBL - Decreased PWM frequency to 5.3kHz                       &&&
49:                  //&&&               Reduced range from 0 to 100                             &&&
50:                  //&&&   2.6 - PBL - Added led_power & interrupt_mgnt files                  &&&
51:                  //&&&               Cleaned code                                            &&&
52:                  //&&&               Removed led patterns                                    &&&
53:                  //&&&               Reworked temperature regulation                         &&&
54:                  //&&&   2.7 - PBL - Increased the minimal speed of the fan                  &&&
55:                  //&&&   2.8 - PBL - Modified the LUT of the Fan                             &&&
56:                  //&&&               Removed some status reading from LM63                   &&&
57:                  //&&&   2.9 - PBL - Adapted the speed of fan to the new HEVC                &&&
58:                  //&&&               -> Changed LUT & min speed                              &&&
59:                  //&&&   2.A - PBL - Decreased the time between two reading of temperature   &&&
60:                  //&&&               Reworked I2C_idle                                       &&&
61:                  //&&&   2.B - PBL - Increased HDMI & DVI reset to 200 ms (HDCP)             &&&
62:                  //&&&   3.0 - PBL - I2C driver now handles 5 buses                          &&&
63:                  //&&&               Added support for PCB 5                                 &&&
64:                  //&&&   3.1 - PBL - Skipped power supplies init after an update             &&&
65:                  //&&&   3.2 - PBL - Fixed i2c errors after an update                        &&&
66:                  //&&&   3.3 - PBL - Added temperature measurement from 2nd LM63             &&&
67:                  //&&&               Fixed some syntax warnings                              &&&
68:                  //&&&               Added workaround if i2c access fails                    &&&
69:                  //&&&   3.4 - PBL - Added workaround if LM63 access fails                   &&&
70:                  //&&&   3.5 - PBL - Rebuilt Timer, adc & PWM libraries                      &&&
71:                  //&&&               Increased PWM frequency to 20kHz                        &&&
72:                  //&&&               Removed uart library                                    &&&
73:                  //&&&               Removed some Microchip's libraries dependancies         &&&
74:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
75:                  
76:                  
77:                  #include "main.h"
78:                  #include "common.h"
79:                  #include "int.h"
80:                  #include <system.h>
81:                  
82:                  //----------------------------- Global Variables ------------------------------
83:                  CONTEXT g;
84:                  
85:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
86:                  //------------------------------ Main Program ---------------------------------
87:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
88:                  int main ()
89:                  {
9D002CB8  27BDFF98   ADDIU SP, SP, -104
90:                      // local variables
91:                      boolean update = false;
9D002CC8  AFC00010   SW ZERO, 16(S8)
92:                  
93:                      //----------------------- Init Global variables ---------------------------
94:                      g.temp_target = 62;
9D002CCC  3C02A000   LUI V0, -24576
9D002CD0  2403003E   ADDIU V1, ZERO, 62
9D002CD4  A043000C   SB V1, 12(V0)
95:                      g.temp_too_low = -35;
9D002CD8  3C02A000   LUI V0, -24576
9D002CDC  2442000C   ADDIU V0, V0, 12
9D002CE0  2403FFDD   ADDIU V1, ZERO, -35
9D002CE4  A0430001   SB V1, 1(V0)
96:                      g.temp_warning = 75;
9D002CE8  3C02A000   LUI V0, -24576
9D002CEC  2442000C   ADDIU V0, V0, 12
9D002CF0  2403004B   ADDIU V1, ZERO, 75
9D002CF4  A0430002   SB V1, 2(V0)
97:                      g.temp_critical = 85;
9D002CF8  3C02A000   LUI V0, -24576
9D002CFC  2442000C   ADDIU V0, V0, 12
9D002D00  24030055   ADDIU V1, ZERO, 85
9D002D04  A0430004   SB V1, 4(V0)
98:                      g.temp_fan_off = 0;
9D002D08  3C02A000   LUI V0, -24576
9D002D0C  2442000C   ADDIU V0, V0, 12
9D002D10  A0400003   SB ZERO, 3(V0)
99:                      g.temp_sensors[TMP75_BR] = 0;
9D002D14  3C02A000   LUI V0, -24576
9D002D18  2442000C   ADDIU V0, V0, 12
9D002D1C  A4400006   SH ZERO, 6(V0)
100:                     g.temp_sensors[TMP75_LM] = 0;
9D002D20  3C02A000   LUI V0, -24576
9D002D24  2442000C   ADDIU V0, V0, 12
9D002D28  A440000C   SH ZERO, 12(V0)
101:                     g.temp_sensors[TMP75_MD] = 0;
9D002D2C  3C02A000   LUI V0, -24576
9D002D30  2442000C   ADDIU V0, V0, 12
9D002D34  A440000A   SH ZERO, 10(V0)
102:                     g.temp_sensors[TMP75_TM] = 0;
9D002D38  3C02A000   LUI V0, -24576
9D002D3C  2442000C   ADDIU V0, V0, 12
9D002D40  A4400008   SH ZERO, 8(V0)
103:                     g.temp_sensors[FPGA_ENC] = 0;
9D002D44  3C02A000   LUI V0, -24576
9D002D48  2442000C   ADDIU V0, V0, 12
9D002D4C  A440000E   SH ZERO, 14(V0)
104:                     g.temp_sensors[FPGA_IO] = 0;
9D002D50  3C02A000   LUI V0, -24576
9D002D54  2442000C   ADDIU V0, V0, 12
9D002D58  A4400010   SH ZERO, 16(V0)
105:                     g.temp_sensors[TEMP_LM63_1] = 0;
9D002D5C  3C02A000   LUI V0, -24576
9D002D60  2442000C   ADDIU V0, V0, 12
9D002D64  A4400012   SH ZERO, 18(V0)
106:                     g.temp_sensors[TEMP_LM63_2] = 0;
9D002D68  3C02A000   LUI V0, -24576
9D002D6C  2442000C   ADDIU V0, V0, 12
9D002D70  A4400014   SH ZERO, 20(V0)
107:                     g.fan_speed_threshold = 100;
9D002D74  3C02A000   LUI V0, -24576
9D002D78  2442000C   ADDIU V0, V0, 12
9D002D7C  24030064   ADDIU V1, ZERO, 100
9D002D80  A4430020   SH V1, 32(V0)
108:                     g.fan_speed_by_soc = false;
9D002D84  3C02A000   LUI V0, -24576
9D002D88  2442000C   ADDIU V0, V0, 12
9D002D8C  AC400044   SW ZERO, 68(V0)
109:                     g.fan_spin_up = true;
9D002D90  3C02A000   LUI V0, -24576
9D002D94  2442000C   ADDIU V0, V0, 12
9D002D98  24030001   ADDIU V1, ZERO, 1
9D002D9C  AC430024   SW V1, 36(V0)
110:                     g.power_in = 0;
9D002DA0  3C02A000   LUI V0, -24576
9D002DA4  2442000C   ADDIU V0, V0, 12
9D002DA8  AC400050   SW ZERO, 80(V0)
111:                     g.led_speed = 200;
9D002DAC  3C02A000   LUI V0, -24576
9D002DB0  2442000C   ADDIU V0, V0, 12
9D002DB4  2403FFC8   ADDIU V1, ZERO, -56
9D002DB8  A0430048   SB V1, 72(V0)
112:                     g.it_cause.temp_critical = 0;
9D002DBC  3C02A000   LUI V0, -24576
9D002DC0  2443000C   ADDIU V1, V0, 12
9D002DC4  9062004A   LBU V0, 74(V1)
9D002DC8  7C020004   INS V0, ZERO, 0, 1
9D002DCC  A062004A   SB V0, 74(V1)
113:                     g.it_cause.temp_hot = 0;
9D002DD0  3C02A000   LUI V0, -24576
9D002DD4  2443000C   ADDIU V1, V0, 12
9D002DD8  9062004A   LBU V0, 74(V1)
9D002DDC  7C020844   INS V0, ZERO, 1, 1
9D002DE0  A062004A   SB V0, 74(V1)
114:                     g.it_cause.temp_cold = 0;
9D002DE4  3C02A000   LUI V0, -24576
9D002DE8  2443000C   ADDIU V1, V0, 12
9D002DEC  9062004A   LBU V0, 74(V1)
9D002DF0  7C021084   INS V0, ZERO, 2, 1
9D002DF4  A062004A   SB V0, 74(V1)
115:                     g.it_cause.fan_slow = 0;
9D002DF8  3C02A000   LUI V0, -24576
9D002DFC  2443000C   ADDIU V1, V0, 12
9D002E00  9062004A   LBU V0, 74(V1)
9D002E04  7C0218C4   INS V0, ZERO, 3, 1
9D002E08  A062004A   SB V0, 74(V1)
116:                     g.it_cause.power_sup = 0;
9D002E0C  3C02A000   LUI V0, -24576
9D002E10  2443000C   ADDIU V1, V0, 12
9D002E14  9062004A   LBU V0, 74(V1)
9D002E18  7C022104   INS V0, ZERO, 4, 1
9D002E1C  A062004A   SB V0, 74(V1)
117:                     g.it_cause.low_power = 0;
9D002E20  3C02A000   LUI V0, -24576
9D002E24  2443000C   ADDIU V1, V0, 12
9D002E28  9062004A   LBU V0, 74(V1)
9D002E2C  7C022944   INS V0, ZERO, 5, 1
9D002E30  A062004A   SB V0, 74(V1)
118:                     g.it_en.temp_critical = 1;
9D002E34  3C02A000   LUI V0, -24576
9D002E38  2443000C   ADDIU V1, V0, 12
9D002E3C  9062004B   LBU V0, 75(V1)
9D002E40  24040001   ADDIU A0, ZERO, 1
9D002E44  7C820004   INS V0, A0, 0, 1
9D002E48  A062004B   SB V0, 75(V1)
119:                     g.it_en.temp_hot = 1;
9D002E4C  3C02A000   LUI V0, -24576
9D002E50  2443000C   ADDIU V1, V0, 12
9D002E54  9062004B   LBU V0, 75(V1)
9D002E58  24040001   ADDIU A0, ZERO, 1
9D002E5C  7C820844   INS V0, A0, 1, 1
9D002E60  A062004B   SB V0, 75(V1)
120:                     g.it_en.temp_cold = 1;
9D002E64  3C02A000   LUI V0, -24576
9D002E68  2443000C   ADDIU V1, V0, 12
9D002E6C  9062004B   LBU V0, 75(V1)
9D002E70  24040001   ADDIU A0, ZERO, 1
9D002E74  7C821084   INS V0, A0, 2, 1
9D002E78  A062004B   SB V0, 75(V1)
121:                     g.it_en.fan_slow = 1;
9D002E7C  3C02A000   LUI V0, -24576
9D002E80  2443000C   ADDIU V1, V0, 12
9D002E84  9062004B   LBU V0, 75(V1)
9D002E88  24040001   ADDIU A0, ZERO, 1
9D002E8C  7C8218C4   INS V0, A0, 3, 1
9D002E90  A062004B   SB V0, 75(V1)
122:                     g.it_en.power_sup = 1;
9D002E94  3C02A000   LUI V0, -24576
9D002E98  2443000C   ADDIU V1, V0, 12
9D002E9C  9062004B   LBU V0, 75(V1)
9D002EA0  24040001   ADDIU A0, ZERO, 1
9D002EA4  7C822104   INS V0, A0, 4, 1
9D002EA8  A062004B   SB V0, 75(V1)
123:                     g.it_en.low_power = 1;
9D002EAC  3C02A000   LUI V0, -24576
9D002EB0  2443000C   ADDIU V1, V0, 12
9D002EB4  9062004B   LBU V0, 75(V1)
9D002EB8  24040001   ADDIU A0, ZERO, 1
9D002EBC  7C822944   INS V0, A0, 5, 1
9D002EC0  A062004B   SB V0, 75(V1)
124:                     g.reg_debug = 0;
9D002EC4  3C02A000   LUI V0, -24576
9D002EC8  2442000C   ADDIU V0, V0, 12
9D002ECC  A0400049   SB ZERO, 73(V0)
125:                     g.pwr_status = 0;
9D002ED0  3C02A000   LUI V0, -24576
9D002ED4  2442000C   ADDIU V0, V0, 12
9D002ED8  A440007A   SH ZERO, 122(V0)
126:                     g.err_init = 0;
9D002EDC  3C02A000   LUI V0, -24576
9D002EE0  2442000C   ADDIU V0, V0, 12
9D002EE4  A0400079   SB ZERO, 121(V0)
127:                     g.err_ps = 0;
9D002EE8  3C02A000   LUI V0, -24576
9D002EEC  2442000C   ADDIU V0, V0, 12
9D002EF0  A0400078   SB ZERO, 120(V0)
128:                     g.lm63_data_1.fan_speed = LM63_NO_FAN;
9D002EF4  3C02A000   LUI V0, -24576
9D002EF8  2442000C   ADDIU V0, V0, 12
9D002EFC  2403FFFC   ADDIU V1, ZERO, -4
9D002F00  A443002A   SH V1, 42(V0)
129:                     g.lm63_data_2.fan_speed = LM63_NO_FAN;
9D002F04  3C02A000   LUI V0, -24576
9D002F08  2442000C   ADDIU V0, V0, 12
9D002F0C  2403FFFC   ADDIU V1, ZERO, -4
9D002F10  A4430038   SH V1, 56(V0)
130:                     g.update_data = false;
9D002F14  3C02A000   LUI V0, -24576
9D002F18  2442000C   ADDIU V0, V0, 12
9D002F1C  AC400074   SW ZERO, 116(V0)
131:                     g.critical_state = false;
9D002F20  3C02A000   LUI V0, -24576
9D002F24  2442000C   ADDIU V0, V0, 12
9D002F28  AC400018   SW ZERO, 24(V0)
132:                     g.led_pattern = LED_PATTERN_STARTING;
9D002F2C  3C02A000   LUI V0, -24576
9D002F30  2442000C   ADDIU V0, V0, 12
9D002F34  24030001   ADDIU V1, ZERO, 1
9D002F38  AC43007C   SW V1, 124(V0)
133:                     g.arria_activated = false;
9D002F3C  3C02A000   LUI V0, -24576
9D002F40  2442000C   ADDIU V0, V0, 12
9D002F44  AC40001C   SW ZERO, 28(V0)
134:                     g.i2c_error = false,
9D002F48  3C02A000   LUI V0, -24576
9D002F4C  2442000C   ADDIU V0, V0, 12
9D002F50  AC400080   SW ZERO, 128(V0)
9D002F54  3C020131   LUI V0, 305
9D002F58  34422D00   ORI V0, V0, 11520
9D002F5C  AFC20014   SW V0, 20(S8)
9D002F60  24020005   ADDIU V0, ZERO, 5
9D002F64  AFC20018   SW V0, 24(S8)
135:                 
136:                     //------------------------ init system clock ------------------------------
137:                     SYSTEMConfig(GetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);   // running @ 20 MHz
138:                 
139:                     //------------------------- IO configuration ------------------------------ (23 ms after Vin is stable)
140:                     gpio_init();
9D00320C  0F401D71   JAL gpio_init
9D003210  00000000   NOP
141:                 
142:                     // reset all chips
143:                     if (power_supplies_check() == SUCCESS){// this is an update (or a soft reboot) -> don't reset SoC
9D003214  0F4013F2   JAL power_supplies_check
9D003218  00000000   NOP
9D00321C  14400008   BNE V0, ZERO, 0x9D003240
9D003220  00000000   NOP
144:                         io_power_off_sequence(/*reset_soc*/false);
9D003224  00002021   ADDU A0, ZERO, ZERO
9D003228  0F401E00   JAL io_power_off_sequence
9D00322C  00000000   NOP
145:                         update = true;
9D003230  24020001   ADDIU V0, ZERO, 1
9D003234  AFC20010   SW V0, 16(S8)
9D003238  0B400C96   J 0x9D003258
9D00323C  00000000   NOP
146:                     }else{
147:                         power_down_dc_dc();
9D003240  0F40151D   JAL power_down_dc_dc
9D003244  00000000   NOP
148:                         io_power_off_sequence(/*reset_soc*/true);
9D003248  24040001   ADDIU A0, ZERO, 1
9D00324C  0F401E00   JAL io_power_off_sequence
9D003250  00000000   NOP
149:                         update = false;
9D003254  AFC00010   SW ZERO, 16(S8)
150:                     }
151:                 
152:                     // power-down heat resistors
153:                     #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
154:                     power_resistors_control(PWR_RES_ALL_OFF);
155:                     #endif
156:                 
157:                     //--------------------------- init i2c buses ------------------------------ (23 ms after Vin is stable)
158:                     if (i2c_master_init(I2C_BUS_2, I2C_FREQ) != SUCCESS) g.err_init++;              // i2c_2 (tmp75 & lm63)
9D003258  24040001   ADDIU A0, ZERO, 1
9D00325C  3C020001   LUI V0, 1
9D003260  344586A0   ORI A1, V0, -31072
9D003264  0F40059B   JAL i2c_master_init
9D003268  00000000   NOP
9D00326C  10400009   BEQ V0, ZERO, 0x9D003294
9D003270  00000000   NOP
9D003274  3C02A000   LUI V0, -24576
9D003278  2442000C   ADDIU V0, V0, 12
9D00327C  90420079   LBU V0, 121(V0)
9D003280  24420001   ADDIU V0, V0, 1
9D003284  304300FF   ANDI V1, V0, 255
9D003288  3C02A000   LUI V0, -24576
9D00328C  2442000C   ADDIU V0, V0, 12
9D003290  A0430079   SB V1, 121(V0)
159:                     #if defined (_PCB5_)
160:                     if (i2c_master_init(I2C_BUS_3, I2C_FREQ) != SUCCESS) g.err_init++;              // i2c_3 (lm63)
9D003294  24040002   ADDIU A0, ZERO, 2
9D003298  3C020001   LUI V0, 1
9D00329C  344586A0   ORI A1, V0, -31072
9D0032A0  0F40059B   JAL i2c_master_init
9D0032A4  00000000   NOP
9D0032A8  10400009   BEQ V0, ZERO, 0x9D0032D0
9D0032AC  00000000   NOP
9D0032B0  3C02A000   LUI V0, -24576
9D0032B4  2442000C   ADDIU V0, V0, 12
9D0032B8  90420079   LBU V0, 121(V0)
9D0032BC  24420001   ADDIU V0, V0, 1
9D0032C0  304300FF   ANDI V1, V0, 255
9D0032C4  3C02A000   LUI V0, -24576
9D0032C8  2442000C   ADDIU V0, V0, 12
9D0032CC  A0430079   SB V1, 121(V0)
161:                     #endif
162:                     if (i2c1_slave_init(I2C_SLAVE_ADDRESS)  != SUCCESS) g.err_init++;               // i2c_1 (SoC)
9D0032D0  24040022   ADDIU A0, ZERO, 34
9D0032D4  0F401B29   JAL i2c1_slave_init
9D0032D8  00000000   NOP
9D0032DC  10400009   BEQ V0, ZERO, 0x9D003304
9D0032E0  00000000   NOP
9D0032E4  3C02A000   LUI V0, -24576
9D0032E8  2442000C   ADDIU V0, V0, 12
9D0032EC  90420079   LBU V0, 121(V0)
9D0032F0  24420001   ADDIU V0, V0, 1
9D0032F4  304300FF   ANDI V1, V0, 255
9D0032F8  3C02A000   LUI V0, -24576
9D0032FC  2442000C   ADDIU V0, V0, 12
9D003300  A0430079   SB V1, 121(V0)
163:                 
164:                     //------------------------------ init adc --------------------------------- (23 ms after Vin is stable)
165:                     if (adc_init() != SUCCESS) g.err_init++;
9D003304  0F401C6D   JAL adc_init
9D003308  00000000   NOP
9D00330C  10400009   BEQ V0, ZERO, 0x9D003334
9D003310  00000000   NOP
9D003314  3C02A000   LUI V0, -24576
9D003318  2442000C   ADDIU V0, V0, 12
9D00331C  90420079   LBU V0, 121(V0)
9D003320  24420001   ADDIU V0, V0, 1
9D003324  304300FF   ANDI V1, V0, 255
9D003328  3C02A000   LUI V0, -24576
9D00332C  2442000C   ADDIU V0, V0, 12
9D003330  A0430079   SB V1, 121(V0)
166:                     get_power_in_at_startup(&g.power_in_at_startup);
9D003334  3C02A000   LUI V0, -24576
9D003338  24440058   ADDIU A0, V0, 88
9D00333C  0F401D3B   JAL get_power_in_at_startup
9D003340  00000000   NOP
167:                 
168:                     //----------------------------- init timers -------------------------------
169:                     if (timer_init(TIMER_1, TMR_200MS) != SUCCESS) g.err_init++;     // used to toggle the LED
9D003344  00002021   ADDU A0, ZERO, ZERO
9D003348  3405F424   ORI A1, ZERO, -3036
9D00334C  0F400F08   JAL timer_init
9D003350  00000000   NOP
9D003354  10400009   BEQ V0, ZERO, 0x9D00337C
9D003358  00000000   NOP
9D00335C  3C02A000   LUI V0, -24576
9D003360  2442000C   ADDIU V0, V0, 12
9D003364  90420079   LBU V0, 121(V0)
9D003368  24420001   ADDIU V0, V0, 1
9D00336C  304300FF   ANDI V1, V0, 255
9D003370  3C02A000   LUI V0, -24576
9D003374  2442000C   ADDIU V0, V0, 12
9D003378  A0430079   SB V1, 121(V0)
170:                     if (timer_init(TIMER_3, TMR_200MS) != SUCCESS) g.err_init++;     // used to read the temperature
9D00337C  24040002   ADDIU A0, ZERO, 2
9D003380  3405F424   ORI A1, ZERO, -3036
9D003384  0F400F08   JAL timer_init
9D003388  00000000   NOP
9D00338C  10400009   BEQ V0, ZERO, 0x9D0033B4
9D003390  00000000   NOP
9D003394  3C02A000   LUI V0, -24576
9D003398  2442000C   ADDIU V0, V0, 12
9D00339C  90420079   LBU V0, 121(V0)
9D0033A0  24420001   ADDIU V0, V0, 1
9D0033A4  304300FF   ANDI V1, V0, 255
9D0033A8  3C02A000   LUI V0, -24576
9D0033AC  2442000C   ADDIU V0, V0, 12
9D0033B0  A0430079   SB V1, 121(V0)
171:                     if (timer_init(TIMER_5, TMR_200MS) != SUCCESS) g.err_init++;     // used for fan spin-up
9D0033B4  24040004   ADDIU A0, ZERO, 4
9D0033B8  3405F424   ORI A1, ZERO, -3036
9D0033BC  0F400F08   JAL timer_init
9D0033C0  00000000   NOP
9D0033C4  10400009   BEQ V0, ZERO, 0x9D0033EC
9D0033C8  00000000   NOP
9D0033CC  3C02A000   LUI V0, -24576
9D0033D0  2442000C   ADDIU V0, V0, 12
9D0033D4  90420079   LBU V0, 121(V0)
9D0033D8  24420001   ADDIU V0, V0, 1
9D0033DC  304300FF   ANDI V1, V0, 255
9D0033E0  3C02A000   LUI V0, -24576
9D0033E4  2442000C   ADDIU V0, V0, 12
9D0033E8  A0430079   SB V1, 121(V0)
172:                 
173:                     //-------------------------- init interrupts ------------------------------ (31 ms after Vin is stable)
174:                     // Configure for multi-vectored mode
175:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D0033EC  00002021   ADDU A0, ZERO, ZERO
9D0033F0  0F40234C   JAL INTConfigureSystem
9D0033F4  00000000   NOP
176:                 
177:                     // Enable interrupts
178:                     INTEnableInterrupts();
9D0033F8  0F402377   JAL INTEnableInterrupts
9D0033FC  00000000   NOP
179:                 
180:                     //------------------------------ Watchdog ---------------------------------
181:                     WDTCONSET = 0x8000;         // Turn on the WDT (4 sec)
9D003400  3C02BF80   LUI V0, -16512
9D003404  34038000   ORI V1, ZERO, -32768
9D003408  AC430008   SW V1, 8(V0)
182:                 
183:                     //-------------------------------- PWM ------------------------------------
184:                     pwm_init(PWM_1, 100*PWM_FREQ_COEF);
9D00340C  00002021   ADDU A0, ZERO, ZERO
9D003410  240503E8   ADDIU A1, ZERO, 1000
9D003414  0F402021   JAL pwm_init
9D003418  00000000   NOP
185:                 
186:                     //------------------------------------------------------------------------- (31.6 ms after Vin is stable)
187:                     if (update == false){
9D00341C  8FC20010   LW V0, 16(S8)
9D003420  14400011   BNE V0, ZERO, 0x9D003468
9D003424  00000000   NOP
188:                         // start power supplies
189:                         g.err_ps = power_supplies_management();
9D003428  0F4012C0   JAL power_supplies_management
9D00342C  00000000   NOP
9D003430  304300FF   ANDI V1, V0, 255
9D003434  3C02A000   LUI V0, -24576
9D003438  2442000C   ADDIU V0, V0, 12
9D00343C  A0430078   SB V1, 120(V0)
190:                 
191:                         // release all resets
192:                         if (g.err_ps == SUCCESS)
9D003440  3C02A000   LUI V0, -24576
9D003444  2442000C   ADDIU V0, V0, 12
9D003448  90420078   LBU V0, 120(V0)
9D00344C  14400010   BNE V0, ZERO, 0x9D003490
9D003450  00000000   NOP
193:                             io_power_on_sequence(/*reset_soc*/true);
9D003454  24040001   ADDIU A0, ZERO, 1
9D003458  0F401DBB   JAL io_power_on_sequence
9D00345C  00000000   NOP
9D003460  0B400D24   J 0x9D003490
9D003464  00000000   NOP
194:                     }else{
195:                 
196:                         // enables all power supplies (enables are kept high by the SoC after an update)
197:                         power_up_dc_dc();
9D003468  0F40155D   JAL power_up_dc_dc
9D00346C  00000000   NOP
198:                 
199:                         // release all resets
200:                         if (g.err_ps == SUCCESS)
9D003470  3C02A000   LUI V0, -24576
9D003474  2442000C   ADDIU V0, V0, 12
9D003478  90420078   LBU V0, 120(V0)
9D00347C  14400004   BNE V0, ZERO, 0x9D003490
9D003480  00000000   NOP
201:                             io_power_on_sequence(/*reset_soc*/false);
9D003484  00002021   ADDU A0, ZERO, ZERO
9D003488  0F401DBB   JAL io_power_on_sequence
9D00348C  00000000   NOP
202:                     }
203:                 
204:                     //-------------- Configuration of temperature sensors (tmp75) ------------- (353 ms after Vin is stable)
205:                     if (tmp75_configure(I2C_BUS_2, TMP75_ADDRESS+0) != SUCCESS) g.err_init++;
9D003490  24040001   ADDIU A0, ZERO, 1
9D003494  24050048   ADDIU A1, ZERO, 72
9D003498  0F401E7F   JAL tmp75_configure
9D00349C  00000000   NOP
9D0034A0  10400009   BEQ V0, ZERO, 0x9D0034C8
9D0034A4  00000000   NOP
9D0034A8  3C02A000   LUI V0, -24576
9D0034AC  2442000C   ADDIU V0, V0, 12
9D0034B0  90420079   LBU V0, 121(V0)
9D0034B4  24420001   ADDIU V0, V0, 1
9D0034B8  304300FF   ANDI V1, V0, 255
9D0034BC  3C02A000   LUI V0, -24576
9D0034C0  2442000C   ADDIU V0, V0, 12
9D0034C4  A0430079   SB V1, 121(V0)
206:                     if (tmp75_configure(I2C_BUS_2, TMP75_ADDRESS+1) != SUCCESS) g.err_init++;
9D0034C8  24040001   ADDIU A0, ZERO, 1
9D0034CC  24050049   ADDIU A1, ZERO, 73
9D0034D0  0F401E7F   JAL tmp75_configure
9D0034D4  00000000   NOP
9D0034D8  10400009   BEQ V0, ZERO, 0x9D003500
9D0034DC  00000000   NOP
9D0034E0  3C02A000   LUI V0, -24576
9D0034E4  2442000C   ADDIU V0, V0, 12
9D0034E8  90420079   LBU V0, 121(V0)
9D0034EC  24420001   ADDIU V0, V0, 1
9D0034F0  304300FF   ANDI V1, V0, 255
9D0034F4  3C02A000   LUI V0, -24576
9D0034F8  2442000C   ADDIU V0, V0, 12
9D0034FC  A0430079   SB V1, 121(V0)
207:                     if (tmp75_configure(I2C_BUS_2, TMP75_ADDRESS+2) != SUCCESS) g.err_init++;
9D003500  24040001   ADDIU A0, ZERO, 1
9D003504  2405004A   ADDIU A1, ZERO, 74
9D003508  0F401E7F   JAL tmp75_configure
9D00350C  00000000   NOP
9D003510  10400009   BEQ V0, ZERO, 0x9D003538
9D003514  00000000   NOP
9D003518  3C02A000   LUI V0, -24576
9D00351C  2442000C   ADDIU V0, V0, 12
9D003520  90420079   LBU V0, 121(V0)
9D003524  24420001   ADDIU V0, V0, 1
9D003528  304300FF   ANDI V1, V0, 255
9D00352C  3C02A000   LUI V0, -24576
9D003530  2442000C   ADDIU V0, V0, 12
9D003534  A0430079   SB V1, 121(V0)
208:                     if (tmp75_configure(I2C_BUS_2, TMP75_ADDRESS+3) != SUCCESS) g.err_init++;
9D003538  24040001   ADDIU A0, ZERO, 1
9D00353C  2405004B   ADDIU A1, ZERO, 75
9D003540  0F401E7F   JAL tmp75_configure
9D003544  00000000   NOP
9D003548  10400009   BEQ V0, ZERO, 0x9D003570
9D00354C  00000000   NOP
9D003550  3C02A000   LUI V0, -24576
9D003554  2442000C   ADDIU V0, V0, 12
9D003558  90420079   LBU V0, 121(V0)
9D00355C  24420001   ADDIU V0, V0, 1
9D003560  304300FF   ANDI V1, V0, 255
9D003564  3C02A000   LUI V0, -24576
9D003568  2442000C   ADDIU V0, V0, 12
9D00356C  A0430079   SB V1, 121(V0)
209:                 
210:                     // config lm63 (!! this chip is not powered at start-up)
211:                     if (lm63_configure(I2C_BUS_2) != SUCCESS) g.err_init++;
9D003570  24040001   ADDIU A0, ZERO, 1
9D003574  0F4017E5   JAL lm63_configure
9D003578  00000000   NOP
9D00357C  10400009   BEQ V0, ZERO, 0x9D0035A4
9D003580  00000000   NOP
9D003584  3C02A000   LUI V0, -24576
9D003588  2442000C   ADDIU V0, V0, 12
9D00358C  90420079   LBU V0, 121(V0)
9D003590  24420001   ADDIU V0, V0, 1
9D003594  304300FF   ANDI V1, V0, 255
9D003598  3C02A000   LUI V0, -24576
9D00359C  2442000C   ADDIU V0, V0, 12
9D0035A0  A0430079   SB V1, 121(V0)
212:                     #if defined (_PCB5_)
213:                     if (lm63_configure(I2C_BUS_3) != SUCCESS) g.err_init++;
9D0035A4  24040002   ADDIU A0, ZERO, 2
9D0035A8  0F4017E5   JAL lm63_configure
9D0035AC  00000000   NOP
9D0035B0  10400009   BEQ V0, ZERO, 0x9D0035D8
9D0035B4  00000000   NOP
9D0035B8  3C02A000   LUI V0, -24576
9D0035BC  2442000C   ADDIU V0, V0, 12
9D0035C0  90420079   LBU V0, 121(V0)
9D0035C4  24420001   ADDIU V0, V0, 1
9D0035C8  304300FF   ANDI V1, V0, 255
9D0035CC  3C02A000   LUI V0, -24576
9D0035D0  2442000C   ADDIU V0, V0, 12
9D0035D4  A0430079   SB V1, 121(V0)
214:                     #endif
215:                 
216:                     //------------------------------------------------------------------------- (355 ms after Vin is stable)
217:                     // set fan speed at the maximum for 4 seconds
218:                     set_fan_speed(PWM_FAN_MAX/2);  // full speed seems to be too much
9D0035D8  00002021   ADDU A0, ZERO, ZERO
9D0035DC  240501F4   ADDIU A1, ZERO, 500
9D0035E0  0F40205A   JAL pwm_set_duty_cycle
9D0035E4  00000000   NOP
219:                 
220:                     // set the pattern of the blinking LED
221:                     g.led_pattern = LED_PATTERN_STARTING;
9D0035E8  3C02A000   LUI V0, -24576
9D0035EC  2442000C   ADDIU V0, V0, 12
9D0035F0  24030001   ADDIU V1, ZERO, 1
9D0035F4  AC43007C   SW V1, 124(V0)
222:                 
223:                 
224:                 //    if (g.err_init){
225:                 //        timer_init(TIMER_1, TMR_10MS);
226:                 //    }else if (g.err_ps){
227:                 //        timer_init(TIMER_1, TMR_50MS);
228:                 //    }
229:                 
230:                     //------------------------------------------------------------------------- (355 ms after Vin is stable)
231:                     while (1)   // about 3 ms for one loop
232:                     {
233:                         //-------------------------------------------------------
234:                         clear_watchdog;
9D0035F8  3C02BF80   LUI V0, -16512
9D0035FC  24030001   ADDIU V1, ZERO, 1
9D003600  AC430008   SW V1, 8(V0)
235:                 
236:                         //-------------------------------------------------------
237:                         // update data from sensors (when IT occurs)
238:                         if (g.update_data == true)
9D003604  3C02A000   LUI V0, -24576
9D003608  2442000C   ADDIU V0, V0, 12
9D00360C  8C430074   LW V1, 116(V0)
9D003610  24020001   ADDIU V0, ZERO, 1
9D003614  1462011F   BNE V1, V0, 0x9D003A94
9D003618  00000000   NOP
239:                         {
240:                             g.update_data = false;
9D00361C  3C02A000   LUI V0, -24576
9D003620  2442000C   ADDIU V0, V0, 12
9D003624  AC400074   SW ZERO, 116(V0)
241:                 
242:                             check_input_voltage();
9D003628  0F400EDE   JAL check_input_voltage
9D00362C  00000000   NOP
243:                 
244:                             #if defined (_PCB5_)
245:                 
246:                             if (lm63_read_die_temp(I2C_BUS_3, &g.lm63_data_2.temp_die) != SUCCESS) g.i2c_error++;
9D003630  24040002   ADDIU A0, ZERO, 2
9D003634  3C02A000   LUI V0, -24576
9D003638  2445004A   ADDIU A1, V0, 74
9D00363C  0F401882   JAL lm63_read_die_temp
9D003640  00000000   NOP
9D003644  10400008   BEQ V0, ZERO, 0x9D003668
9D003648  00000000   NOP
9D00364C  3C02A000   LUI V0, -24576
9D003650  2442000C   ADDIU V0, V0, 12
9D003654  8C420080   LW V0, 128(V0)
9D003658  24430001   ADDIU V1, V0, 1
9D00365C  3C02A000   LUI V0, -24576
9D003660  2442000C   ADDIU V0, V0, 12
9D003664  AC430080   SW V1, 128(V0)
247:                             g.temp_sensors[TEMP_LM63_2] = g.lm63_data_2.temp_die;
9D003668  3C02A000   LUI V0, -24576
9D00366C  2442000C   ADDIU V0, V0, 12
9D003670  8042003E   LB V0, 62(V0)
9D003674  3043FFFF   ANDI V1, V0, -1
9D003678  3C02A000   LUI V0, -24576
9D00367C  2442000C   ADDIU V0, V0, 12
9D003680  A4430014   SH V1, 20(V0)
248:                             check_input_voltage();
9D003684  0F400EDE   JAL check_input_voltage
9D003688  00000000   NOP
249:                             if (lm63_read_diode_temp(I2C_BUS_3, &g.lm63_data_2.temp_diode) != SUCCESS) g.i2c_error++;
9D00368C  24040002   ADDIU A0, ZERO, 2
9D003690  3C02A000   LUI V0, -24576
9D003694  2445004C   ADDIU A1, V0, 76
9D003698  0F4018CB   JAL lm63_read_diode_temp
9D00369C  00000000   NOP
9D0036A0  10400008   BEQ V0, ZERO, 0x9D0036C4
9D0036A4  00000000   NOP
9D0036A8  3C02A000   LUI V0, -24576
9D0036AC  2442000C   ADDIU V0, V0, 12
9D0036B0  8C420080   LW V0, 128(V0)
9D0036B4  24430001   ADDIU V1, V0, 1
9D0036B8  3C02A000   LUI V0, -24576
9D0036BC  2442000C   ADDIU V0, V0, 12
9D0036C0  AC430080   SW V1, 128(V0)
250:                             g.temp_sensors[FPGA_ENC] = g.lm63_data_2.temp_diode;
9D0036C4  3C02A000   LUI V0, -24576
9D0036C8  2442000C   ADDIU V0, V0, 12
9D0036CC  80420040   LB V0, 64(V0)
9D0036D0  3043FFFF   ANDI V1, V0, -1
9D0036D4  3C02A000   LUI V0, -24576
9D0036D8  2442000C   ADDIU V0, V0, 12
9D0036DC  A443000E   SH V1, 14(V0)
251:                             check_input_voltage();
9D0036E0  0F400EDE   JAL check_input_voltage
9D0036E4  00000000   NOP
252:                             if (lm63_read_speed(I2C_BUS_3, &g.lm63_data_2.fan_speed) != SUCCESS) g.i2c_error++;
9D0036E8  24040002   ADDIU A0, ZERO, 2
9D0036EC  3C02A000   LUI V0, -24576
9D0036F0  24450044   ADDIU A1, V0, 68
9D0036F4  0F4018F9   JAL lm63_read_speed
9D0036F8  00000000   NOP
9D0036FC  10400008   BEQ V0, ZERO, 0x9D003720
9D003700  00000000   NOP
9D003704  3C02A000   LUI V0, -24576
9D003708  2442000C   ADDIU V0, V0, 12
9D00370C  8C420080   LW V0, 128(V0)
9D003710  24430001   ADDIU V1, V0, 1
9D003714  3C02A000   LUI V0, -24576
9D003718  2442000C   ADDIU V0, V0, 12
9D00371C  AC430080   SW V1, 128(V0)
253:                             check_input_voltage();
9D003720  0F400EDE   JAL check_input_voltage
9D003724  00000000   NOP
254:                 
255:                             #endif
256:                 
257:                             // update data from lm63
258:                             if (lm63_read_die_temp(I2C_BUS_2, &g.lm63_data_1.temp_die) != SUCCESS) g.i2c_error++;
9D003728  24040001   ADDIU A0, ZERO, 1
9D00372C  3C02A000   LUI V0, -24576
9D003730  2445003C   ADDIU A1, V0, 60
9D003734  0F401882   JAL lm63_read_die_temp
9D003738  00000000   NOP
9D00373C  10400008   BEQ V0, ZERO, 0x9D003760
9D003740  00000000   NOP
9D003744  3C02A000   LUI V0, -24576
9D003748  2442000C   ADDIU V0, V0, 12
9D00374C  8C420080   LW V0, 128(V0)
9D003750  24430001   ADDIU V1, V0, 1
9D003754  3C02A000   LUI V0, -24576
9D003758  2442000C   ADDIU V0, V0, 12
9D00375C  AC430080   SW V1, 128(V0)
259:                             g.temp_sensors[TEMP_LM63_1] = g.lm63_data_1.temp_die;
9D003760  3C02A000   LUI V0, -24576
9D003764  2442000C   ADDIU V0, V0, 12
9D003768  80420030   LB V0, 48(V0)
9D00376C  3043FFFF   ANDI V1, V0, -1
9D003770  3C02A000   LUI V0, -24576
9D003774  2442000C   ADDIU V0, V0, 12
9D003778  A4430012   SH V1, 18(V0)
260:                             check_input_voltage();
9D00377C  0F400EDE   JAL check_input_voltage
9D003780  00000000   NOP
261:                             if (lm63_read_diode_temp(I2C_BUS_2, &g.lm63_data_1.temp_diode) != SUCCESS) g.i2c_error++;
9D003784  24040001   ADDIU A0, ZERO, 1
9D003788  3C02A000   LUI V0, -24576
9D00378C  2445003E   ADDIU A1, V0, 62
9D003790  0F4018CB   JAL lm63_read_diode_temp
9D003794  00000000   NOP
9D003798  10400008   BEQ V0, ZERO, 0x9D0037BC
9D00379C  00000000   NOP
9D0037A0  3C02A000   LUI V0, -24576
9D0037A4  2442000C   ADDIU V0, V0, 12
9D0037A8  8C420080   LW V0, 128(V0)
9D0037AC  24430001   ADDIU V1, V0, 1
9D0037B0  3C02A000   LUI V0, -24576
9D0037B4  2442000C   ADDIU V0, V0, 12
9D0037B8  AC430080   SW V1, 128(V0)
262:                             g.temp_sensors[FPGA_IO] = g.lm63_data_1.temp_diode;
9D0037BC  3C02A000   LUI V0, -24576
9D0037C0  2442000C   ADDIU V0, V0, 12
9D0037C4  80420032   LB V0, 50(V0)
9D0037C8  3043FFFF   ANDI V1, V0, -1
9D0037CC  3C02A000   LUI V0, -24576
9D0037D0  2442000C   ADDIU V0, V0, 12
9D0037D4  A4430010   SH V1, 16(V0)
263:                             check_input_voltage();
9D0037D8  0F400EDE   JAL check_input_voltage
9D0037DC  00000000   NOP
264:                             if (lm63_read_speed(I2C_BUS_2, &g.lm63_data_1.fan_speed) != SUCCESS) g.i2c_error++;
9D0037E0  24040001   ADDIU A0, ZERO, 1
9D0037E4  3C02A000   LUI V0, -24576
9D0037E8  24450036   ADDIU A1, V0, 54
9D0037EC  0F4018F9   JAL lm63_read_speed
9D0037F0  00000000   NOP
9D0037F4  10400008   BEQ V0, ZERO, 0x9D003818
9D0037F8  00000000   NOP
9D0037FC  3C02A000   LUI V0, -24576
9D003800  2442000C   ADDIU V0, V0, 12
9D003804  8C420080   LW V0, 128(V0)
9D003808  24430001   ADDIU V1, V0, 1
9D00380C  3C02A000   LUI V0, -24576
9D003810  2442000C   ADDIU V0, V0, 12
9D003814  AC430080   SW V1, 128(V0)
265:                             check_input_voltage();
9D003818  0F400EDE   JAL check_input_voltage
9D00381C  00000000   NOP
266:                 
267:                 
268:                             // read temperature
269:                             tmp75_read_temp(I2C_BUS_2, TMP75_ADDRESS+0, &g.temp_sensors[TMP75_BR]);
9D003820  24040001   ADDIU A0, ZERO, 1
9D003824  24050048   ADDIU A1, ZERO, 72
9D003828  3C02A000   LUI V0, -24576
9D00382C  24460012   ADDIU A2, V0, 18
9D003830  0F401E38   JAL tmp75_read_temp
9D003834  00000000   NOP
270:                             check_input_voltage();
9D003838  0F400EDE   JAL check_input_voltage
9D00383C  00000000   NOP
271:                             tmp75_read_temp(I2C_BUS_2, TMP75_ADDRESS+1, &g.temp_sensors[TMP75_TM]);
9D003840  24040001   ADDIU A0, ZERO, 1
9D003844  24050049   ADDIU A1, ZERO, 73
9D003848  3C02A000   LUI V0, -24576
9D00384C  24460014   ADDIU A2, V0, 20
9D003850  0F401E38   JAL tmp75_read_temp
9D003854  00000000   NOP
272:                             check_input_voltage();
9D003858  0F400EDE   JAL check_input_voltage
9D00385C  00000000   NOP
273:                             tmp75_read_temp(I2C_BUS_2, TMP75_ADDRESS+2, &g.temp_sensors[TMP75_MD]);
9D003860  24040001   ADDIU A0, ZERO, 1
9D003864  2405004A   ADDIU A1, ZERO, 74
9D003868  3C02A000   LUI V0, -24576
9D00386C  24460016   ADDIU A2, V0, 22
9D003870  0F401E38   JAL tmp75_read_temp
9D003874  00000000   NOP
274:                             check_input_voltage();
9D003878  0F400EDE   JAL check_input_voltage
9D00387C  00000000   NOP
275:                             tmp75_read_temp(I2C_BUS_2, TMP75_ADDRESS+3, &g.temp_sensors[TMP75_LM]);
9D003880  24040001   ADDIU A0, ZERO, 1
9D003884  2405004B   ADDIU A1, ZERO, 75
9D003888  3C02A000   LUI V0, -24576
9D00388C  24460018   ADDIU A2, V0, 24
9D003890  0F401E38   JAL tmp75_read_temp
9D003894  00000000   NOP
276:                             check_input_voltage();
9D003898  0F400EDE   JAL check_input_voltage
9D00389C  00000000   NOP
277:                 
278:                 
279:                             // manage temperature
280:                             temperature_management(g.temp_sensors);
9D0038A0  3C02A000   LUI V0, -24576
9D0038A4  24440012   ADDIU A0, V0, 18
9D0038A8  0F401601   JAL temperature_management
9D0038AC  00000000   NOP
281:                 
282:                             // check if all power supplies are ok
283:                             if (power_supplies_check() != SUCCESS){
9D0038B0  0F4013F2   JAL power_supplies_check
9D0038B4  00000000   NOP
9D0038B8  1040000E   BEQ V0, ZERO, 0x9D0038F4
9D0038BC  00000000   NOP
284:                                 if (g.it_en.power_sup){
9D0038C0  3C02A000   LUI V0, -24576
9D0038C4  2442000C   ADDIU V0, V0, 12
9D0038C8  8C430048   LW V1, 72(V0)
9D0038CC  3C021000   LUI V0, 4096
9D0038D0  00621024   AND V0, V1, V0
9D0038D4  10400007   BEQ V0, ZERO, 0x9D0038F4
9D0038D8  00000000   NOP
285:                                     g.it_cause.power_sup = 1;
9D0038DC  3C02A000   LUI V0, -24576
9D0038E0  2443000C   ADDIU V1, V0, 12
9D0038E4  9062004A   LBU V0, 74(V1)
9D0038E8  24040001   ADDIU A0, ZERO, 1
9D0038EC  7C822104   INS V0, A0, 4, 1
9D0038F0  A062004A   SB V0, 74(V1)
286:                                 }
287:                             }
288:                 
289:                             check_input_voltage();
9D0038F4  0F400EDE   JAL check_input_voltage
9D0038F8  00000000   NOP
290:                 
291:                             // read voltages
292:                             adc_conversion(&g.power_0v9_enc, ADC_CH8);
9D0038FC  3C02A000   LUI V0, -24576
9D003900  24440064   ADDIU A0, V0, 100
9D003904  24050008   ADDIU A1, ZERO, 8
9D003908  0F401CC5   JAL adc_conversion
9D00390C  00000000   NOP
293:                             adc_conversion(&g.power_1v8,     ADC_CH5);
9D003910  3C02A000   LUI V0, -24576
9D003914  24440068   ADDIU A0, V0, 104
9D003918  24050005   ADDIU A1, ZERO, 5
9D00391C  0F401CC5   JAL adc_conversion
9D003920  00000000   NOP
294:                             #if defined (_PCB5_)
295:                             adc_conversion(&g.power_0v9_cpu, ADC_CH10);
9D003924  3C02A000   LUI V0, -24576
9D003928  2444007C   ADDIU A0, V0, 124
9D00392C  2405000A   ADDIU A1, ZERO, 10
9D003930  0F401CC5   JAL adc_conversion
9D003934  00000000   NOP
296:                             adc_conversion(&g.power_0v9_io,  ADC_CH3);
9D003938  3C02A000   LUI V0, -24576
9D00393C  24440060   ADDIU A0, V0, 96
9D003940  24050003   ADDIU A1, ZERO, 3
9D003944  0F401CC5   JAL adc_conversion
9D003948  00000000   NOP
297:                             adc_conversion(&g.power_1v1,     ADC_CH7);
9D00394C  3C02A000   LUI V0, -24576
9D003950  24440070   ADDIU A0, V0, 112
9D003954  24050007   ADDIU A1, ZERO, 7
9D003958  0F401CC5   JAL adc_conversion
9D00395C  00000000   NOP
298:                             adc_conversion(&g.power_1v0,     ADC_CH9);
9D003960  3C02A000   LUI V0, -24576
9D003964  24440078   ADDIU A0, V0, 120
9D003968  24050009   ADDIU A1, ZERO, 9
9D00396C  0F401CC5   JAL adc_conversion
9D003970  00000000   NOP
299:                             adc_conversion(&g.power_1v5,     ADC_CH4);
9D003974  3C02A000   LUI V0, -24576
9D003978  24440074   ADDIU A0, V0, 116
9D00397C  24050004   ADDIU A1, ZERO, 4
9D003980  0F401CC5   JAL adc_conversion
9D003984  00000000   NOP
300:                             adc_conversion(&g.power_3v3,     ADC_CH6);
9D003988  3C02A000   LUI V0, -24576
9D00398C  2444006C   ADDIU A0, V0, 108
9D003990  24050006   ADDIU A1, ZERO, 6
9D003994  0F401CC5   JAL adc_conversion
9D003998  00000000   NOP
301:                             #endif
302:                 
303:                             check_input_voltage();
9D00399C  0F400EDE   JAL check_input_voltage
9D0039A0  00000000   NOP
304:                 
305:                             // check speed of the fan
306:                             if (OC1RS != 0){ // if control is > 0
9D0039A4  3C02BF80   LUI V0, -16512
9D0039A8  8C423020   LW V0, 12320(V0)
9D0039AC  10400039   BEQ V0, ZERO, 0x9D003A94
9D0039B0  00000000   NOP
307:                 
308:                                 if (g.lm63_data_1.fan_speed < g.fan_speed_threshold ||
9D0039B4  3C02A000   LUI V0, -24576
9D0039B8  2442000C   ADDIU V0, V0, 12
9D0039BC  9443002A   LHU V1, 42(V0)
9D0039C0  3C02A000   LUI V0, -24576
9D0039C4  2442000C   ADDIU V0, V0, 12
9D0039C8  94420020   LHU V0, 32(V0)
9D0039CC  0062102B   SLTU V0, V1, V0
9D0039D0  14400007   BNE V0, ZERO, 0x9D0039F0
9D0039D4  00000000   NOP
9D0039E4  3402FFFC   ORI V0, ZERO, -4
9D0039E8  1462000E   BNE V1, V0, 0x9D003A24
9D0039EC  00000000   NOP
309:                                     g.lm63_data_1.fan_speed == LM63_NO_FAN){
9D0039D8  3C02A000   LUI V0, -24576
9D0039DC  2442000C   ADDIU V0, V0, 12
9D0039E0  9443002A   LHU V1, 42(V0)
310:                                     if (g.it_en.fan_slow){
9D0039F0  3C02A000   LUI V0, -24576
9D0039F4  2442000C   ADDIU V0, V0, 12
9D0039F8  8C430048   LW V1, 72(V0)
9D0039FC  3C020800   LUI V0, 2048
9D003A00  00621024   AND V0, V1, V0
9D003A04  10400007   BEQ V0, ZERO, 0x9D003A24
9D003A08  00000000   NOP
311:                                         g.it_cause.fan_slow = 1;
9D003A0C  3C02A000   LUI V0, -24576
9D003A10  2443000C   ADDIU V1, V0, 12
9D003A14  9062004A   LBU V0, 74(V1)
9D003A18  24040001   ADDIU A0, ZERO, 1
9D003A1C  7C8218C4   INS V0, A0, 3, 1
9D003A20  A062004A   SB V0, 74(V1)
312:                                     }
313:                                 }
314:                 
315:                                 #if defined (_PCB5_)
316:                                 if (g.lm63_data_2.fan_speed < g.fan_speed_threshold ||
9D003A24  3C02A000   LUI V0, -24576
9D003A28  2442000C   ADDIU V0, V0, 12
9D003A2C  94430038   LHU V1, 56(V0)
9D003A30  3C02A000   LUI V0, -24576
9D003A34  2442000C   ADDIU V0, V0, 12
9D003A38  94420020   LHU V0, 32(V0)
9D003A3C  0062102B   SLTU V0, V1, V0
9D003A40  14400007   BNE V0, ZERO, 0x9D003A60
9D003A44  00000000   NOP
9D003A54  3402FFFC   ORI V0, ZERO, -4
9D003A58  1462000E   BNE V1, V0, 0x9D003A94
9D003A5C  00000000   NOP
317:                                     g.lm63_data_2.fan_speed == LM63_NO_FAN){
9D003A48  3C02A000   LUI V0, -24576
9D003A4C  2442000C   ADDIU V0, V0, 12
9D003A50  94430038   LHU V1, 56(V0)
318:                                     if (g.it_en.fan_slow){
9D003A60  3C02A000   LUI V0, -24576
9D003A64  2442000C   ADDIU V0, V0, 12
9D003A68  8C430048   LW V1, 72(V0)
9D003A6C  3C020800   LUI V0, 2048
9D003A70  00621024   AND V0, V1, V0
9D003A74  10400007   BEQ V0, ZERO, 0x9D003A94
9D003A78  00000000   NOP
319:                                         g.it_cause.fan_slow = 1;
9D003A7C  3C02A000   LUI V0, -24576
9D003A80  2443000C   ADDIU V1, V0, 12
9D003A84  9062004A   LBU V0, 74(V1)
9D003A88  24040001   ADDIU A0, ZERO, 1
9D003A8C  7C8218C4   INS V0, A0, 3, 1
9D003A90  A062004A   SB V0, 74(V1)
320:                                     }
321:                                 }
322:                                 #endif
323:                             }
324:                         }
325:                 
326:                         //-------------------------------------------------------
327:                         check_input_voltage();
9D003A94  0F400EDE   JAL check_input_voltage
9D003A98  00000000   NOP
328:                 
329:                         //-------------------------------------------------------
330:                         // manage it
331:                         if (g.it_cause.temp_hot  ||
9D003A9C  3C02A000   LUI V0, -24576
9D003AA0  2442000C   ADDIU V0, V0, 12
9D003AA4  8C430048   LW V1, 72(V0)
9D003AA8  3C020002   LUI V0, 2
9D003AAC  00621024   AND V0, V1, V0
9D003AB0  14400024   BNE V0, ZERO, 0x9D003B44
9D003AB4  00000000   NOP
9D003AB8  3C02A000   LUI V0, -24576
9D003ABC  2442000C   ADDIU V0, V0, 12
9D003AC0  8C430048   LW V1, 72(V0)
9D003AC4  3C020001   LUI V0, 1
9D003AC8  00621024   AND V0, V1, V0
9D003ACC  1440001D   BNE V0, ZERO, 0x9D003B44
9D003AD0  00000000   NOP
332:                             g.it_cause.temp_critical ||
9D003AD4  3C02A000   LUI V0, -24576
9D003AD8  2442000C   ADDIU V0, V0, 12
9D003ADC  8C430048   LW V1, 72(V0)
9D003AE0  3C020004   LUI V0, 4
9D003AE4  00621024   AND V0, V1, V0
9D003AE8  14400016   BNE V0, ZERO, 0x9D003B44
9D003AEC  00000000   NOP
333:                             g.it_cause.temp_cold ||
9D003AF0  3C02A000   LUI V0, -24576
9D003AF4  2442000C   ADDIU V0, V0, 12
9D003AF8  8C430048   LW V1, 72(V0)
9D003AFC  3C020008   LUI V0, 8
9D003B00  00621024   AND V0, V1, V0
9D003B04  1440000F   BNE V0, ZERO, 0x9D003B44
9D003B08  00000000   NOP
334:                             g.it_cause.fan_slow  ||
9D003B0C  3C02A000   LUI V0, -24576
9D003B10  2442000C   ADDIU V0, V0, 12
9D003B14  8C430048   LW V1, 72(V0)
9D003B18  3C020010   LUI V0, 16
9D003B1C  00621024   AND V0, V1, V0
9D003B20  14400008   BNE V0, ZERO, 0x9D003B44
9D003B24  00000000   NOP
335:                             g.it_cause.power_sup ||
9D003B28  3C02A000   LUI V0, -24576
9D003B2C  2442000C   ADDIU V0, V0, 12
9D003B30  8C430048   LW V1, 72(V0)
9D003B34  3C020020   LUI V0, 32
9D003B38  00621024   AND V0, V1, V0
9D003B3C  10400008   BEQ V0, ZERO, 0x9D003B60
9D003B40  00000000   NOP
336:                             g.it_cause.low_power)
337:                         {
338:                             PIN_IT_TO_SOC = 1;
9D003B44  3C03BF88   LUI V1, -16504
9D003B48  94626120   LHU V0, 24864(V1)
9D003B4C  24040001   ADDIU A0, ZERO, 1
9D003B50  7C8239C4   INS V0, A0, 7, 1
9D003B54  A4626120   SH V0, 24864(V1)
339:                         }else{
340:                             PIN_IT_TO_SOC = 0;
9D003B60  3C03BF88   LUI V1, -16504
9D003B64  94626120   LHU V0, 24864(V1)
9D003B68  7C0239C4   INS V0, ZERO, 7, 1
9D003B6C  A4626120   SH V0, 24864(V1)
341:                         }
342:                 
343:                     }
9D003B58  0B400D7E   J 0x9D0035F8
9D003B5C  00000000   NOP
9D003B70  0B400D7E   J 0x9D0035F8
9D003B74  00000000   NOP
344:                 
345:                     return 0;
346:                 }
347:                 
348:                 
349:                 
350:                 
351:                 void check_input_voltage()
352:                 {
9D003B78  27BDFFE8   ADDIU SP, SP, -24
9D003B7C  AFBF0014   SW RA, 20(SP)
9D003B80  AFBE0010   SW S8, 16(SP)
9D003B84  03A0F021   ADDU S8, SP, ZERO
353:                     // read input voltage
354:                     adc_conversion(&g.power_in,      ADC_CH2);
9D003B88  3C02A000   LUI V0, -24576
9D003B8C  2444005C   ADDIU A0, V0, 92
9D003B90  24050002   ADDIU A1, ZERO, 2
9D003B94  0F401CC5   JAL adc_conversion
9D003B98  00000000   NOP
355:                 
356:                     if (g.power_in < g.power_in_at_startup - 20)        // adc * 3.3V-q / 1024 * 15.66 (voltage divider) ~= adc * 0.0504
9D003B9C  3C02A000   LUI V0, -24576
9D003BA0  2442000C   ADDIU V0, V0, 12
9D003BA4  8C430050   LW V1, 80(V0)
9D003BA8  3C02A000   LUI V0, -24576
9D003BAC  2442000C   ADDIU V0, V0, 12
9D003BB0  8C42004C   LW V0, 76(V0)
9D003BB4  2442FFEC   ADDIU V0, V0, -20
9D003BB8  0062102B   SLTU V0, V1, V0
9D003BBC  10400012   BEQ V0, ZERO, 0x9D003C08
9D003BC0  00000000   NOP
357:                     {
358:                         if (g.it_en.low_power){
9D003BC4  3C02A000   LUI V0, -24576
9D003BC8  2442000C   ADDIU V0, V0, 12
9D003BCC  8C430048   LW V1, 72(V0)
9D003BD0  3C022000   LUI V0, 8192
9D003BD4  00621024   AND V0, V1, V0
9D003BD8  10400007   BEQ V0, ZERO, 0x9D003BF8
9D003BDC  00000000   NOP
359:                             g.it_cause.low_power = 1;
9D003BE0  3C02A000   LUI V0, -24576
9D003BE4  2443000C   ADDIU V1, V0, 12
9D003BE8  9062004A   LBU V0, 74(V1)
9D003BEC  24040001   ADDIU A0, ZERO, 1
9D003BF0  7C822944   INS V0, A0, 5, 1
9D003BF4  A062004A   SB V0, 74(V1)
360:                         }
361:                 
362:                         INTDisableInterrupts();
9D003BF8  0F402379   JAL INTDisableInterrupts
9D003BFC  00000000   NOP
363:                         power_down_sequence();
9D003C00  0F4014DD   JAL power_down_sequence
9D003C04  00000000   NOP
364:                     }
365:                 }
9D003C08  03C0E821   ADDU SP, S8, ZERO
9D003C0C  8FBF0014   LW RA, 20(SP)
9D003C10  8FBE0010   LW S8, 16(SP)
9D003C14  27BD0018   ADDIU SP, SP, 24
9D003C18  03E00008   JR RA
9D003C1C  00000000   NOP
9D003C20  27BDFFE8   ADDIU SP, SP, -24
---  d:/svn/mgw-ace-enc/trunk/pic32/lm63.c  -------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   19 November 2013                                    &&&
6:                   //&&&   Version     :   v1.0                                                &&&
7:                   //&&&   File        :   lm63.c                                              &&&
8:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9:                   //&&&   Description :   - configure LM63 fan controller                     &&&
10:                  //&&&                   - manages temperature and fan speed                 &&&
11:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
12:                  //&&&   Infos       :   i2c frequency : 100 000 kHz                         &&&
13:                  //&&&                   i2c slave address : 0x4C                            &&&
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  
16:                  #include "lm63.h"
17:                  
18:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
19:                  //------------------------ Init LM63 Controller -------------------------------
20:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
21:                  RESULT lm63_configure (I2C_BUS bus_id)
22:                  {
9D005F94  27BDFFD8   ADDIU SP, SP, -40
9D005F98  AFBF0024   SW RA, 36(SP)
9D005F9C  AFBE0020   SW S8, 32(SP)
9D005FA0  03A0F021   ADDU S8, SP, ZERO
9D005FA4  AFC40028   SW A0, 40(S8)
23:                      RESULT result = SUCCESS;
9D005FA8  AFC00014   SW ZERO, 20(S8)
24:                      u8 tmp;
25:                      u8 error = 0;
9D005FAC  A3C00010   SB ZERO, 16(S8)
26:                  
27:                      // fan pwm and tachometer config
28:                      // - pwm pol : 0=OFF, open_ON
29:                      // - pwm clock : 360 kHz
30:                      // - tacho mode : 00: Traditional tach input monitor, false readings when under minimum detectable RPM
31:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG_FAN,        0x20);     //reg 4A
9D005FB0  8FC40028   LW A0, 40(S8)
9D005FB4  2405004C   ADDIU A1, ZERO, 76
9D005FB8  2406004A   ADDIU A2, ZERO, 74
9D005FBC  24070020   ADDIU A3, ZERO, 32
9D005FC0  0F400AF0   JAL i2c_write_reg
9D005FC4  00000000   NOP
32:                  
33:                      // fan spin-up config
34:                      // - no spin-up
35:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_FAN_SPIN_UP_CFG,   0x00);     //reg 4B
9D005FC8  8FC40028   LW A0, 40(S8)
9D005FCC  2405004C   ADDIU A1, ZERO, 76
9D005FD0  2406004B   ADDIU A2, ZERO, 75
9D005FD4  00003821   ADDU A3, ZERO, ZERO
9D005FD8  0F400AF0   JAL i2c_write_reg
9D005FDC  00000000   NOP
36:                  
37:                      // pwm frequency [5..0]
38:                      // - pwm_freq = pwm_clock / 2n = 7.8kHz, here n is 23
39:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_FREQ,          0x17);     //reg 4D
9D005FE0  8FC40028   LW A0, 40(S8)
9D005FE4  2405004C   ADDIU A1, ZERO, 76
9D005FE8  2406004D   ADDIU A2, ZERO, 77
9D005FEC  24070017   ADDIU A3, ZERO, 23
9D005FF0  0F400AF0   JAL i2c_write_reg
9D005FF4  00000000   NOP
40:                  
41:                      // pwm value [5..0]
42:                      // lm63 will use this value or the look-up table
43:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_VALUE,         0x10);     //reg 4C
9D005FF8  8FC40028   LW A0, 40(S8)
9D005FFC  2405004C   ADDIU A1, ZERO, 76
9D006000  2406004C   ADDIU A2, ZERO, 76
9D006004  24070010   ADDIU A3, ZERO, 16
9D006008  0F400AF0   JAL i2c_write_reg
9D00600C  00000000   NOP
44:                  
45:                      // configuration register
46:                      // - no alert, uses tachometer
47:                      // - normal operation
48:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG1,           0x84);     //reg 03
9D006010  8FC40028   LW A0, 40(S8)
9D006014  2405004C   ADDIU A1, ZERO, 76
9D006018  24060003   ADDIU A2, ZERO, 3
9D00601C  24070084   ADDIU A3, ZERO, 132
9D006020  0F400AF0   JAL i2c_write_reg
9D006024  00000000   NOP
49:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TCRIT,      0x80);
9D006028  8FC40028   LW A0, 40(S8)
9D00602C  2405004C   ADDIU A1, ZERO, 76
9D006030  24060019   ADDIU A2, ZERO, 25
9D006034  24070080   ADDIU A3, ZERO, 128
9D006038  0F400AF0   JAL i2c_write_reg
9D00603C  00000000   NOP
50:                  
51:                      // alert mask
52:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_ALERT_MASK,        0xFF);     // disable all ALERTs
9D006040  8FC40028   LW A0, 40(S8)
9D006044  2405004C   ADDIU A1, ZERO, 76
9D006048  24060016   ADDIU A2, ZERO, 22
9D00604C  240700FF   ADDIU A3, ZERO, 255
9D006050  0F400AF0   JAL i2c_write_reg
9D006054  00000000   NOP
53:                  
54:                      // Setpoint
55:                      i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_HIGH_MSB,   0x80);
9D006058  8FC40028   LW A0, 40(S8)
9D00605C  2405004C   ADDIU A1, ZERO, 76
9D006060  24060007   ADDIU A2, ZERO, 7
9D006064  24070080   ADDIU A3, ZERO, 128
9D006068  0F400AF0   JAL i2c_write_reg
9D00606C  00000000   NOP
56:                  
57:                  
58:                      // check if the chip has been well configured
59:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG_FAN, &tmp);
9D006070  27C20018   ADDIU V0, S8, 24
9D006074  8FC40028   LW A0, 40(S8)
9D006078  2405004C   ADDIU A1, ZERO, 76
9D00607C  2406004A   ADDIU A2, ZERO, 74
9D006080  00403821   ADDU A3, V0, ZERO
9D006084  0F400A9E   JAL i2c_read_reg
9D006088  00000000   NOP
9D00608C  AFC20014   SW V0, 20(S8)
60:                      if (tmp != 0x20 || result != SUCCESS) error++;
9D006090  93C30018   LBU V1, 24(S8)
9D006094  24020020   ADDIU V0, ZERO, 32
9D006098  14620004   BNE V1, V0, 0x9D0060AC
9D00609C  00000000   NOP
9D0060A0  8FC20014   LW V0, 20(S8)
9D0060A4  10400004   BEQ V0, ZERO, 0x9D0060B8
9D0060A8  00000000   NOP
9D0060AC  93C20010   LBU V0, 16(S8)
9D0060B0  24420001   ADDIU V0, V0, 1
9D0060B4  A3C20010   SB V0, 16(S8)
61:                  
62:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_FAN_SPIN_UP_CFG, &tmp);
9D0060B8  27C20018   ADDIU V0, S8, 24
9D0060BC  8FC40028   LW A0, 40(S8)
9D0060C0  2405004C   ADDIU A1, ZERO, 76
9D0060C4  2406004B   ADDIU A2, ZERO, 75
9D0060C8  00403821   ADDU A3, V0, ZERO
9D0060CC  0F400A9E   JAL i2c_read_reg
9D0060D0  00000000   NOP
9D0060D4  AFC20014   SW V0, 20(S8)
63:                      if (tmp != 0x00 || result != SUCCESS) error++;
9D0060D8  93C20018   LBU V0, 24(S8)
9D0060DC  14400004   BNE V0, ZERO, 0x9D0060F0
9D0060E0  00000000   NOP
9D0060E4  8FC20014   LW V0, 20(S8)
9D0060E8  10400004   BEQ V0, ZERO, 0x9D0060FC
9D0060EC  00000000   NOP
9D0060F0  93C20010   LBU V0, 16(S8)
9D0060F4  24420001   ADDIU V0, V0, 1
9D0060F8  A3C20010   SB V0, 16(S8)
64:                  
65:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_FREQ, &tmp);
9D0060FC  27C20018   ADDIU V0, S8, 24
9D006100  8FC40028   LW A0, 40(S8)
9D006104  2405004C   ADDIU A1, ZERO, 76
9D006108  2406004D   ADDIU A2, ZERO, 77
9D00610C  00403821   ADDU A3, V0, ZERO
9D006110  0F400A9E   JAL i2c_read_reg
9D006114  00000000   NOP
9D006118  AFC20014   SW V0, 20(S8)
66:                      if (tmp != 0x17 || result != SUCCESS) error++;
9D00611C  93C30018   LBU V1, 24(S8)
9D006120  24020017   ADDIU V0, ZERO, 23
9D006124  14620004   BNE V1, V0, 0x9D006138
9D006128  00000000   NOP
9D00612C  8FC20014   LW V0, 20(S8)
9D006130  10400004   BEQ V0, ZERO, 0x9D006144
9D006134  00000000   NOP
9D006138  93C20010   LBU V0, 16(S8)
9D00613C  24420001   ADDIU V0, V0, 1
9D006140  A3C20010   SB V0, 16(S8)
67:                  
68:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_VALUE, &tmp);
9D006144  27C20018   ADDIU V0, S8, 24
9D006148  8FC40028   LW A0, 40(S8)
9D00614C  2405004C   ADDIU A1, ZERO, 76
9D006150  2406004C   ADDIU A2, ZERO, 76
9D006154  00403821   ADDU A3, V0, ZERO
9D006158  0F400A9E   JAL i2c_read_reg
9D00615C  00000000   NOP
9D006160  AFC20014   SW V0, 20(S8)
69:                      if (tmp != 0x10 || result != SUCCESS) error++;
9D006164  93C30018   LBU V1, 24(S8)
9D006168  24020010   ADDIU V0, ZERO, 16
9D00616C  14620004   BNE V1, V0, 0x9D006180
9D006170  00000000   NOP
9D006174  8FC20014   LW V0, 20(S8)
9D006178  10400004   BEQ V0, ZERO, 0x9D00618C
9D00617C  00000000   NOP
9D006180  93C20010   LBU V0, 16(S8)
9D006184  24420001   ADDIU V0, V0, 1
9D006188  A3C20010   SB V0, 16(S8)
70:                  
71:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG1, &tmp);
9D00618C  27C20018   ADDIU V0, S8, 24
9D006190  8FC40028   LW A0, 40(S8)
9D006194  2405004C   ADDIU A1, ZERO, 76
9D006198  24060003   ADDIU A2, ZERO, 3
9D00619C  00403821   ADDU A3, V0, ZERO
9D0061A0  0F400A9E   JAL i2c_read_reg
9D0061A4  00000000   NOP
9D0061A8  AFC20014   SW V0, 20(S8)
72:                      if (tmp != 0x84 || result != SUCCESS) error++;
9D0061AC  93C30018   LBU V1, 24(S8)
9D0061B0  24020084   ADDIU V0, ZERO, 132
9D0061B4  14620004   BNE V1, V0, 0x9D0061C8
9D0061B8  00000000   NOP
9D0061BC  8FC20014   LW V0, 20(S8)
9D0061C0  10400004   BEQ V0, ZERO, 0x9D0061D4
9D0061C4  00000000   NOP
9D0061C8  93C20010   LBU V0, 16(S8)
9D0061CC  24420001   ADDIU V0, V0, 1
9D0061D0  A3C20010   SB V0, 16(S8)
73:                  
74:                      if (error != 0)
9D0061D4  93C20010   LBU V0, 16(S8)
9D0061D8  10400004   BEQ V0, ZERO, 0x9D0061EC
9D0061DC  00000000   NOP
75:                          return ERROR;
9D0061E0  24020001   ADDIU V0, ZERO, 1
9D0061E4  0B40187C   J 0x9D0061F0
9D0061E8  00000000   NOP
76:                      else
77:                          return SUCCESS;
9D0061EC  00001021   ADDU V0, ZERO, ZERO
78:                  }
9D0061F0  03C0E821   ADDU SP, S8, ZERO
9D0061F4  8FBF0024   LW RA, 36(SP)
9D0061F8  8FBE0020   LW S8, 32(SP)
9D0061FC  27BD0028   ADDIU SP, SP, 40
9D006200  03E00008   JR RA
9D006204  00000000   NOP
79:                  
80:                  
81:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
82:                  //------------------- Read Temperature from LM63 Die --------------------------
83:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
84:                  RESULT lm63_read_die_temp (I2C_BUS bus_id, u8 *data)
85:                  {
9D006208  27BDFFE0   ADDIU SP, SP, -32
9D00620C  AFBF001C   SW RA, 28(SP)
9D006210  AFBE0018   SW S8, 24(SP)
9D006214  03A0F021   ADDU S8, SP, ZERO
9D006218  AFC40020   SW A0, 32(S8)
9D00621C  AFC50024   SW A1, 36(S8)
86:                      RESULT result;
87:                  
88:                      result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_LOCAL_TEMP, data);
9D006220  8FC40020   LW A0, 32(S8)
9D006224  2405004C   ADDIU A1, ZERO, 76
9D006228  00003021   ADDU A2, ZERO, ZERO
9D00622C  8FC70024   LW A3, 36(S8)
9D006230  0F400A9E   JAL i2c_read_reg
9D006234  00000000   NOP
9D006238  AFC20010   SW V0, 16(S8)
89:                  
90:                      // retry
91:                      if (result != SUCCESS){
9D00623C  8FC20010   LW V0, 16(S8)
9D006240  10400018   BEQ V0, ZERO, 0x9D0062A4
9D006244  00000000   NOP
92:                          delay_ms(1);
9D006248  24040001   ADDIU A0, ZERO, 1
9D00624C  0F40218B   JAL delay_ms
9D006250  00000000   NOP
93:                          result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_LOCAL_TEMP, data);
9D006254  8FC40020   LW A0, 32(S8)
9D006258  2405004C   ADDIU A1, ZERO, 76
9D00625C  00003021   ADDU A2, ZERO, ZERO
9D006260  8FC70024   LW A3, 36(S8)
9D006264  0F400A9E   JAL i2c_read_reg
9D006268  00000000   NOP
9D00626C  AFC20010   SW V0, 16(S8)
94:                  
95:                          // retry
96:                          if (result != SUCCESS){
9D006270  8FC20010   LW V0, 16(S8)
9D006274  1040000B   BEQ V0, ZERO, 0x9D0062A4
9D006278  00000000   NOP
97:                              delay_ms(10);
9D00627C  2404000A   ADDIU A0, ZERO, 10
9D006280  0F40218B   JAL delay_ms
9D006284  00000000   NOP
98:                              result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_LOCAL_TEMP, data);
9D006288  8FC40020   LW A0, 32(S8)
9D00628C  2405004C   ADDIU A1, ZERO, 76
9D006290  00003021   ADDU A2, ZERO, ZERO
9D006294  8FC70024   LW A3, 36(S8)
9D006298  0F400A9E   JAL i2c_read_reg
9D00629C  00000000   NOP
9D0062A0  AFC20010   SW V0, 16(S8)
99:                          }
100:                     }
101:                 
102:                     return result;
9D0062A4  8FC20010   LW V0, 16(S8)
103:                 }
9D0062A8  03C0E821   ADDU SP, S8, ZERO
9D0062AC  8FBF001C   LW RA, 28(SP)
9D0062B0  8FBE0018   LW S8, 24(SP)
9D0062B4  27BD0020   ADDIU SP, SP, 32
9D0062B8  03E00008   JR RA
9D0062BC  00000000   NOP
104:                 
105:                 
106:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
107:                 //------------------- Read Temperature from LM63 Die --------------------------
108:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
109:                 RESULT lm63_read_diode_offset (I2C_BUS bus_id, u8 *msb, u8 *lsb)
110:                 {
9D0062C0  27BDFFE0   ADDIU SP, SP, -32
9D0062C4  AFBF001C   SW RA, 28(SP)
9D0062C8  AFBE0018   SW S8, 24(SP)
9D0062CC  03A0F021   ADDU S8, SP, ZERO
9D0062D0  AFC40020   SW A0, 32(S8)
9D0062D4  AFC50024   SW A1, 36(S8)
9D0062D8  AFC60028   SW A2, 40(S8)
111:                     RESULT result;
112:                 
113:                     result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_OFFSET_MSB, msb);
9D0062DC  8FC40020   LW A0, 32(S8)
9D0062E0  2405004C   ADDIU A1, ZERO, 76
9D0062E4  24060011   ADDIU A2, ZERO, 17
9D0062E8  8FC70024   LW A3, 36(S8)
9D0062EC  0F400A9E   JAL i2c_read_reg
9D0062F0  00000000   NOP
9D0062F4  AFC20010   SW V0, 16(S8)
114:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_OFFSET_LSB, lsb);
9D0062F8  8FC40020   LW A0, 32(S8)
9D0062FC  2405004C   ADDIU A1, ZERO, 76
9D006300  24060012   ADDIU A2, ZERO, 18
9D006304  8FC70028   LW A3, 40(S8)
9D006308  0F400A9E   JAL i2c_read_reg
9D00630C  00000000   NOP
115:                 
116:                     return result;
9D006310  8FC20010   LW V0, 16(S8)
117:                 }
9D006314  03C0E821   ADDU SP, S8, ZERO
9D006318  8FBF001C   LW RA, 28(SP)
9D00631C  8FBE0018   LW S8, 24(SP)
9D006320  27BD0020   ADDIU SP, SP, 32
9D006324  03E00008   JR RA
9D006328  00000000   NOP
118:                 
119:                 
120:                 
121:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
122:                 //------------------- Read Temperature from LM63 Diode --------------------------
123:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
124:                 RESULT lm63_read_diode_temp (I2C_BUS bus_id, u8 *data)
125:                 {
9D00632C  27BDFFE0   ADDIU SP, SP, -32
9D006330  AFBF001C   SW RA, 28(SP)
9D006334  AFBE0018   SW S8, 24(SP)
9D006338  03A0F021   ADDU S8, SP, ZERO
9D00633C  AFC40020   SW A0, 32(S8)
9D006340  AFC50024   SW A1, 36(S8)
126:                     RESULT result;
127:                 
128:                     result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TEMP_MSB, data);
9D006344  8FC40020   LW A0, 32(S8)
9D006348  2405004C   ADDIU A1, ZERO, 76
9D00634C  24060001   ADDIU A2, ZERO, 1
9D006350  8FC70024   LW A3, 36(S8)
9D006354  0F400A9E   JAL i2c_read_reg
9D006358  00000000   NOP
9D00635C  AFC20010   SW V0, 16(S8)
129:                 
130:                     // retry
131:                     if (result != SUCCESS){
9D006360  8FC20010   LW V0, 16(S8)
9D006364  10400018   BEQ V0, ZERO, 0x9D0063C8
9D006368  00000000   NOP
132:                         delay_ms(1);
9D00636C  24040001   ADDIU A0, ZERO, 1
9D006370  0F40218B   JAL delay_ms
9D006374  00000000   NOP
133:                         result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TEMP_MSB, data);
9D006378  8FC40020   LW A0, 32(S8)
9D00637C  2405004C   ADDIU A1, ZERO, 76
9D006380  24060001   ADDIU A2, ZERO, 1
9D006384  8FC70024   LW A3, 36(S8)
9D006388  0F400A9E   JAL i2c_read_reg
9D00638C  00000000   NOP
9D006390  AFC20010   SW V0, 16(S8)
134:                 
135:                         // retry
136:                         if (result != SUCCESS){
9D006394  8FC20010   LW V0, 16(S8)
9D006398  1040000B   BEQ V0, ZERO, 0x9D0063C8
9D00639C  00000000   NOP
137:                             delay_ms(10);
9D0063A0  2404000A   ADDIU A0, ZERO, 10
9D0063A4  0F40218B   JAL delay_ms
9D0063A8  00000000   NOP
138:                             result = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TEMP_MSB, data);
9D0063AC  8FC40020   LW A0, 32(S8)
9D0063B0  2405004C   ADDIU A1, ZERO, 76
9D0063B4  24060001   ADDIU A2, ZERO, 1
9D0063B8  8FC70024   LW A3, 36(S8)
9D0063BC  0F400A9E   JAL i2c_read_reg
9D0063C0  00000000   NOP
9D0063C4  AFC20010   SW V0, 16(S8)
139:                         }
140:                     }
141:                 
142:                     return result;
9D0063C8  8FC20010   LW V0, 16(S8)
143:                 }
9D0063CC  03C0E821   ADDU SP, S8, ZERO
9D0063D0  8FBF001C   LW RA, 28(SP)
9D0063D4  8FBE0018   LW S8, 24(SP)
9D0063D8  27BD0020   ADDIU SP, SP, 32
9D0063DC  03E00008   JR RA
9D0063E0  00000000   NOP
144:                 
145:                 
146:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
147:                 //---------------------- Read Fan Speed from LM63 -----------------------------
148:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
149:                 RESULT lm63_read_speed (I2C_BUS bus_id, u16 *speed)
150:                 {
9D0063E4  27BDFFD8   ADDIU SP, SP, -40
9D0063E8  AFBF0024   SW RA, 36(SP)
9D0063EC  AFBE0020   SW S8, 32(SP)
9D0063F0  03A0F021   ADDU S8, SP, ZERO
9D0063F4  AFC40028   SW A0, 40(S8)
9D0063F8  AFC5002C   SW A1, 44(S8)
151:                     RESULT result1, result2;
152:                 
153:                     u16 speed_old = *speed;
9D0063FC  8FC2002C   LW V0, 44(S8)
9D006400  94420000   LHU V0, 0(V0)
9D006404  A7C20010   SH V0, 16(S8)
154:                 
155:                     u8 lsb = 0;
9D006408  A3C0001C   SB ZERO, 28(S8)
156:                     u8 msb = 0;
9D00640C  A3C0001D   SB ZERO, 29(S8)
157:                 
158:                     result1 = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_COUNT_LSB, &lsb);
9D006410  27C2001C   ADDIU V0, S8, 28
9D006414  8FC40028   LW A0, 40(S8)
9D006418  2405004C   ADDIU A1, ZERO, 76
9D00641C  24060046   ADDIU A2, ZERO, 70
9D006420  00403821   ADDU A3, V0, ZERO
9D006424  0F400A9E   JAL i2c_read_reg
9D006428  00000000   NOP
9D00642C  AFC20014   SW V0, 20(S8)
159:                 
160:                     result2 = i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_COUNT_MSB, &msb);
9D006430  27C2001D   ADDIU V0, S8, 29
9D006434  8FC40028   LW A0, 40(S8)
9D006438  2405004C   ADDIU A1, ZERO, 76
9D00643C  24060047   ADDIU A2, ZERO, 71
9D006440  00403821   ADDU A3, V0, ZERO
9D006444  0F400A9E   JAL i2c_read_reg
9D006448  00000000   NOP
9D00644C  AFC20018   SW V0, 24(S8)
161:                 
162:                     if (result1 != SUCCESS || result2 != SUCCESS){
9D006450  8FC20014   LW V0, 20(S8)
9D006454  14400004   BNE V0, ZERO, 0x9D006468
9D006458  00000000   NOP
9D00645C  8FC20018   LW V0, 24(S8)
9D006460  10400007   BEQ V0, ZERO, 0x9D006480
9D006464  00000000   NOP
163:                         *speed = speed_old;
9D006468  8FC2002C   LW V0, 44(S8)
9D00646C  97C30010   LHU V1, 16(S8)
9D006470  A4430000   SH V1, 0(V0)
164:                         return ERROR;
9D006474  24020001   ADDIU V0, ZERO, 1
9D006478  0B401938   J 0x9D0064E0
9D00647C  00000000   NOP
165:                     }else{
166:                         if (msb == 0 && lsb == 0){
9D006480  93C2001D   LBU V0, 29(S8)
9D006484  14400009   BNE V0, ZERO, 0x9D0064AC
9D006488  00000000   NOP
9D00648C  93C2001C   LBU V0, 28(S8)
9D006490  14400006   BNE V0, ZERO, 0x9D0064AC
9D006494  00000000   NOP
167:                             *speed = speed_old;
9D006498  8FC2002C   LW V0, 44(S8)
9D00649C  97C30010   LHU V1, 16(S8)
9D0064A0  A4430000   SH V1, 0(V0)
9D0064A4  0B401937   J 0x9D0064DC
9D0064A8  00000000   NOP
168:                         }else{
169:                             *speed = (msb<<8) | (lsb&0xFC);
9D0064AC  93C2001D   LBU V0, 29(S8)
9D0064B0  00021200   SLL V0, V0, 8
9D0064B4  7C021E20   SEH V1, V0
9D0064B8  93C2001C   LBU V0, 28(S8)
9D0064BC  7C021620   SEH V0, V0
9D0064C0  304200FC   ANDI V0, V0, 252
9D0064C4  7C021620   SEH V0, V0
9D0064C8  00621025   OR V0, V1, V0
9D0064CC  7C021620   SEH V0, V0
9D0064D0  3043FFFF   ANDI V1, V0, -1
9D0064D4  8FC2002C   LW V0, 44(S8)
9D0064D8  A4430000   SH V1, 0(V0)
170:                         }
171:                         return SUCCESS;
9D0064DC  00001021   ADDU V0, ZERO, ZERO
172:                     }
173:                 }
9D0064E0  03C0E821   ADDU SP, S8, ZERO
9D0064E4  8FBF0024   LW RA, 36(SP)
9D0064E8  8FBE0020   LW S8, 32(SP)
9D0064EC  27BD0028   ADDIU SP, SP, 40
9D0064F0  03E00008   JR RA
9D0064F4  00000000   NOP
174:                 
175:                 
176:                 
177:                 
178:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
179:                 //---------------------- Set the Speed of the Fan -----------------------------
180:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
181:                 RESULT lm63_set_fan_speed (I2C_BUS bus_id, u8 speed)
182:                 {
9D0064F8  27BDFFE8   ADDIU SP, SP, -24
9D0064FC  AFBF0014   SW RA, 20(SP)
9D006500  AFBE0010   SW S8, 16(SP)
9D006504  03A0F021   ADDU S8, SP, ZERO
9D006508  AFC40018   SW A0, 24(S8)
9D00650C  00A01021   ADDU V0, A1, ZERO
9D006510  A3C2001C   SB V0, 28(S8)
183:                     // speed must be within the range 0 to 63
184:                     if (speed > 63){
9D006514  93C2001C   LBU V0, 28(S8)
9D006518  2C420040   SLTIU V0, V0, 64
9D00651C  14400004   BNE V0, ZERO, 0x9D006530
9D006520  00000000   NOP
185:                         return ERROR;
9D006524  24020001   ADDIU V0, ZERO, 1
9D006528  0B401953   J 0x9D00654C
9D00652C  00000000   NOP
186:                     }else{
187:                         return i2c_write_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_VALUE, speed);
9D006530  93C2001C   LBU V0, 28(S8)
9D006534  8FC40018   LW A0, 24(S8)
9D006538  2405004C   ADDIU A1, ZERO, 76
9D00653C  2406004C   ADDIU A2, ZERO, 76
9D006540  00403821   ADDU A3, V0, ZERO
9D006544  0F400AF0   JAL i2c_write_reg
9D006548  00000000   NOP
188:                     }
189:                 }
9D00654C  03C0E821   ADDU SP, S8, ZERO
9D006550  8FBF0014   LW RA, 20(SP)
9D006554  8FBE0010   LW S8, 16(SP)
9D006558  27BD0018   ADDIU SP, SP, 24
9D00655C  03E00008   JR RA
9D006560  00000000   NOP
190:                 
191:                 
192:                 
193:                 
194:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
195:                 //---------------------- Read Fan Speed from LM63 -----------------------------
196:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
197:                 RESULT lm63_update_data (I2C_BUS bus_id, t_lm63_data *l_lm63_data)
198:                 {
9D006564  27BDFFE0   ADDIU SP, SP, -32
9D006568  AFBF001C   SW RA, 28(SP)
9D00656C  AFBE0018   SW S8, 24(SP)
9D006570  03A0F021   ADDU S8, SP, ZERO
9D006574  AFC40020   SW A0, 32(S8)
9D006578  AFC50024   SW A1, 36(S8)
199:                     u8 tmp, tmp2;
200:                 
201:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG1, &tmp);
9D00657C  8FC40020   LW A0, 32(S8)
9D006580  2405004C   ADDIU A1, ZERO, 76
9D006584  24060003   ADDIU A2, ZERO, 3
9D006588  27C20010   ADDIU V0, S8, 16
9D00658C  00403821   ADDU A3, V0, ZERO
9D006590  0F400A9E   JAL i2c_read_reg
9D006594  00000000   NOP
202:                     l_lm63_data->config = tmp;
9D006598  93C30010   LBU V1, 16(S8)
9D00659C  8FC20024   LW V0, 36(S8)
9D0065A0  A0430000   SB V1, 0(V0)
203:                 
204:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_CONFIG_FAN, &tmp);
9D0065A4  8FC40020   LW A0, 32(S8)
9D0065A8  2405004C   ADDIU A1, ZERO, 76
9D0065AC  2406004A   ADDIU A2, ZERO, 74
9D0065B0  27C20010   ADDIU V0, S8, 16
9D0065B4  00403821   ADDU A3, V0, ZERO
9D0065B8  0F400A9E   JAL i2c_read_reg
9D0065BC  00000000   NOP
205:                     l_lm63_data->config_fan = tmp;
9D0065C0  93C30010   LBU V1, 16(S8)
9D0065C4  8FC20024   LW V0, 36(S8)
9D0065C8  A0430001   SB V1, 1(V0)
206:                 
207:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_COUNT_LSB, &tmp);
9D0065CC  8FC40020   LW A0, 32(S8)
9D0065D0  2405004C   ADDIU A1, ZERO, 76
9D0065D4  24060046   ADDIU A2, ZERO, 70
9D0065D8  27C20010   ADDIU V0, S8, 16
9D0065DC  00403821   ADDU A3, V0, ZERO
9D0065E0  0F400A9E   JAL i2c_read_reg
9D0065E4  00000000   NOP
208:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_COUNT_MSB, &tmp2);
9D0065E8  27C20011   ADDIU V0, S8, 17
9D0065EC  8FC40020   LW A0, 32(S8)
9D0065F0  2405004C   ADDIU A1, ZERO, 76
9D0065F4  24060047   ADDIU A2, ZERO, 71
9D0065F8  00403821   ADDU A3, V0, ZERO
9D0065FC  0F400A9E   JAL i2c_read_reg
9D006600  00000000   NOP
209:                     l_lm63_data->fan_speed = (tmp2 << 8) | (tmp & 0xFC);
9D006604  93C20011   LBU V0, 17(S8)
9D006608  00021200   SLL V0, V0, 8
9D00660C  7C021E20   SEH V1, V0
9D006610  93C20010   LBU V0, 16(S8)
9D006614  7C021620   SEH V0, V0
9D006618  304200FC   ANDI V0, V0, 252
9D00661C  7C021620   SEH V0, V0
9D006620  00621025   OR V0, V1, V0
9D006624  7C021620   SEH V0, V0
9D006628  3043FFFF   ANDI V1, V0, -1
9D00662C  8FC20024   LW V0, 36(S8)
9D006630  A4430002   SH V1, 2(V0)
210:                 
211:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_LIMIT_LSB, &tmp);
9D006634  8FC40020   LW A0, 32(S8)
9D006638  2405004C   ADDIU A1, ZERO, 76
9D00663C  24060048   ADDIU A2, ZERO, 72
9D006640  27C20010   ADDIU V0, S8, 16
9D006644  00403821   ADDU A3, V0, ZERO
9D006648  0F400A9E   JAL i2c_read_reg
9D00664C  00000000   NOP
212:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_TACH_LIMIT_MSB, &tmp2);
9D006650  27C20011   ADDIU V0, S8, 17
9D006654  8FC40020   LW A0, 32(S8)
9D006658  2405004C   ADDIU A1, ZERO, 76
9D00665C  24060049   ADDIU A2, ZERO, 73
9D006660  00403821   ADDU A3, V0, ZERO
9D006664  0F400A9E   JAL i2c_read_reg
9D006668  00000000   NOP
213:                     l_lm63_data->fan_limit = (tmp2 << 8) | (tmp & 0xFC);
9D00666C  93C20011   LBU V0, 17(S8)
9D006670  00021200   SLL V0, V0, 8
9D006674  7C021E20   SEH V1, V0
9D006678  93C20010   LBU V0, 16(S8)
9D00667C  7C021620   SEH V0, V0
9D006680  304200FC   ANDI V0, V0, 252
9D006684  7C021620   SEH V0, V0
9D006688  00621025   OR V0, V1, V0
9D00668C  7C021620   SEH V0, V0
9D006690  3043FFFF   ANDI V1, V0, -1
9D006694  8FC20024   LW V0, 36(S8)
9D006698  A4430004   SH V1, 4(V0)
214:                 
215:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_FREQ, &tmp);
9D00669C  8FC40020   LW A0, 32(S8)
9D0066A0  2405004C   ADDIU A1, ZERO, 76
9D0066A4  2406004D   ADDIU A2, ZERO, 77
9D0066A8  27C20010   ADDIU V0, S8, 16
9D0066AC  00403821   ADDU A3, V0, ZERO
9D0066B0  0F400A9E   JAL i2c_read_reg
9D0066B4  00000000   NOP
216:                     l_lm63_data->pwm_freq = tmp;
9D0066B8  93C30010   LBU V1, 16(S8)
9D0066BC  8FC20024   LW V0, 36(S8)
9D0066C0  A0430006   SB V1, 6(V0)
217:                 
218:                     i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_PWM_VALUE, &tmp);
9D0066C4  8FC40020   LW A0, 32(S8)
9D0066C8  2405004C   ADDIU A1, ZERO, 76
9D0066CC  2406004C   ADDIU A2, ZERO, 76
9D0066D0  27C20010   ADDIU V0, S8, 16
9D0066D4  00403821   ADDU A3, V0, ZERO
9D0066D8  0F400A9E   JAL i2c_read_reg
9D0066DC  00000000   NOP
219:                     l_lm63_data->pwm_value = tmp;
9D0066E0  93C30010   LBU V1, 16(S8)
9D0066E4  8FC20024   LW V0, 36(S8)
9D0066E8  A0430007   SB V1, 7(V0)
220:                 
221:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_LOCAL_TEMP, &tmp);
222:                 //    l_lm63_data->temp_die = tmp;
223:                 
224:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_LOCAL_HIGH, &tmp);
225:                 //    l_lm63_data->temp_high = tmp;
226:                 
227:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TCRIT, &tmp);
228:                 //    l_lm63_data->temp_rmt_crit = tmp;
229:                 
230:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TCRIT_HYST, &tmp);
231:                 //    l_lm63_data->temp_rmt_hyst = tmp;
232:                 
233:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_ALERT_STATUS, &tmp);
234:                 //    l_lm63_data->temp_rmt_hyst = tmp & 0x7F; //                                <--- WTF !!!!
235:                 
236:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TEMP_LSB, &tmp);
237:                 //    i2c_read_reg(bus_id, LM63_ADDRESS, LM63_REG_REMOTE_TEMP_MSB, &tmp2);
238:                 //    l_lm63_data->temp_diode = (tmp2 << 8) | tmp;
239:                 
240:                     return SUCCESS;
9D0066EC  00001021   ADDU V0, ZERO, ZERO
241:                 }
9D0066F0  03C0E821   ADDU SP, S8, ZERO
9D0066F4  8FBF001C   LW RA, 28(SP)
9D0066F8  8FBE0018   LW S8, 24(SP)
9D0066FC  27BD0020   ADDIU SP, SP, 32
9D006700  03E00008   JR RA
9D006704  00000000   NOP
9D006708  27BDFFF8   ADDIU SP, SP, -8
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   26 january 2015                                     &&&
6:                   //&&&   Version     :   v1.0                                                &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   //&&&   Description :   - handles LED "power"                               &&&
9:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
10:                  //&&&   Infos       :   - This function is called by the timer 1 interrupt  &&&
11:                  //&&&                     every second                                      &&&
12:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:                  //&&&   Hystory     :                                                       &&&
14:                  //&&&   1.0 - 26/01/2015 - PBL - First release                              &&&
15:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
16:                  
17:                  #include "common.h"
18:                  #include "io_control.h"
19:                  
20:                  extern CONTEXT g;
21:                  
22:                  void toggle_power_led()
23:                  {
9D006708  27BDFFF8   ADDIU SP, SP, -8
9D00670C  AFBE0004   SW S8, 4(SP)
9D006710  03A0F021   ADDU S8, SP, ZERO
24:                      // Pattern definition:
25:                      // 0 = LED OFF
26:                      // 1 = Starting
27:                      // 2 = Updating
28:                      // 3 = Power Good default
29:                      // 4 = Temperature default
30:                      // 5 = Fan default
31:                      // 6 = Input Voltage default
32:                      // 7 = LED ON
33:                  
34:                      static u8 cnt = 0;
35:                  
36:                      switch (g.led_pattern)
9D006714  3C02A000   LUI V0, -24576
9D006718  2442000C   ADDIU V0, V0, 12
9D00671C  8C42007C   LW V0, 124(V0)
9D006720  2C430009   SLTIU V1, V0, 9
9D006724  10600159   BEQ V1, ZERO, 0x9D006C8C
9D006728  00000000   NOP
9D00672C  00021880   SLL V1, V0, 2
9D006730  3C029D00   LUI V0, -25344
9D006734  24426748   ADDIU V0, V0, 26440
9D006738  00621021   ADDU V0, V1, V0
9D00673C  8C420000   LW V0, 0(V0)
9D006740  00400008   JR V0
9D006744  00000000   NOP
37:                      {
38:                          case LED_PATTERN_OFF :
39:                              PIN_LED_POWER = 0;
9D00676C  3C03BF88   LUI V1, -16504
9D006770  94626120   LHU V0, 24864(V1)
9D006774  7C022944   INS V0, ZERO, 5, 1
9D006778  A4626120   SH V0, 24864(V1)
40:                              break;
9D00677C  0B401B24   J 0x9D006C90
9D006780  00000000   NOP
41:                  
42:                          case LED_PATTERN_STARTING :    // 1s=ON 1s=OFF
43:                              PIN_LED_POWER = !PIN_LED_POWER;
9D006784  3C02BF88   LUI V0, -16504
9D006788  8C426120   LW V0, 24864(V0)
9D00678C  30420020   ANDI V0, V0, 32
9D006790  2C420001   SLTIU V0, V0, 1
9D006794  304400FF   ANDI A0, V0, 255
9D006798  3C03BF88   LUI V1, -16504
9D00679C  94626120   LHU V0, 24864(V1)
9D0067A0  7C822944   INS V0, A0, 5, 1
9D0067A4  A4626120   SH V0, 24864(V1)
44:                              break;
9D0067A8  0B401B24   J 0x9D006C90
9D0067AC  00000000   NOP
45:                  
46:                          case LED_PATTERN_UPDATING :    // 3s=ON 1s=OFF
47:                              if (cnt == 0 || cnt == 1 || cnt == 3 || cnt == 4){
9D0067B0  93828019   LBU V0, -32743(GP)
9D0067B4  1040000D   BEQ V0, ZERO, 0x9D0067EC
9D0067B8  00000000   NOP
9D0067BC  93838019   LBU V1, -32743(GP)
9D0067C0  24020001   ADDIU V0, ZERO, 1
9D0067C4  10620009   BEQ V1, V0, 0x9D0067EC
9D0067C8  00000000   NOP
9D0067CC  93838019   LBU V1, -32743(GP)
9D0067D0  24020003   ADDIU V0, ZERO, 3
9D0067D4  10620005   BEQ V1, V0, 0x9D0067EC
9D0067D8  00000000   NOP
9D0067DC  93838019   LBU V1, -32743(GP)
9D0067E0  24020004   ADDIU V0, ZERO, 4
9D0067E4  1462000C   BNE V1, V0, 0x9D006818
9D0067E8  00000000   NOP
48:                                  PIN_LED_POWER = 1;
9D0067EC  3C03BF88   LUI V1, -16504
9D0067F0  94626120   LHU V0, 24864(V1)
9D0067F4  24040001   ADDIU A0, ZERO, 1
9D0067F8  7C822944   INS V0, A0, 5, 1
9D0067FC  A4626120   SH V0, 24864(V1)
49:                                  cnt++;
9D006800  93828019   LBU V0, -32743(GP)
9D006804  24420001   ADDIU V0, V0, 1
9D006808  304200FF   ANDI V0, V0, 255
9D00680C  A3828019   SB V0, -32743(GP)
9D006810  0B401A1B   J 0x9D00686C
9D006814  00000000   NOP
50:                              }else if (cnt == 13){
9D006818  93838019   LBU V1, -32743(GP)
9D00681C  2402000D   ADDIU V0, ZERO, 13
9D006820  14620008   BNE V1, V0, 0x9D006844
9D006824  00000000   NOP
51:                                  PIN_LED_POWER = 0;
9D006828  3C03BF88   LUI V1, -16504
9D00682C  94626120   LHU V0, 24864(V1)
9D006830  7C022944   INS V0, ZERO, 5, 1
9D006834  A4626120   SH V0, 24864(V1)
52:                                  cnt = 0;
9D006838  A3808019   SB ZERO, -32743(GP)
9D00683C  0B401A1B   J 0x9D00686C
9D006840  00000000   NOP
53:                              }else{
54:                                  PIN_LED_POWER = 0;
9D006844  3C03BF88   LUI V1, -16504
9D006848  94626120   LHU V0, 24864(V1)
9D00684C  7C022944   INS V0, ZERO, 5, 1
9D006850  A4626120   SH V0, 24864(V1)
55:                                  cnt++;
9D006854  93828019   LBU V0, -32743(GP)
9D006858  24420001   ADDIU V0, V0, 1
9D00685C  304200FF   ANDI V0, V0, 255
9D006860  A3828019   SB V0, -32743(GP)
56:                              }
57:                              break;
9D006864  0B401B24   J 0x9D006C90
9D006868  00000000   NOP
9D00686C  0B401B24   J 0x9D006C90
9D006870  00000000   NOP
58:                  
59:                          case LED_PATTERN_PWR_DEFAULT :    // 3s=ON 1s=OFF 1s=ON 1s=OFF
60:                              if (cnt == 0 || cnt == 1 || cnt == 2 || cnt == 4){
9D006874  93828019   LBU V0, -32743(GP)
9D006878  1040000D   BEQ V0, ZERO, 0x9D0068B0
9D00687C  00000000   NOP
9D006880  93838019   LBU V1, -32743(GP)
9D006884  24020001   ADDIU V0, ZERO, 1
9D006888  10620009   BEQ V1, V0, 0x9D0068B0
9D00688C  00000000   NOP
9D006890  93838019   LBU V1, -32743(GP)
9D006894  24020002   ADDIU V0, ZERO, 2
9D006898  10620005   BEQ V1, V0, 0x9D0068B0
9D00689C  00000000   NOP
9D0068A0  93838019   LBU V1, -32743(GP)
9D0068A4  24020004   ADDIU V0, ZERO, 4
9D0068A8  1462000C   BNE V1, V0, 0x9D0068DC
9D0068AC  00000000   NOP
61:                                  PIN_LED_POWER = 1;
9D0068B0  3C03BF88   LUI V1, -16504
9D0068B4  94626120   LHU V0, 24864(V1)
9D0068B8  24040001   ADDIU A0, ZERO, 1
9D0068BC  7C822944   INS V0, A0, 5, 1
9D0068C0  A4626120   SH V0, 24864(V1)
62:                                  cnt++;
9D0068C4  93828019   LBU V0, -32743(GP)
9D0068C8  24420001   ADDIU V0, V0, 1
9D0068CC  304200FF   ANDI V0, V0, 255
9D0068D0  A3828019   SB V0, -32743(GP)
9D0068D4  0B401A4C   J 0x9D006930
9D0068D8  00000000   NOP
63:                              }else if (cnt == 3){
9D0068DC  93838019   LBU V1, -32743(GP)
9D0068E0  24020003   ADDIU V0, ZERO, 3
9D0068E4  1462000B   BNE V1, V0, 0x9D006914
9D0068E8  00000000   NOP
64:                                  PIN_LED_POWER = 0;
9D0068EC  3C03BF88   LUI V1, -16504
9D0068F0  94626120   LHU V0, 24864(V1)
9D0068F4  7C022944   INS V0, ZERO, 5, 1
9D0068F8  A4626120   SH V0, 24864(V1)
65:                                  cnt++;
9D0068FC  93828019   LBU V0, -32743(GP)
9D006900  24420001   ADDIU V0, V0, 1
9D006904  304200FF   ANDI V0, V0, 255
9D006908  A3828019   SB V0, -32743(GP)
9D00690C  0B401A4C   J 0x9D006930
9D006910  00000000   NOP
66:                              }else{
67:                                  PIN_LED_POWER = 0;
9D006914  3C03BF88   LUI V1, -16504
9D006918  94626120   LHU V0, 24864(V1)
9D00691C  7C022944   INS V0, ZERO, 5, 1
9D006920  A4626120   SH V0, 24864(V1)
68:                                  cnt=0;
9D006924  A3808019   SB ZERO, -32743(GP)
69:                              }
70:                              break;
9D006928  0B401B24   J 0x9D006C90
9D00692C  00000000   NOP
9D006930  0B401B24   J 0x9D006C90
9D006934  00000000   NOP
71:                  
72:                          case LED_PATTERN_TEMP_DEFAULT :    // 3s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF
73:                              if (cnt == 0 || cnt == 1 || cnt == 2 || cnt == 4 || cnt == 6){
9D006938  93828019   LBU V0, -32743(GP)
9D00693C  10400011   BEQ V0, ZERO, 0x9D006984
9D006940  00000000   NOP
9D006944  93838019   LBU V1, -32743(GP)
9D006948  24020001   ADDIU V0, ZERO, 1
9D00694C  1062000D   BEQ V1, V0, 0x9D006984
9D006950  00000000   NOP
9D006954  93838019   LBU V1, -32743(GP)
9D006958  24020002   ADDIU V0, ZERO, 2
9D00695C  10620009   BEQ V1, V0, 0x9D006984
9D006960  00000000   NOP
9D006964  93838019   LBU V1, -32743(GP)
9D006968  24020004   ADDIU V0, ZERO, 4
9D00696C  10620005   BEQ V1, V0, 0x9D006984
9D006970  00000000   NOP
9D006974  93838019   LBU V1, -32743(GP)
9D006978  24020006   ADDIU V0, ZERO, 6
9D00697C  1462000C   BNE V1, V0, 0x9D0069B0
9D006980  00000000   NOP
74:                                  PIN_LED_POWER = 1;
9D006984  3C03BF88   LUI V1, -16504
9D006988  94626120   LHU V0, 24864(V1)
9D00698C  24040001   ADDIU A0, ZERO, 1
9D006990  7C822944   INS V0, A0, 5, 1
9D006994  A4626120   SH V0, 24864(V1)
75:                                  cnt++;
9D006998  93828019   LBU V0, -32743(GP)
9D00699C  24420001   ADDIU V0, V0, 1
9D0069A0  304200FF   ANDI V0, V0, 255
9D0069A4  A3828019   SB V0, -32743(GP)
9D0069A8  0B401A85   J 0x9D006A14
9D0069AC  00000000   NOP
76:                              }else if (cnt == 3 || cnt == 5){
9D0069B0  93838019   LBU V1, -32743(GP)
9D0069B4  24020003   ADDIU V0, ZERO, 3
9D0069B8  10620005   BEQ V1, V0, 0x9D0069D0
9D0069BC  00000000   NOP
9D0069C0  93838019   LBU V1, -32743(GP)
9D0069C4  24020005   ADDIU V0, ZERO, 5
9D0069C8  1462000B   BNE V1, V0, 0x9D0069F8
9D0069CC  00000000   NOP
77:                                  PIN_LED_POWER = 0;
9D0069D0  3C03BF88   LUI V1, -16504
9D0069D4  94626120   LHU V0, 24864(V1)
9D0069D8  7C022944   INS V0, ZERO, 5, 1
9D0069DC  A4626120   SH V0, 24864(V1)
78:                                  cnt++;
9D0069E0  93828019   LBU V0, -32743(GP)
9D0069E4  24420001   ADDIU V0, V0, 1
9D0069E8  304200FF   ANDI V0, V0, 255
9D0069EC  A3828019   SB V0, -32743(GP)
9D0069F0  0B401A85   J 0x9D006A14
9D0069F4  00000000   NOP
79:                              }else{
80:                                  PIN_LED_POWER = 0;
9D0069F8  3C03BF88   LUI V1, -16504
9D0069FC  94626120   LHU V0, 24864(V1)
9D006A00  7C022944   INS V0, ZERO, 5, 1
9D006A04  A4626120   SH V0, 24864(V1)
81:                                  cnt=0;
9D006A08  A3808019   SB ZERO, -32743(GP)
82:                              }
83:                              break;
9D006A0C  0B401B24   J 0x9D006C90
9D006A10  00000000   NOP
9D006A14  0B401B24   J 0x9D006C90
9D006A18  00000000   NOP
84:                  
85:                          case LED_PATTERN_FAN_DEFAULT :    // 3s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF
86:                              if (cnt == 0 || cnt == 1 || cnt == 2 || cnt == 4 || cnt == 6 || cnt == 8){
9D006A1C  93828019   LBU V0, -32743(GP)
9D006A20  10400015   BEQ V0, ZERO, 0x9D006A78
9D006A24  00000000   NOP
9D006A28  93838019   LBU V1, -32743(GP)
9D006A2C  24020001   ADDIU V0, ZERO, 1
9D006A30  10620011   BEQ V1, V0, 0x9D006A78
9D006A34  00000000   NOP
9D006A38  93838019   LBU V1, -32743(GP)
9D006A3C  24020002   ADDIU V0, ZERO, 2
9D006A40  1062000D   BEQ V1, V0, 0x9D006A78
9D006A44  00000000   NOP
9D006A48  93838019   LBU V1, -32743(GP)
9D006A4C  24020004   ADDIU V0, ZERO, 4
9D006A50  10620009   BEQ V1, V0, 0x9D006A78
9D006A54  00000000   NOP
9D006A58  93838019   LBU V1, -32743(GP)
9D006A5C  24020006   ADDIU V0, ZERO, 6
9D006A60  10620005   BEQ V1, V0, 0x9D006A78
9D006A64  00000000   NOP
9D006A68  93838019   LBU V1, -32743(GP)
9D006A6C  24020008   ADDIU V0, ZERO, 8
9D006A70  1462000C   BNE V1, V0, 0x9D006AA4
9D006A74  00000000   NOP
87:                                  PIN_LED_POWER = 1;
9D006A78  3C03BF88   LUI V1, -16504
9D006A7C  94626120   LHU V0, 24864(V1)
9D006A80  24040001   ADDIU A0, ZERO, 1
9D006A84  7C822944   INS V0, A0, 5, 1
9D006A88  A4626120   SH V0, 24864(V1)
88:                                  cnt++;
9D006A8C  93828019   LBU V0, -32743(GP)
9D006A90  24420001   ADDIU V0, V0, 1
9D006A94  304200FF   ANDI V0, V0, 255
9D006A98  A3828019   SB V0, -32743(GP)
9D006A9C  0B401AC6   J 0x9D006B18
9D006AA0  00000000   NOP
89:                              }else if (cnt == 3 || cnt == 5 || cnt == 7){
9D006AA4  93838019   LBU V1, -32743(GP)
9D006AA8  24020003   ADDIU V0, ZERO, 3
9D006AAC  10620009   BEQ V1, V0, 0x9D006AD4
9D006AB0  00000000   NOP
9D006AB4  93838019   LBU V1, -32743(GP)
9D006AB8  24020005   ADDIU V0, ZERO, 5
9D006ABC  10620005   BEQ V1, V0, 0x9D006AD4
9D006AC0  00000000   NOP
9D006AC4  93838019   LBU V1, -32743(GP)
9D006AC8  24020007   ADDIU V0, ZERO, 7
9D006ACC  1462000B   BNE V1, V0, 0x9D006AFC
9D006AD0  00000000   NOP
90:                                  PIN_LED_POWER = 0;
9D006AD4  3C03BF88   LUI V1, -16504
9D006AD8  94626120   LHU V0, 24864(V1)
9D006ADC  7C022944   INS V0, ZERO, 5, 1
9D006AE0  A4626120   SH V0, 24864(V1)
91:                                  cnt++;
9D006AE4  93828019   LBU V0, -32743(GP)
9D006AE8  24420001   ADDIU V0, V0, 1
9D006AEC  304200FF   ANDI V0, V0, 255
9D006AF0  A3828019   SB V0, -32743(GP)
9D006AF4  0B401AC6   J 0x9D006B18
9D006AF8  00000000   NOP
92:                              }else{
93:                                  PIN_LED_POWER = 0;
9D006AFC  3C03BF88   LUI V1, -16504
9D006B00  94626120   LHU V0, 24864(V1)
9D006B04  7C022944   INS V0, ZERO, 5, 1
9D006B08  A4626120   SH V0, 24864(V1)
94:                                  cnt=0;
9D006B0C  A3808019   SB ZERO, -32743(GP)
95:                              }
96:                              break;
9D006B10  0B401B24   J 0x9D006C90
9D006B14  00000000   NOP
9D006B18  0B401B24   J 0x9D006C90
9D006B1C  00000000   NOP
97:                  
98:                          case LED_PATTERN_PWR_IN_DEFAULT :    // 3s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF 1s=ON 1s=OFF
99:                              if (cnt == 0 || cnt == 1 || cnt == 2 || cnt == 4 || cnt == 6 || cnt == 8 || cnt == 10){
9D006B20  93828019   LBU V0, -32743(GP)
9D006B24  10400019   BEQ V0, ZERO, 0x9D006B8C
9D006B28  00000000   NOP
9D006B2C  93838019   LBU V1, -32743(GP)
9D006B30  24020001   ADDIU V0, ZERO, 1
9D006B34  10620015   BEQ V1, V0, 0x9D006B8C
9D006B38  00000000   NOP
9D006B3C  93838019   LBU V1, -32743(GP)
9D006B40  24020002   ADDIU V0, ZERO, 2
9D006B44  10620011   BEQ V1, V0, 0x9D006B8C
9D006B48  00000000   NOP
9D006B4C  93838019   LBU V1, -32743(GP)
9D006B50  24020004   ADDIU V0, ZERO, 4
9D006B54  1062000D   BEQ V1, V0, 0x9D006B8C
9D006B58  00000000   NOP
9D006B5C  93838019   LBU V1, -32743(GP)
9D006B60  24020006   ADDIU V0, ZERO, 6
9D006B64  10620009   BEQ V1, V0, 0x9D006B8C
9D006B68  00000000   NOP
9D006B6C  93838019   LBU V1, -32743(GP)
9D006B70  24020008   ADDIU V0, ZERO, 8
9D006B74  10620005   BEQ V1, V0, 0x9D006B8C
9D006B78  00000000   NOP
9D006B7C  93838019   LBU V1, -32743(GP)
9D006B80  2402000A   ADDIU V0, ZERO, 10
9D006B84  1462000C   BNE V1, V0, 0x9D006BB8
9D006B88  00000000   NOP
100:                                 PIN_LED_POWER = 1;
9D006B8C  3C03BF88   LUI V1, -16504
9D006B90  94626120   LHU V0, 24864(V1)
9D006B94  24040001   ADDIU A0, ZERO, 1
9D006B98  7C822944   INS V0, A0, 5, 1
9D006B9C  A4626120   SH V0, 24864(V1)
101:                                 cnt++;
9D006BA0  93828019   LBU V0, -32743(GP)
9D006BA4  24420001   ADDIU V0, V0, 1
9D006BA8  304200FF   ANDI V0, V0, 255
9D006BAC  A3828019   SB V0, -32743(GP)
9D006BB0  0B401B0F   J 0x9D006C3C
9D006BB4  00000000   NOP
102:                             }else if (cnt == 3 || cnt == 5 || cnt == 7 || cnt == 9){
9D006BB8  93838019   LBU V1, -32743(GP)
9D006BBC  24020003   ADDIU V0, ZERO, 3
9D006BC0  1062000D   BEQ V1, V0, 0x9D006BF8
9D006BC4  00000000   NOP
9D006BC8  93838019   LBU V1, -32743(GP)
9D006BCC  24020005   ADDIU V0, ZERO, 5
9D006BD0  10620009   BEQ V1, V0, 0x9D006BF8
9D006BD4  00000000   NOP
9D006BD8  93838019   LBU V1, -32743(GP)
9D006BDC  24020007   ADDIU V0, ZERO, 7
9D006BE0  10620005   BEQ V1, V0, 0x9D006BF8
9D006BE4  00000000   NOP
9D006BE8  93838019   LBU V1, -32743(GP)
9D006BEC  24020009   ADDIU V0, ZERO, 9
9D006BF0  1462000B   BNE V1, V0, 0x9D006C20
9D006BF4  00000000   NOP
103:                                 PIN_LED_POWER = 0;
9D006BF8  3C03BF88   LUI V1, -16504
9D006BFC  94626120   LHU V0, 24864(V1)
9D006C00  7C022944   INS V0, ZERO, 5, 1
9D006C04  A4626120   SH V0, 24864(V1)
104:                                 cnt++;
9D006C08  93828019   LBU V0, -32743(GP)
9D006C0C  24420001   ADDIU V0, V0, 1
9D006C10  304200FF   ANDI V0, V0, 255
9D006C14  A3828019   SB V0, -32743(GP)
9D006C18  0B401B0F   J 0x9D006C3C
9D006C1C  00000000   NOP
105:                             }else{
106:                                 PIN_LED_POWER = 0;
9D006C20  3C03BF88   LUI V1, -16504
9D006C24  94626120   LHU V0, 24864(V1)
9D006C28  7C022944   INS V0, ZERO, 5, 1
9D006C2C  A4626120   SH V0, 24864(V1)
107:                                 cnt=0;
9D006C30  A3808019   SB ZERO, -32743(GP)
108:                             }
109:                             break;
9D006C34  0B401B24   J 0x9D006C90
9D006C38  00000000   NOP
9D006C3C  0B401B24   J 0x9D006C90
9D006C40  00000000   NOP
110:                 
111:                         case LED_PATTERN_ON :
112:                             PIN_LED_POWER = 1;
9D006C44  3C03BF88   LUI V1, -16504
9D006C48  94626120   LHU V0, 24864(V1)
9D006C4C  24040001   ADDIU A0, ZERO, 1
9D006C50  7C822944   INS V0, A0, 5, 1
9D006C54  A4626120   SH V0, 24864(V1)
113:                             break;
9D006C58  0B401B24   J 0x9D006C90
9D006C5C  00000000   NOP
114:                 
115:                         case LED_PATTERN_POWERING_DOWN :
116:                             PIN_LED_POWER = !PIN_LED_POWER;
9D006C60  3C02BF88   LUI V0, -16504
9D006C64  8C426120   LW V0, 24864(V0)
9D006C68  30420020   ANDI V0, V0, 32
9D006C6C  2C420001   SLTIU V0, V0, 1
9D006C70  304400FF   ANDI A0, V0, 255
9D006C74  3C03BF88   LUI V1, -16504
9D006C78  94626120   LHU V0, 24864(V1)
9D006C7C  7C822944   INS V0, A0, 5, 1
9D006C80  A4626120   SH V0, 24864(V1)
117:                             break;
9D006C84  0B401B24   J 0x9D006C90
9D006C88  00000000   NOP
118:                 
119:                         default :
120:                             break;
9D006C8C  00000000   NOP
121:                     }
122:                 
123:                 }
9D006C90  03C0E821   ADDU SP, S8, ZERO
9D006C94  8FBE0004   LW S8, 4(SP)
9D006C98  27BD0008   ADDIU SP, SP, 8
9D006C9C  03E00008   JR RA
9D006CA0  00000000   NOP
9D006CA4  27BDFFF8   ADDIU SP, SP, -8
---  d:/svn/mgw-ace-enc/trunk/pic32/io_control.c  -------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   04 November 2013                                    &&&
6:                   //&&&   Version     :   v1.0                                                &&&
7:                   //&&&   File        :   io_control.c                                        &&&
8:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9:                   //&&&   Description :   Controls IO                                         &&&
10:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:                  
12:                  #include "io_control.h"
13:                  
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  //--------------------------- Configuration of IO -----------------------------
16:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
17:                  void gpio_init()
18:                  {
9D0075C4  27BDFFF8   ADDIU SP, SP, -8
9D0075C8  AFBE0004   SW S8, 4(SP)
9D0075CC  03A0F021   ADDU S8, SP, ZERO
19:                      // PORT A  ================================================================
20:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
21:                      PORT_A_SET_DIGITAL_OUT(BIT_PWR_EN_3V3 | BIT_PWR_EN_5V);
22:                      PORT_A_CLEAR_BITS     (BIT_PWR_EN_3V3 | BIT_PWR_EN_5V);
23:                  #elif defined (_PCB5_)
24:                      PORT_A_SET_DIGITAL_IN (BIT_TEMP_ALERT_2 | BIT_TEMP_ALERT_3);
9D0075D0  3C02BF88   LUI V0, -16504
9D0075D4  24030030   ADDIU V1, ZERO, 48
9D0075D8  AC436008   SW V1, 24584(V0)
25:                      PORT_A_SET_DIGITAL_OUT(BIT_SOC_RSTN | BIT_PWR_EN_5V);
9D0075DC  3C02BF88   LUI V0, -16504
9D0075E0  24030280   ADDIU V1, ZERO, 640
9D0075E4  AC436004   SW V1, 24580(V0)
26:                      PORT_A_CLEAR_BITS     (BIT_PWR_EN_5V | BIT_SOC_RSTN);
9D0075E8  3C02BF88   LUI V0, -16504
9D0075EC  24030280   ADDIU V1, ZERO, 640
9D0075F0  AC436024   SW V1, 24612(V0)
27:                  #endif
28:                  
29:                  
30:                      // PORT B  ================================================================
31:                  #if defined (_PCB1_)
32:                      PORT_B_SET_ANALOG_IN  (BIT_ADC_POWER_IN);
33:                      PORT_B_SET_DIGITAL_OUT(BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_VM4400_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
34:                      PORT_B_CLEAR_BITS     (BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_VM4400_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
35:                  #elif defined (_PCB2_)
36:                      PORT_B_SET_ANALOG_IN  (BIT_ADC_POWER_IN);
37:                      PORT_B_SET_DIGITAL_OUT(BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
38:                      PORT_B_CLEAR_BITS     (BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
39:                  #elif defined (_PCB3_) || defined (_PCB4_)
40:                      PORT_B_SET_ANALOG_IN  (BIT_ADC_POWER_IN | BIT_ARRIA_0V9 | BIT_ARRIA_1V8);
41:                      PORT_B_SET_DIGITAL_OUT(BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
42:                      PORT_B_CLEAR_BITS     (BIT_TLV320_B_RSTN | BIT_TLV320_A_RSTN | BIT_ANX_HDMI_RSTN | BIT_ANX_DVI_RSTN | BIT_CVBS_RSTN | BIT_SOC_RSTN);
43:                  #elif defined (_PCB5_)
44:                      PORT_B_SET_ANALOG_IN  (BIT_ADC_POWER_IN | BIT_ADC_0V9_IO | BIT_ADC_1V5 | BIT_ADC_1V8 | BIT_ADC_3V3 | BIT_ADC_1V1 | BIT_ADC_0V9_ENC | BIT_ADC_1V0 | BIT_ADC_0V9_CPU);
9D0075F4  3C02BF88   LUI V0, -16504
9D0075F8  240307FC   ADDIU V1, ZERO, 2044
9D0075FC  AC436048   SW V1, 24648(V0)
9D007600  3C02BF81   LUI V0, -16511
9D007604  240307FC   ADDIU V1, ZERO, 2044
9D007608  AC439064   SW V1, -28572(V0)
45:                      PORT_B_SET_DIGITAL_OUT(BIT_ANX_DVI_RSTN | BIT_ANX_HDMI_RSTN | BIT_TLV320_A_RSTN | BIT_TLV320_B_RSTN);
9D00760C  3C02BF88   LUI V0, -16504
9D007610  3403F000   ORI V1, ZERO, -4096
9D007614  AC436044   SW V1, 24644(V0)
9D007618  3C02BF81   LUI V0, -16511
9D00761C  3403F000   ORI V1, ZERO, -4096
9D007620  AC439068   SW V1, -28568(V0)
46:                      PORT_B_CLEAR_BITS     (BIT_ANX_DVI_RSTN | BIT_ANX_HDMI_RSTN | BIT_TLV320_A_RSTN | BIT_TLV320_B_RSTN);
9D007624  3C02BF88   LUI V0, -16504
9D007628  3403F000   ORI V1, ZERO, -4096
9D00762C  AC436064   SW V1, 24676(V0)
47:                  #endif
48:                  
49:                  
50:                      // PORT C  ================================================================
51:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
52:                      PORT_C_SET_DIGITAL_OUT(BIT_PWR_ARRIA_DIS_2 | BIT_PWR_ARRIA_DIS_3);
53:                      PORT_C_CLEAR_BITS     (BIT_PWR_ARRIA_DIS_2 | BIT_PWR_ARRIA_DIS_3);
54:                  #elif defined (_PCB5_)
55:                      PORT_C_SET_DIGITAL_OUT(BIT_PWR_DIS_1V8 | BIT_PWR_DIS_1V5 | BIT_PWR_DIS_0V9_ENC | BIT_PWR_DIS_3V3 | BIT_PWR_EN_0V75 | BIT_PWR_EN_0V9_CPU);
9D007630  3C02BF88   LUI V0, -16504
9D007634  2403601E   ADDIU V1, ZERO, 24606
9D007638  AC436084   SW V1, 24708(V0)
56:                      PORT_C_CLEAR_BITS     (BIT_PWR_DIS_1V8 | BIT_PWR_DIS_1V5 | BIT_PWR_DIS_0V9_ENC | BIT_PWR_DIS_3V3 | BIT_PWR_EN_0V75 | BIT_PWR_EN_0V9_CPU);
9D00763C  3C02BF88   LUI V0, -16504
9D007640  2403601E   ADDIU V1, ZERO, 24606
9D007644  AC4360A4   SW V1, 24740(V0)
57:                  #endif
58:                  
59:                      
60:                      // PORT D  ================================================================
61:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
62:                      PORT_D_SET_DIGITAL_IN (BIT_PWR_GD_1V2_ECP3 | BIT_CVBS_PWDN | BIT_PWR_GD_0V9_ARRIA);
63:                      PORT_D_SET_DIGITAL_OUT(BIT_FAN_PWM | BIT_PWR_RES_TR | BIT_PWR_RES_BM | BIT_PWR_RES_TL | BIT_PWR_GD_1V2_ECP3 | BIT_PWR_EN_ARRIA_1 | BIT_PWR_EN_ARRIA_2 | BIT_PWR_EN_ARRIA_3 | BIT_PWR_EN_1V05 | BIT_PWR_EN_1V);
64:                      PORT_D_CLEAR_BITS     (BIT_FAN_PWM | BIT_PWR_RES_TR | BIT_PWR_RES_BM | BIT_PWR_RES_TL | BIT_PWR_GD_1V2_ECP3 | BIT_PWR_EN_ARRIA_1 | BIT_PWR_EN_ARRIA_2 | BIT_PWR_EN_ARRIA_3 | BIT_PWR_EN_1V05 | BIT_PWR_EN_1V);
65:                  #elif defined (_PCB5_)
66:                      PORT_D_SET_DIGITAL_IN (BIT_PWR_GD_0V9_ENC | BIT_PWR_GD_0V9_IO);
9D007648  3C02BF88   LUI V0, -16504
9D00764C  24030C00   ADDIU V1, ZERO, 3072
9D007650  AC4360C8   SW V1, 24776(V0)
67:                      PORT_D_SET_DIGITAL_OUT(BIT_FAN_PWM | BIT_PWR_EN_1V1_CPU | BIT_PWR_EN_3V3 | BIT_PWR_EN_0V9_IO | BIT_PWR_EN_0V9_ENC | BIT_PWR_EN_1V05 | BIT_PWR_EN_1V0 | BIT_PWR_EN_1V8_DLY | BIT_PWR_EN_1V5 | BIT_PWR_EN_1V8 | BIT_CVBS_RSTN);
9D007654  3C02BF88   LUI V0, -16504
9D007658  3403B1FD   ORI V1, ZERO, -19971
9D00765C  AC4360C4   SW V1, 24772(V0)
68:                      PORT_D_CLEAR_BITS     (BIT_FAN_PWM | BIT_PWR_EN_1V1_CPU | BIT_PWR_EN_3V3 | BIT_PWR_EN_0V9_IO | BIT_PWR_EN_0V9_ENC | BIT_PWR_EN_1V05 | BIT_PWR_EN_1V0 | BIT_PWR_EN_1V8_DLY | BIT_PWR_EN_1V5 | BIT_PWR_EN_1V8 | BIT_CVBS_RSTN);
9D007660  3C02BF88   LUI V0, -16504
9D007664  3403B1FD   ORI V1, ZERO, -19971
9D007668  AC4360E4   SW V1, 24804(V0)
69:                  #endif
70:                  
71:                  
72:                      // PORT E  ================================================================
73:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
74:                      PORT_E_SET_DIGITAL_IN (BIT_PWR_GD_1V | BIT_PWR_GD_1V05 | BIT_PWR_GD_1V8 | BIT_PWR_GD_3V3 | BIT_PWR_GD_5V);
75:                      PORT_E_SET_DIGITAL_OUT(BIT_LED_POWER | BIT_PWR_ARRIA_DIS_1 | BIT_IT_TO_SOC | BIT_DIR9001_1_RSTN | BIT_DIR9001_2_RSTN);
76:                      PORT_E_CLEAR_BITS     (BIT_LED_POWER | BIT_PWR_ARRIA_DIS_1 | BIT_IT_TO_SOC | BIT_DIR9001_1_RSTN | BIT_DIR9001_2_RSTN);
77:                  #elif defined (_PCB5_)
78:                      PORT_E_SET_DIGITAL_IN (BIT_PWR_GD_1V0 | BIT_PWR_GD_1V05 | BIT_PWR_GD_1V8 | BIT_PWR_GD_3V3 | BIT_PWR_GD_5V);
9D00766C  3C02BF88   LUI V0, -16504
9D007670  2403001F   ADDIU V1, ZERO, 31
9D007674  AC436108   SW V1, 24840(V0)
79:                      PORT_E_SET_DIGITAL_OUT(BIT_LED_POWER | BIT_PWR_DIS_0V9_IO | BIT_IT_TO_SOC | BIT_DIR9001_1_RSTN | BIT_DIR9001_2_RSTN);
9D007678  3C02BF88   LUI V0, -16504
9D00767C  240303E0   ADDIU V1, ZERO, 992
9D007680  AC436104   SW V1, 24836(V0)
80:                      PORT_E_CLEAR_BITS     (BIT_LED_POWER | BIT_PWR_DIS_0V9_IO | BIT_IT_TO_SOC | BIT_DIR9001_1_RSTN | BIT_DIR9001_2_RSTN);
9D007684  3C02BF88   LUI V0, -16504
9D007688  240303E0   ADDIU V1, ZERO, 992
9D00768C  AC436124   SW V1, 24868(V0)
81:                  #endif
82:                  
83:                      
84:                      // PORT F  ================================================================
85:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
86:                      PORT_F_SET_DIGITAL_IN (BIT_TEMP_ALERT_3 | BIT_TEMP_ALERT_4 | BIT_TEMP_ALERT_2);
87:                      PORT_F_SET_DIGITAL_OUT(BIT_PWR_EN_1V2 | BIT_PWR_EN_1V35);
88:                      PORT_F_CLEAR_BITS     (BIT_PWR_EN_1V2 | BIT_PWR_EN_1V35);
89:                  #elif defined (_PCB5_)
90:                      PORT_F_SET_DIGITAL_IN (BIT_TEMP_ALERT_4);
9D007690  3C02BF88   LUI V0, -16504
9D007694  24030008   ADDIU V1, ZERO, 8
9D007698  AC436148   SW V1, 24904(V0)
91:                      PORT_F_SET_DIGITAL_OUT(BIT_PWR_EN_FAN | BIT_PWR_EN_12V);
9D00769C  3C02BF88   LUI V0, -16504
9D0076A0  24030003   ADDIU V1, ZERO, 3
9D0076A4  AC436144   SW V1, 24900(V0)
92:                      PORT_F_CLEAR_BITS     (BIT_PWR_EN_FAN | BIT_PWR_EN_12V);
9D0076A8  3C02BF88   LUI V0, -16504
9D0076AC  24030003   ADDIU V1, ZERO, 3
9D0076B0  AC436164   SW V1, 24932(V0)
93:                  #endif
94:                  
95:                      
96:                      // PORT G  ================================================================
97:                  #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
98:                      PORT_G_SET_DIGITAL_IN (BIT_TEMP_ALERT_1 | BIT_PWR_GD_1V35 | BIT_PWR_GD_1V5 | BIT_PWR_GD_1V2);
99:                      PORT_G_SET_DIGITAL_OUT(BIT_PWR_EN_1V8 | BIT_PWR_EN_1V5);
100:                     PORT_G_CLEAR_BITS     (BIT_PWR_EN_1V8 | BIT_PWR_EN_1V5);
101:                 #elif defined (_PCB5_)
102:                     PORT_G_SET_DIGITAL_IN (BIT_PWR_GD_12V | BIT_PWR_GD_FAN | BIT_TEMP_ALERT_1 | BIT_PWR_GD_1V1_CPU | BIT_PWR_GD_1V5 | BIT_PWR_GD_0V9_CPU);
9D0076B4  3C02BF88   LUI V0, -16504
9D0076B8  24037007   ADDIU V1, ZERO, 28679
9D0076BC  AC436188   SW V1, 24968(V0)
103:                     PORT_G_SET_DIGITAL_OUT(BIT_PWR_DIS_1V1_CPU | BIT_PWR_DIS_1V0 | BIT_PWR_DIS_0V9_CPU);
9D0076C0  3C02BF88   LUI V0, -16504
9D0076C4  240301C0   ADDIU V1, ZERO, 448
9D0076C8  AC436184   SW V1, 24964(V0)
104:                     PORT_G_CLEAR_BITS     (BIT_PWR_DIS_1V1_CPU | BIT_PWR_DIS_1V0 | BIT_PWR_DIS_0V9_CPU);
9D0076CC  3C02BF88   LUI V0, -16504
9D0076D0  240301C0   ADDIU V1, ZERO, 448
9D0076D4  AC4361A4   SW V1, 24996(V0)
105:                 #endif
106:                 }
9D0076D8  03C0E821   ADDU SP, S8, ZERO
9D0076DC  8FBE0004   LW S8, 4(SP)
9D0076E0  27BD0008   ADDIU SP, SP, 8
9D0076E4  03E00008   JR RA
9D0076E8  00000000   NOP
107:                 
108:                 
109:                 
110:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
111:                 //---------------------------- Release all reset ------------------------------
112:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
113:                 void io_power_on_sequence(boolean reset_soc)
114:                 {
9D0076EC  27BDFFE8   ADDIU SP, SP, -24
9D0076F0  AFBF0014   SW RA, 20(SP)
9D0076F4  AFBE0010   SW S8, 16(SP)
9D0076F8  03A0F021   ADDU S8, SP, ZERO
9D0076FC  AFC40018   SW A0, 24(S8)
115:                     // Wake up everyone step by step to avoid current peaks
116:                 
117:                     // Start the VM4400
118:                     #ifdef _PCB1_
119:                     delay_ms(10);
120:                     PIN_VM4400_RSTN    = 1;
121:                     #endif
122:                 
123:                     // Audio
124:                     delay_ms(10);
9D007700  2404000A   ADDIU A0, ZERO, 10
9D007704  0F40218B   JAL delay_ms
9D007708  00000000   NOP
125:                     PIN_DIR9001_1_RSTN = 1;
9D00770C  3C03BF88   LUI V1, -16504
9D007710  94626120   LHU V0, 24864(V1)
9D007714  24040001   ADDIU A0, ZERO, 1
9D007718  7C824204   INS V0, A0, 8, 1
9D00771C  A4626120   SH V0, 24864(V1)
126:                     PIN_DIR9001_2_RSTN = 1;
9D007720  3C03BF88   LUI V1, -16504
9D007724  94626120   LHU V0, 24864(V1)
9D007728  24040001   ADDIU A0, ZERO, 1
9D00772C  7C824A44   INS V0, A0, 9, 1
9D007730  A4626120   SH V0, 24864(V1)
127:                     PIN_TLV320_A_RSTN = 1;
9D007734  3C03BF88   LUI V1, -16504
9D007738  94626060   LHU V0, 24672(V1)
9D00773C  24040001   ADDIU A0, ZERO, 1
9D007740  7C827384   INS V0, A0, 14, 1
9D007744  A4626060   SH V0, 24672(V1)
128:                     PIN_TLV320_B_RSTN = 1;
9D007748  3C03BF88   LUI V1, -16504
9D00774C  94626060   LHU V0, 24672(V1)
9D007750  24040001   ADDIU A0, ZERO, 1
9D007754  7C827BC4   INS V0, A0, 15, 1
9D007758  A4626060   SH V0, 24672(V1)
129:                 
130:                     // cvbs
131:                     delay_ms(10);
9D00775C  2404000A   ADDIU A0, ZERO, 10
9D007760  0F40218B   JAL delay_ms
9D007764  00000000   NOP
132:                     PIN_CVBS_RSTN = 1;      // needs long reset because of the 1uF capa
9D007768  3C03BF88   LUI V1, -16504
9D00776C  946260E0   LHU V0, 24800(V1)
9D007770  24040001   ADDIU A0, ZERO, 1
9D007774  7C827BC4   INS V0, A0, 15, 1
9D007778  A46260E0   SH V0, 24800(V1)
133:                 
134:                     // hdmi
135:                     delay_ms(10);
9D00777C  2404000A   ADDIU A0, ZERO, 10
9D007780  0F40218B   JAL delay_ms
9D007784  00000000   NOP
136:                     PIN_ANX_HDMI_RSTN = 1;
9D007788  3C03BF88   LUI V1, -16504
9D00778C  94626060   LHU V0, 24672(V1)
9D007790  24040001   ADDIU A0, ZERO, 1
9D007794  7C826B44   INS V0, A0, 13, 1
9D007798  A4626060   SH V0, 24672(V1)
137:                 
138:                     // dvi
139:                     delay_ms(10);
9D00779C  2404000A   ADDIU A0, ZERO, 10
9D0077A0  0F40218B   JAL delay_ms
9D0077A4  00000000   NOP
140:                     PIN_ANX_DVI_RSTN = 1;
9D0077A8  3C03BF88   LUI V1, -16504
9D0077AC  94626060   LHU V0, 24672(V1)
9D0077B0  24040001   ADDIU A0, ZERO, 1
9D0077B4  7C826304   INS V0, A0, 12, 1
9D0077B8  A4626060   SH V0, 24672(V1)
141:                 
142:                     // SoC
143:                     if (reset_soc == true){
9D0077BC  8FC30018   LW V1, 24(S8)
9D0077C0  24020001   ADDIU V0, ZERO, 1
9D0077C4  14620008   BNE V1, V0, 0x9D0077E8
9D0077C8  00000000   NOP
144:                         delay_ms(20);
9D0077CC  24040014   ADDIU A0, ZERO, 20
9D0077D0  0F40218B   JAL delay_ms
9D0077D4  00000000   NOP
145:                         #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
146:                             PIN_SOC_RSTN = 1;
147:                         #elif defined (_PCB5_)
148:                             PIN_SOC_RSTN = 0;
9D0077D8  3C03BF88   LUI V1, -16504
9D0077DC  94626020   LHU V0, 24608(V1)
9D0077E0  7C024A44   INS V0, ZERO, 9, 1
9D0077E4  A4626020   SH V0, 24608(V1)
149:                         #endif
150:                     }
151:                 }
9D0077E8  03C0E821   ADDU SP, S8, ZERO
9D0077EC  8FBF0014   LW RA, 20(SP)
9D0077F0  8FBE0010   LW S8, 16(SP)
9D0077F4  27BD0018   ADDIU SP, SP, 24
9D0077F8  03E00008   JR RA
9D0077FC  00000000   NOP
152:                 
153:                 
154:                 
155:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
156:                 //----------------------------- Reset all Chips -------------------------------
157:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
158:                 void io_power_off_sequence(boolean reset_soc)
159:                 {
9D007800  27BDFFF8   ADDIU SP, SP, -8
9D007804  AFBE0004   SW S8, 4(SP)
9D007808  03A0F021   ADDU S8, SP, ZERO
9D00780C  AFC40008   SW A0, 8(S8)
160:                     if (reset_soc == true){
9D007810  8FC30008   LW V1, 8(S8)
9D007814  24020001   ADDIU V0, ZERO, 1
9D007818  14620006   BNE V1, V0, 0x9D007834
9D00781C  00000000   NOP
161:                         #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
162:                         PIN_SOC_RSTN = 0;
163:                         #elif defined (_PCB5_)
164:                         PIN_SOC_RSTN = 1;   // inverted by NMOS
9D007820  3C03BF88   LUI V1, -16504
9D007824  94626020   LHU V0, 24608(V1)
9D007828  24040001   ADDIU A0, ZERO, 1
9D00782C  7C824A44   INS V0, A0, 9, 1
9D007830  A4626020   SH V0, 24608(V1)
165:                         #endif
166:                     }
167:                 
168:                     PIN_CVBS_RSTN      = 0;
9D007834  3C03BF88   LUI V1, -16504
9D007838  946260E0   LHU V0, 24800(V1)
9D00783C  7C027BC4   INS V0, ZERO, 15, 1
9D007840  A46260E0   SH V0, 24800(V1)
169:                     PIN_ANX_HDMI_RSTN  = 0;
9D007844  3C03BF88   LUI V1, -16504
9D007848  94626060   LHU V0, 24672(V1)
9D00784C  7C026B44   INS V0, ZERO, 13, 1
9D007850  A4626060   SH V0, 24672(V1)
170:                     PIN_ANX_DVI_RSTN   = 0;
9D007854  3C03BF88   LUI V1, -16504
9D007858  94626060   LHU V0, 24672(V1)
9D00785C  7C026304   INS V0, ZERO, 12, 1
9D007860  A4626060   SH V0, 24672(V1)
171:                     PIN_DIR9001_1_RSTN = 0;
9D007864  3C03BF88   LUI V1, -16504
9D007868  94626120   LHU V0, 24864(V1)
9D00786C  7C024204   INS V0, ZERO, 8, 1
9D007870  A4626120   SH V0, 24864(V1)
172:                     PIN_DIR9001_2_RSTN = 0;
9D007874  3C03BF88   LUI V1, -16504
9D007878  94626120   LHU V0, 24864(V1)
9D00787C  7C024A44   INS V0, ZERO, 9, 1
9D007880  A4626120   SH V0, 24864(V1)
173:                 
174:                     #if defined (_PCB1_)
175:                     PIN_VM4400_RSTN    = 0;
176:                     #endif
177:                 
178:                     PIN_TLV320_A_RSTN  = 0;
9D007884  3C03BF88   LUI V1, -16504
9D007888  94626060   LHU V0, 24672(V1)
9D00788C  7C027384   INS V0, ZERO, 14, 1
9D007890  A4626060   SH V0, 24672(V1)
179:                     PIN_TLV320_B_RSTN  = 0;
9D007894  3C03BF88   LUI V1, -16504
9D007898  94626060   LHU V0, 24672(V1)
9D00789C  7C027BC4   INS V0, ZERO, 15, 1
9D0078A0  A4626060   SH V0, 24672(V1)
180:                 }
9D0078A4  03C0E821   ADDU SP, S8, ZERO
9D0078A8  8FBE0004   LW S8, 4(SP)
9D0078AC  27BD0008   ADDIU SP, SP, 8
9D0078B0  03E00008   JR RA
9D0078B4  00000000   NOP
181:                 
182:                 
183:                 
184:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
185:                 //--------------------------- Power down all DC/DC ----------------------------
186:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
187:                 void power_resistors_control(u8 map)
188:                 {
9D0078B8  27BDFFF8   ADDIU SP, SP, -8
9D0078BC  AFBE0004   SW S8, 4(SP)
9D0078C0  03A0F021   ADDU S8, SP, ZERO
9D0078C4  00801021   ADDU V0, A0, ZERO
9D0078C8  A3C20008   SB V0, 8(S8)
189:                     #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
190:                     if (map & 0x01) PIN_PWR_RES_TL = 1; else PIN_PWR_RES_TL = 0;
191:                     if (map & 0x02) PIN_PWR_RES_BM = 1; else PIN_PWR_RES_BM = 0;
192:                     if (map & 0x04) PIN_PWR_RES_TR = 1; else PIN_PWR_RES_TR = 0;
193:                     #endif
194:                 }
9D0078CC  03C0E821   ADDU SP, S8, ZERO
9D0078D0  8FBE0004   LW S8, 4(SP)
9D0078D4  27BD0008   ADDIU SP, SP, 8
9D0078D8  03E00008   JR RA
9D0078DC  00000000   NOP
9D0078E0  27BDFFE0   ADDIU SP, SP, -32
195:                 
---  d:/svn/mgw-ace-enc/trunk/pic32/interrupt_management.c  ---------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   26 January 2015                                     &&&
6:                   //&&&   Version     :   v1.0                                                &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   //&&&   Description :   - handles interrupts from timers                    &&&
9:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
10:                  //&&&   Infos       :   - none                                              &&&
11:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
12:                  //&&&   History     :                                                       &&&
13:                  //&&&   1.0 - 26/01/2015 - PBL - First release                              &&&
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  
16:                  #include "interrupt_management.h"
17:                  #include "temp_management.h"
18:                  #include "led_power.h"
19:                  #include "common.h"
20:                  
21:                  extern CONTEXT g;
22:                  
23:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
24:                  RESULT timer1_isr()
25:                  {
9D008250  27BDFFE8   ADDIU SP, SP, -24
26:                      static u8 cnt = 0;
27:                  
28:                      if (g.led_pattern != LED_PATTERN_UPDATING){
9D008260  3C02A000   LUI V0, -24576
9D008264  2442000C   ADDIU V0, V0, 12
9D008268  8C43007C   LW V1, 124(V0)
9D00826C  24020002   ADDIU V0, ZERO, 2
9D008270  1062000D   BEQ V1, V0, 0x9D0082A8
9D008274  00000000   NOP
29:                          if (cnt++ >= 4){
9D008278  93828016   LBU V0, -32746(GP)
9D00827C  24430001   ADDIU V1, V0, 1
9D008280  306300FF   ANDI V1, V1, 255
9D008284  A3838016   SB V1, -32746(GP)
9D008288  2C420004   SLTIU V0, V0, 4
9D00828C  14400008   BNE V0, ZERO, 0x9D0082B0
9D008290  00000000   NOP
30:                              cnt = 0;
9D008294  A3808016   SB ZERO, -32746(GP)
31:                              toggle_power_led();     // called every 5*LedSpeed ms
9D008298  0F4019C2   JAL toggle_power_led
9D00829C  00000000   NOP
9D0082A0  0B4020AC   J 0x9D0082B0
9D0082A4  00000000   NOP
32:                          }
33:                      }else{
34:                          toggle_power_led();         // called every LedSpeed ms
9D0082A8  0F4019C2   JAL toggle_power_led
9D0082AC  00000000   NOP
35:                      }
36:                      return SUCCESS;
9D0082B0  00001021   ADDU V0, ZERO, ZERO
37:                  }
9D0082B4  03C0E821   ADDU SP, S8, ZERO
9D0082B8  8FBF0014   LW RA, 20(SP)
9D0082BC  8FBE0010   LW S8, 16(SP)
9D0082C0  27BD0018   ADDIU SP, SP, 24
9D0082C4  03E00008   JR RA
9D0082C8  00000000   NOP
38:                  
39:                  
40:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
41:                  RESULT timer2_isr()
42:                  {
9D0082CC  27BDFFF8   ADDIU SP, SP, -8
9D0082D0  AFBE0004   SW S8, 4(SP)
9D0082D4  03A0F021   ADDU S8, SP, ZERO
43:                      return SUCCESS;
9D0082D8  00001021   ADDU V0, ZERO, ZERO
44:                  }
9D0082DC  03C0E821   ADDU SP, S8, ZERO
9D0082E0  8FBE0004   LW S8, 4(SP)
9D0082E4  27BD0008   ADDIU SP, SP, 8
9D0082E8  03E00008   JR RA
9D0082EC  00000000   NOP
45:                  
46:                  
47:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
48:                  // used to update data from sensors
49:                  // function called every 200 ms
50:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
51:                  RESULT timer3_isr()
52:                  {
9D0082F0  27BDFFF8   ADDIU SP, SP, -8
9D0082F4  AFBE0004   SW S8, 4(SP)
9D0082F8  03A0F021   ADDU S8, SP, ZERO
53:                      static u8 cnt = 0;
54:                  
55:                      if (cnt++ >= 14){
9D0082FC  93828017   LBU V0, -32745(GP)
9D008300  24430001   ADDIU V1, V0, 1
9D008304  306300FF   ANDI V1, V1, 255
9D008308  A3838017   SB V1, -32745(GP)
9D00830C  2C42000E   SLTIU V0, V0, 14
9D008310  1440000B   BNE V0, ZERO, 0x9D008340
9D008314  00000000   NOP
56:                          cnt = 0;
9D008318  A3808017   SB ZERO, -32745(GP)
57:                          if (g.update_data == false) // every 3000 ms
9D00831C  3C02A000   LUI V0, -24576
9D008320  2442000C   ADDIU V0, V0, 12
9D008324  8C420074   LW V0, 116(V0)
9D008328  14400005   BNE V0, ZERO, 0x9D008340
9D00832C  00000000   NOP
58:                              g.update_data = true;
9D008330  3C02A000   LUI V0, -24576
9D008334  2442000C   ADDIU V0, V0, 12
9D008338  24030001   ADDIU V1, ZERO, 1
9D00833C  AC430074   SW V1, 116(V0)
59:                      }
60:                      return SUCCESS;
9D008340  00001021   ADDU V0, ZERO, ZERO
61:                  }
9D008344  03C0E821   ADDU SP, S8, ZERO
9D008348  8FBE0004   LW S8, 4(SP)
9D00834C  27BD0008   ADDIU SP, SP, 8
9D008350  03E00008   JR RA
9D008354  00000000   NOP
62:                  
63:                  
64:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
65:                  RESULT timer4_isr()
66:                  {
9D008358  27BDFFF8   ADDIU SP, SP, -8
9D00835C  AFBE0004   SW S8, 4(SP)
9D008360  03A0F021   ADDU S8, SP, ZERO
67:                      return SUCCESS;
9D008364  00001021   ADDU V0, ZERO, ZERO
68:                  }
9D008368  03C0E821   ADDU SP, S8, ZERO
9D00836C  8FBE0004   LW S8, 4(SP)
9D008370  27BD0008   ADDIU SP, SP, 8
9D008374  03E00008   JR RA
9D008378  00000000   NOP
69:                  
70:                  
71:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
72:                  RESULT timer5_isr()
73:                  {
9D00837C  27BDFFE8   ADDIU SP, SP, -24
9D008380  AFBF0014   SW RA, 20(SP)
9D008384  AFBE0010   SW S8, 16(SP)
9D008388  03A0F021   ADDU S8, SP, ZERO
74:                      static u8 cnt = 0;
75:                  
76:                      if (cnt++ > 4){
9D00838C  93828018   LBU V0, -32744(GP)
9D008390  24430001   ADDIU V1, V0, 1
9D008394  306300FF   ANDI V1, V1, 255
9D008398  A3838018   SB V1, -32744(GP)
9D00839C  2C420005   SLTIU V0, V0, 5
9D0083A0  14400004   BNE V0, ZERO, 0x9D0083B4
9D0083A4  00000000   NOP
77:                          fan_spin_up();
9D0083A8  0F4017C6   JAL fan_spin_up
9D0083AC  00000000   NOP
78:                          cnt = 0;
9D0083B0  A3808018   SB ZERO, -32744(GP)
79:                      }
80:                  
81:                      return SUCCESS;
9D0083B4  00001021   ADDU V0, ZERO, ZERO
82:                  }
9D0083B8  03C0E821   ADDU SP, S8, ZERO
9D0083BC  8FBF0014   LW RA, 20(SP)
9D0083C0  8FBE0010   LW S8, 16(SP)
9D0083C4  27BD0018   ADDIU SP, SP, 24
9D0083C8  03E00008   JR RA
9D0083CC  00000000   NOP
83:                  
84:                  
85:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
86:                  RESULT timer23_isr()
87:                  {
9D0083D0  27BDFFF8   ADDIU SP, SP, -8
9D0083D4  AFBE0004   SW S8, 4(SP)
9D0083D8  03A0F021   ADDU S8, SP, ZERO
88:                      return SUCCESS;
9D0083DC  00001021   ADDU V0, ZERO, ZERO
89:                  }
9D0083E0  03C0E821   ADDU SP, S8, ZERO
9D0083E4  8FBE0004   LW S8, 4(SP)
9D0083E8  27BD0008   ADDIU SP, SP, 8
9D0083EC  03E00008   JR RA
9D0083F0  00000000   NOP
90:                  
91:                  
92:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
93:                  RESULT timer45_isr()
94:                  {
9D0083F4  27BDFFF8   ADDIU SP, SP, -8
9D0083F8  AFBE0004   SW S8, 4(SP)
9D0083FC  03A0F021   ADDU S8, SP, ZERO
95:                      return SUCCESS;
9D008400  00001021   ADDU V0, ZERO, ZERO
96:                  }
9D008404  03C0E821   ADDU SP, S8, ZERO
9D008408  8FBE0004   LW S8, 4(SP)
9D00840C  27BD0008   ADDIU SP, SP, 8
9D008410  03E00008   JR RA
9D008414  00000000   NOP
9D008418  00043DC2   SRL A3, A0, 23
---  d:/svn/mgw-ace-enc/trunk/pic32/i2c_slave.c  --------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Version     :   v1.2                                                &&&
4:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:                   //&&&   Description :   - Init i2c slave bus                                &&&
6:                   //&&&                   - handles interrupt                                 &&&
7:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
8:                   //&&&   History     :                                                       &&&
9:                   //&&&   1.0 - 2014/09/05 - PBL - Creation                                   &&&
10:                  //&&&   1.1 - 2016/09/07 - PBL - Made library independant of Microchip's one&&&
11:                  //&&&   1.2 - 2016/09/12 - PBL - Removed clock stretching                   &&&
12:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:                  
14:                  #include "i2c_slave.h"
15:                  #include "i2c_registers.h"
16:                  #include <sys/attribs.h>
17:                  #include "hardware_profile.h"
18:                  
19:                  u8 addr_flag = 0;  // Initialize AddFlag
20:                  u8 data_flag = 0;  // Initialize DataFlag
21:                  
22:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
23:                  //------------------------- Init I2C slave bus --------------------------------
24:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
25:                  RESULT i2c1_slave_init(u8 slave_addr)
26:                  {
9D006CA4  27BDFFF8   ADDIU SP, SP, -8
9D006CA8  AFBE0004   SW S8, 4(SP)
9D006CAC  03A0F021   ADDU S8, SP, ZERO
9D006CB0  00801021   ADDU V0, A0, ZERO
9D006CB4  A3C20008   SB V0, 8(S8)
27:                      // disable clock stretching
28:                      I2C1CONbits.STREN = 0;
9D006CB8  3C03BF80   LUI V1, -16512
9D006CBC  94625300   LHU V0, 21248(V1)
9D006CC0  7C023184   INS V0, ZERO, 6, 1
9D006CC4  A4625300   SH V0, 21248(V1)
29:                  
30:                      // use 7-bit slave address
31:                      I2C1CONbits.A10M = 0;
9D006CC8  3C03BF80   LUI V1, -16512
9D006CCC  94625300   LHU V0, 21248(V1)
9D006CD0  7C025284   INS V0, ZERO, 10, 1
9D006CD4  A4625300   SH V0, 21248(V1)
32:                  
33:                      // enable interface
34:                      I2C1CONbits.ON = 1;
9D006CD8  3C03BF80   LUI V1, -16512
9D006CDC  94625300   LHU V0, 21248(V1)
9D006CE0  24040001   ADDIU A0, ZERO, 1
9D006CE4  7C827BC4   INS V0, A0, 15, 1
9D006CE8  A4625300   SH V0, 21248(V1)
35:                  
36:                      // set the address of the slave module
37:                      I2C1ADD = slave_addr; // 7 bits address;
9D006CEC  93C30008   LBU V1, 8(S8)
9D006CF0  3C02BF80   LUI V0, -16512
9D006CF4  AC435320   SW V1, 21280(V0)
38:                      I2C1MSK = 0;
9D006CF8  3C02BF80   LUI V0, -16512
9D006CFC  AC405330   SW ZERO, 21296(V0)
39:                  
40:                      // configure the interrupt priority for the I2C peripheral
41:                      IPC6bits.I2C1IP = 3;
9D006D00  3C03BF88   LUI V1, -16504
9D006D04  8C6210F0   LW V0, 4336(V1)
9D006D08  24040003   ADDIU A0, ZERO, 3
9D006D0C  7C826284   INS V0, A0, 10, 3
9D006D10  AC6210F0   SW V0, 4336(V1)
42:                  
43:                      // clear pending interrupts and enable I2C interrupts
44:                      IFS0bits.I2C1SIF = 0;
9D006D14  3C03BF88   LUI V1, -16504
9D006D18  8C621030   LW V0, 4144(V1)
9D006D1C  7C02F784   INS V0, ZERO, 30, 1
9D006D20  AC621030   SW V0, 4144(V1)
45:                      IEC0bits.I2C1SIE = 0;
9D006D24  3C03BF88   LUI V1, -16504
9D006D28  8C621060   LW V0, 4192(V1)
9D006D2C  7C02F784   INS V0, ZERO, 30, 1
9D006D30  AC621060   SW V0, 4192(V1)
46:                      IEC0bits.I2C1SIE = 1;
9D006D34  3C03BF88   LUI V1, -16504
9D006D38  8C621060   LW V0, 4192(V1)
9D006D3C  24040001   ADDIU A0, ZERO, 1
9D006D40  7C82F784   INS V0, A0, 30, 1
9D006D44  AC621060   SW V0, 4192(V1)
47:                  
48:                      return SUCCESS;
9D006D48  00001021   ADDU V0, ZERO, ZERO
49:                  }
9D006D4C  03C0E821   ADDU SP, S8, ZERO
9D006D50  8FBE0004   LW S8, 4(SP)
9D006D54  27BD0008   ADDIU SP, SP, 8
9D006D58  03E00008   JR RA
9D006D5C  00000000   NOP
50:                  
51:                  RESULT i2c2_slave_init(u8 slave_addr)
52:                  {
9D006D60  27BDFFF8   ADDIU SP, SP, -8
9D006D64  AFBE0004   SW S8, 4(SP)
9D006D68  03A0F021   ADDU S8, SP, ZERO
9D006D6C  00801021   ADDU V0, A0, ZERO
9D006D70  A3C20008   SB V0, 8(S8)
53:                      // disable clock stretching
54:                      I2C2CONbits.STREN = 0;
9D006D74  3C03BF80   LUI V1, -16512
9D006D78  94625400   LHU V0, 21504(V1)
9D006D7C  7C023184   INS V0, ZERO, 6, 1
9D006D80  A4625400   SH V0, 21504(V1)
55:                  
56:                      // use 7-bit slave address
57:                      I2C2CONbits.A10M = 0;
9D006D84  3C03BF80   LUI V1, -16512
9D006D88  94625400   LHU V0, 21504(V1)
9D006D8C  7C025284   INS V0, ZERO, 10, 1
9D006D90  A4625400   SH V0, 21504(V1)
58:                  
59:                      // enable interface
60:                      I2C2CONbits.ON = 1;
9D006D94  3C03BF80   LUI V1, -16512
9D006D98  94625400   LHU V0, 21504(V1)
9D006D9C  24040001   ADDIU A0, ZERO, 1
9D006DA0  7C827BC4   INS V0, A0, 15, 1
9D006DA4  A4625400   SH V0, 21504(V1)
61:                  
62:                      // set the address of the slave module
63:                      I2C2ADD = slave_addr; // 7 bits address;
9D006DA8  93C30008   LBU V1, 8(S8)
9D006DAC  3C02BF80   LUI V0, -16512
9D006DB0  AC435420   SW V1, 21536(V0)
64:                      I2C2MSK = 0;
9D006DB4  3C02BF80   LUI V0, -16512
9D006DB8  AC405430   SW ZERO, 21552(V0)
65:                  
66:                      // configure the interrupt priority for the I2C peripheral
67:                      IPC8bits.I2C2IP = 3;
9D006DBC  3C03BF88   LUI V1, -16504
9D006DC0  8C621110   LW V0, 4368(V1)
9D006DC4  24040003   ADDIU A0, ZERO, 3
9D006DC8  7C826284   INS V0, A0, 10, 3
9D006DCC  AC621110   SW V0, 4368(V1)
68:                  
69:                      // clear pending interrupts and enable I2C interrupts
70:                      IFS1bits.I2C2SIF = 0;
9D006DD0  3C03BF88   LUI V1, -16504
9D006DD4  8C621040   LW V0, 4160(V1)
9D006DD8  7C026304   INS V0, ZERO, 12, 1
9D006DDC  AC621040   SW V0, 4160(V1)
71:                      IEC1bits.I2C2SIE = 0;
9D006DE0  3C03BF88   LUI V1, -16504
9D006DE4  8C621070   LW V0, 4208(V1)
9D006DE8  7C026304   INS V0, ZERO, 12, 1
9D006DEC  AC621070   SW V0, 4208(V1)
72:                      IEC1bits.I2C2SIE = 1;
9D006DF0  3C03BF88   LUI V1, -16504
9D006DF4  8C621070   LW V0, 4208(V1)
9D006DF8  24040001   ADDIU A0, ZERO, 1
9D006DFC  7C826304   INS V0, A0, 12, 1
9D006E00  AC621070   SW V0, 4208(V1)
73:                  
74:                      return SUCCESS;
9D006E04  00001021   ADDU V0, ZERO, ZERO
75:                  }
9D006E08  03C0E821   ADDU SP, S8, ZERO
9D006E0C  8FBE0004   LW S8, 4(SP)
9D006E10  27BD0008   ADDIU SP, SP, 8
9D006E14  03E00008   JR RA
9D006E18  00000000   NOP
76:                  
77:                  
78:                  
79:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
80:                  //-------------------- IT Generated by I2C Slave Module -----------------------
81:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
82:                  void __ISR(_I2C_1_VECTOR, IPL3AUTO) _SlaveI2CHandler(void)
83:                  {
9D006E1C  415DE800   RDPGPR SP, SP
9D006E20  401B7000   MFC0 K1, EPC
9D006E24  401A6002   MFC0 K0, SRSCtl
9D006E28  27BDFF80   ADDIU SP, SP, -128
9D006E2C  AFBB007C   SW K1, 124(SP)
9D006E30  401B6000   MFC0 K1, Status
9D006E34  AFBA0074   SW K0, 116(SP)
9D006E38  AFBB0078   SW K1, 120(SP)
9D006E3C  7C1B7844   INS K1, ZERO, 1, 15
9D006E40  377B0C00   ORI K1, K1, 3072
9D006E44  409B6000   MTC0 K1, Status
9D006E48  AFA30024   SW V1, 36(SP)
9D006E4C  AFA20020   SW V0, 32(SP)
9D006E50  8FA30074   LW V1, 116(SP)
9D006E54  3063000F   ANDI V1, V1, 15
9D006E58  14600012   BNE V1, ZERO, 0x9D006EA4
9D006E5C  00000000   NOP
9D006E60  AFBF0064   SW RA, 100(SP)
9D006E64  AFBE0060   SW S8, 96(SP)
9D006E68  AFB9005C   SW T9, 92(SP)
9D006E6C  AFB80058   SW T8, 88(SP)
9D006E70  AFAF0054   SW T7, 84(SP)
9D006E74  AFAE0050   SW T6, 80(SP)
9D006E78  AFAD004C   SW T5, 76(SP)
9D006E7C  AFAC0048   SW T4, 72(SP)
9D006E80  AFAB0044   SW T3, 68(SP)
9D006E84  AFAA0040   SW T2, 64(SP)
9D006E88  AFA9003C   SW T1, 60(SP)
9D006E8C  AFA80038   SW T0, 56(SP)
9D006E90  AFA70034   SW A3, 52(SP)
9D006E94  AFA60030   SW A2, 48(SP)
9D006E98  AFA5002C   SW A1, 44(SP)
9D006E9C  AFA40028   SW A0, 40(SP)
9D006EA0  AFA1001C   SW AT, 28(SP)
9D006EA4  00000000   NOP
9D006EA8  00001012   MFLO V0
9D006EAC  AFA2006C   SW V0, 108(SP)
9D006EB0  00001810   MFHI V1
9D006EB4  AFA30068   SW V1, 104(SP)
9D006EB8  03A0F021   ADDU S8, SP, ZERO
84:                      static u8 i2c_addr = 0;
85:                      static u8 i2c_data = 0;
86:                      u8 read_data = 0;
9D006EBC  A3C00010   SB ZERO, 16(S8)
87:                  
88:                      // check for MASTER and Bus events and respond accordingly
89:                      if (IFS0bits.I2C1MIF == 1) {
9D006EC0  3C02BF88   LUI V0, -16504
9D006EC4  8C431030   LW V1, 4144(V0)
9D006EC8  3C028000   LUI V0, -32768
9D006ECC  00621024   AND V0, V1, V0
9D006ED0  10400007   BEQ V0, ZERO, 0x9D006EF0
9D006ED4  00000000   NOP
90:                          IFS0bits.I2C1MIF = 0;
9D006ED8  3C03BF88   LUI V1, -16504
9D006EDC  8C621030   LW V0, 4144(V1)
9D006EE0  7C02FFC4   INS V0, ZERO, 31, 1
9D006EE4  AC621030   SW V0, 4144(V1)
91:                          return;
9D006EE8  0B401C45   J 0x9D007114
9D006EEC  00000000   NOP
92:                      }
93:                      if (IFS0bits.I2C1BIF == 1) {
9D006EF0  3C02BF88   LUI V0, -16504
9D006EF4  8C431030   LW V1, 4144(V0)
9D006EF8  3C022000   LUI V0, 8192
9D006EFC  00621024   AND V0, V1, V0
9D006F00  10400007   BEQ V0, ZERO, 0x9D006F20
9D006F04  00000000   NOP
94:                          IFS0bits.I2C1BIF = 0;
9D006F08  3C03BF88   LUI V1, -16504
9D006F0C  8C621030   LW V0, 4144(V1)
9D006F10  7C02EF44   INS V0, ZERO, 29, 1
9D006F14  AC621030   SW V0, 4144(V1)
95:                          return;
9D006F18  0B401C45   J 0x9D007114
9D006F1C  00000000   NOP
96:                      }
97:                  
98:                      // handle the incoming message
99:                  
100:                     //===============================================================
101:                     // write, last byte was address
102:                     if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 0)) {
9D006F20  3C02BF80   LUI V0, -16512
9D006F24  8C425310   LW V0, 21264(V0)
9D006F28  30420004   ANDI V0, V0, 4
9D006F2C  14400011   BNE V0, ZERO, 0x9D006F74
9D006F30  00000000   NOP
9D006F34  3C02BF80   LUI V0, -16512
9D006F38  8C425310   LW V0, 21264(V0)
9D006F3C  30420020   ANDI V0, V0, 32
9D006F40  1440000C   BNE V0, ZERO, 0x9D006F74
9D006F44  00000000   NOP
103:                 
104:                         // reset any state variables needed by a message sequence
105:                         // perform a dummy read of the address
106:                         I2C1RCV;
9D006F48  3C02BF80   LUI V0, -16512
9D006F4C  8C425360   LW V0, 21344(V0)
107:                 
108:                         // release the clock to restart I2C
109:                         I2C1CONbits.SCLREL = 1; // release the clock
9D006F50  3C03BF80   LUI V1, -16512
9D006F54  94625300   LHU V0, 21248(V1)
9D006F58  24040001   ADDIU A0, ZERO, 1
9D006F5C  7C826304   INS V0, A0, 12, 1
9D006F60  A4625300   SH V0, 21248(V1)
110:                 
111:                         addr_flag = 1;
9D006F64  24020001   ADDIU V0, ZERO, 1
9D006F68  A3828010   SB V0, -32752(GP)
9D006F6C  0B401C41   J 0x9D007104
9D006F70  00000000   NOP
112:                 
113:                 
114:                     //===============================================================
115:                     // write, last byte was data
116:                     } else if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 1)) {
9D006F74  3C02BF80   LUI V0, -16512
9D006F78  8C425310   LW V0, 21264(V0)
9D006F7C  30420004   ANDI V0, V0, 4
9D006F80  14400032   BNE V0, ZERO, 0x9D00704C
9D006F84  00000000   NOP
9D006F88  3C02BF80   LUI V0, -16512
9D006F8C  8C425310   LW V0, 21264(V0)
9D006F90  30420020   ANDI V0, V0, 32
9D006F94  1040002D   BEQ V0, ZERO, 0x9D00704C
9D006F98  00000000   NOP
117:                 
118:                         if (addr_flag == 1)             // reception of the address of the register
9D006F9C  93838010   LBU V1, -32752(GP)
9D006FA0  24020001   ADDIU V0, ZERO, 1
9D006FA4  1462000F   BNE V1, V0, 0x9D006FE4
9D006FA8  00000000   NOP
9D00703C  0B401C41   J 0x9D007104
9D007040  00000000   NOP
9D007044  0B401C41   J 0x9D007104
9D007048  00000000   NOP
119:                         {
120:                             addr_flag = 0;
9D006FAC  A3808010   SB ZERO, -32752(GP)
121:                             data_flag = 1;
9D006FB0  24020001   ADDIU V0, ZERO, 1
9D006FB4  A3828011   SB V0, -32751(GP)
122:                 
123:                             // get address from master
124:                             i2c_addr = I2C1RCV;
9D006FB8  3C02BF80   LUI V0, -16512
9D006FBC  8C425360   LW V0, 21344(V0)
9D006FC0  304200FF   ANDI V0, V0, 255
9D006FC4  A3828012   SB V0, -32750(GP)
125:                 
126:                             // release the clock to restart I2C
127:                             I2C1CONbits.SCLREL = 1;
9D006FC8  3C03BF80   LUI V1, -16512
9D006FCC  94625300   LHU V0, 21248(V1)
9D006FD0  24040001   ADDIU A0, ZERO, 1
9D006FD4  7C826304   INS V0, A0, 12, 1
9D006FD8  A4625300   SH V0, 21248(V1)
9D006FDC  0B401C11   J 0x9D007044
9D006FE0  00000000   NOP
128:                         }
129:                         else if (data_flag == 1)        // reception of the data to write in the register
9D006FE4  93838011   LBU V1, -32751(GP)
9D006FE8  24020001   ADDIU V0, ZERO, 1
9D006FEC  14620015   BNE V1, V0, 0x9D007044
9D006FF0  00000000   NOP
130:                         {
131:                             addr_flag = 0;
9D006FF4  A3808010   SB ZERO, -32752(GP)
132:                             data_flag = 0;
9D006FF8  A3808011   SB ZERO, -32751(GP)
133:                 
134:                             // get address from master
135:                             i2c_data = I2C1RCV;
9D006FFC  3C02BF80   LUI V0, -16512
9D007000  8C425360   LW V0, 21344(V0)
9D007004  304200FF   ANDI V0, V0, 255
9D007008  A3828013   SB V0, -32749(GP)
136:                 
137:                             //Release SCL1 line
138:                             I2C1CONbits.SCLREL = 1;
9D00700C  3C03BF80   LUI V1, -16512
9D007010  94625300   LHU V0, 21248(V1)
9D007014  24040001   ADDIU A0, ZERO, 1
9D007018  7C826304   INS V0, A0, 12, 1
9D00701C  A4625300   SH V0, 21248(V1)
139:                 
140:                             i2c_write_from_master(i2c_addr, i2c_data);
9D007020  93828012   LBU V0, -32750(GP)
9D007024  00401821   ADDU V1, V0, ZERO
9D007028  93828013   LBU V0, -32749(GP)
9D00702C  00602021   ADDU A0, V1, ZERO
9D007030  00402821   ADDU A1, V0, ZERO
9D007034  0F400000   JAL i2c_write_from_master
9D007038  00000000   NOP
141:                         }
142:                 
143:                 
144:                     //===============================================================
145:                     // read, last byte was address
146:                     } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 0)) {
9D00704C  3C02BF80   LUI V0, -16512
9D007050  8C425310   LW V0, 21264(V0)
9D007054  30420004   ANDI V0, V0, 4
9D007058  10400019   BEQ V0, ZERO, 0x9D0070C0
9D00705C  00000000   NOP
9D007060  3C02BF80   LUI V0, -16512
9D007064  8C425310   LW V0, 21264(V0)
9D007068  30420020   ANDI V0, V0, 32
9D00706C  14400014   BNE V0, ZERO, 0x9D0070C0
9D007070  00000000   NOP
147:                 
148:                         // read of the slave device, read the address
149:                         I2C1RCV;
9D007074  3C02BF80   LUI V0, -16512
9D007078  8C425360   LW V0, 21344(V0)
150:                         i2c_read_to_master(i2c_addr, &read_data);
9D00707C  93828012   LBU V0, -32750(GP)
9D007080  00402021   ADDU A0, V0, ZERO
9D007084  27C20010   ADDIU V0, S8, 16
9D007088  00402821   ADDU A1, V0, ZERO
9D00708C  0F4002C7   JAL i2c_read_to_master
9D007090  00000000   NOP
151:                         I2C1TRN = read_data;
9D007094  93C20010   LBU V0, 16(S8)
9D007098  00401821   ADDU V1, V0, ZERO
9D00709C  3C02BF80   LUI V0, -16512
9D0070A0  AC435350   SW V1, 21328(V0)
152:                         I2C1CONbits.SCLREL = 1;     // release the clock;
9D0070A4  3C03BF80   LUI V1, -16512
9D0070A8  94625300   LHU V0, 21248(V1)
9D0070AC  24040001   ADDIU A0, ZERO, 1
9D0070B0  7C826304   INS V0, A0, 12, 1
9D0070B4  A4625300   SH V0, 21248(V1)
9D0070B8  0B401C41   J 0x9D007104
9D0070BC  00000000   NOP
153:                 
154:                 
155:                     //===============================================================
156:                     // read, last byte was data
157:                     } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 1)) {
9D0070C0  3C02BF80   LUI V0, -16512
9D0070C4  8C425310   LW V0, 21264(V0)
9D0070C8  30420004   ANDI V0, V0, 4
9D0070CC  1040000D   BEQ V0, ZERO, 0x9D007104
9D0070D0  00000000   NOP
9D0070D4  3C02BF80   LUI V0, -16512
9D0070D8  8C425310   LW V0, 21264(V0)
9D0070DC  30420020   ANDI V0, V0, 32
9D0070E0  10400008   BEQ V0, ZERO, 0x9D007104
9D0070E4  00000000   NOP
158:                 
159:                         I2C1TRN = 0;
9D0070E8  3C02BF80   LUI V0, -16512
9D0070EC  AC405350   SW ZERO, 21328(V0)
160:                         I2C1CONbits.SCLREL = 1;     // release the clock;
9D0070F0  3C03BF80   LUI V1, -16512
9D0070F4  94625300   LHU V0, 21248(V1)
9D0070F8  24040001   ADDIU A0, ZERO, 1
9D0070FC  7C826304   INS V0, A0, 12, 1
9D007100  A4625300   SH V0, 21248(V1)
161:                 
162:                     }
163:                 
164:                     // finally clear the slave interrupt flag
165:                     IFS0bits.I2C1SIF = 0;
9D007104  3C03BF88   LUI V1, -16504
9D007108  8C621030   LW V0, 4144(V1)
9D00710C  7C02F784   INS V0, ZERO, 30, 1
9D007110  AC621030   SW V0, 4144(V1)
166:                 }
9D007114  03C0E821   ADDU SP, S8, ZERO
9D007118  8FA2006C   LW V0, 108(SP)
9D00711C  00400013   MTLO V0
9D007120  8FA30068   LW V1, 104(SP)
9D007124  00600011   MTHI V1
9D007128  8FA20074   LW V0, 116(SP)
9D00712C  3042000F   ANDI V0, V0, 15
9D007130  14400014   BNE V0, ZERO, 0x9D007184
9D007134  00000000   NOP
9D007138  8FBF0064   LW RA, 100(SP)
9D00713C  8FBE0060   LW S8, 96(SP)
9D007140  8FB9005C   LW T9, 92(SP)
9D007144  8FB80058   LW T8, 88(SP)
9D007148  8FAF0054   LW T7, 84(SP)
9D00714C  8FAE0050   LW T6, 80(SP)
9D007150  8FAD004C   LW T5, 76(SP)
9D007154  8FAC0048   LW T4, 72(SP)
9D007158  8FAB0044   LW T3, 68(SP)
9D00715C  8FAA0040   LW T2, 64(SP)
9D007160  8FA9003C   LW T1, 60(SP)
9D007164  8FA80038   LW T0, 56(SP)
9D007168  8FA70034   LW A3, 52(SP)
9D00716C  8FA60030   LW A2, 48(SP)
9D007170  8FA5002C   LW A1, 44(SP)
9D007174  8FA40028   LW A0, 40(SP)
9D007178  8FA30024   LW V1, 36(SP)
9D00717C  8FA20020   LW V0, 32(SP)
9D007180  8FA1001C   LW AT, 28(SP)
9D007184  00000000   NOP
9D007188  41606000   DI ZERO
9D00718C  000000C0   EHB
9D007190  8FBA007C   LW K0, 124(SP)
9D007194  8FBB0078   LW K1, 120(SP)
9D007198  409A7000   MTC0 K0, EPC
9D00719C  8FBA0074   LW K0, 116(SP)
9D0071A0  27BD0080   ADDIU SP, SP, 128
9D0071A4  409A6002   MTC0 K0, SRSCtl
9D0071A8  41DDE800   WRPGPR SP, SP
9D0071AC  409B6000   MTC0 K1, Status
9D0071B0  42000018   ERET
9D0071B4  27BDFFF8   ADDIU SP, SP, -8
9D0071B8  AFBE0004   SW S8, 4(SP)
9D0071BC  03A0F021   ADDU S8, SP, ZERO
167:                 
168:                 
---  d:/svn/mgw-ace-enc/trunk/pic32/i2c_registers.c  ----------------------------------------------------
1:                   #include "i2c_registers.h"
2:                   #include "common.h"
3:                   #include "io_control.h"
4:                   #include "pwm.h"
5:                   #include "timer.h"
6:                   #include "hardware_profile.h"
7:                   
8:                   extern CONTEXT g;
9:                   
10:                  
11:                  
12:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:                  //---------------------------- I2C Write Operation ----------------------------
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  RESULT i2c_write_from_master(u8 address, u8 data)
16:                  {
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFBE0018   SW S8, 24(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
9D000010  00801821   ADDU V1, A0, ZERO
9D000014  00A01021   ADDU V0, A1, ZERO
9D000018  A3C30020   SB V1, 32(S8)
9D00001C  A3C20024   SB V0, 36(S8)
17:                      u32 pwm_duty = 0;
9D000020  AFC00010   SW ZERO, 16(S8)
18:                  
19:                      switch (address)
9D000024  93C20020   LBU V0, 32(S8)
9D000028  2C430090   SLTIU V1, V0, 144
9D00002C  106002B2   BEQ V1, ZERO, 0x9D000AF8
9D000030  00000000   NOP
9D000034  00021880   SLL V1, V0, 2
9D000038  3C029D00   LUI V0, -25344
9D00003C  24420050   ADDIU V0, V0, 80
9D000040  00621021   ADDU V0, V1, V0
9D000044  8C420000   LW V0, 0(V0)
9D000048  00400008   JR V0
9D00004C  00000000   NOP
20:                      {
21:                          // reset of the PIC32 and thus the power supplies
22:                          case REG_SOFT_RST :
23:                              if (data&0x01) {
9D000290  93C20024   LBU V0, 36(S8)
9D000294  30420001   ANDI V0, V0, 1
9D000298  10400005   BEQ V0, ZERO, 0x9D0002B0
9D00029C  00000000   NOP
24:                                  soft_reset();
9D0002A0  0F4022CD   JAL soft_reset
9D0002A4  00000000   NOP
25:                              }
26:                              break;
9D0002A8  0B4002C1   J 0x9D000B04
9D0002AC  00000000   NOP
9D0002B0  0B4002C1   J 0x9D000B04
9D0002B4  00000000   NOP
27:                  
28:                          // disable/enable the power supply of arria fpga
29:                          case REG_DIS_ARRIA :
30:                              if (data&0x01) {
31:                                  #if defined (_PCB3_) || defined (_PCB4_)
32:                                  PIN_PWR_EN_ARRIA_1 = 0;
33:                                  PIN_PWR_EN_ARRIA_2 = 0;
34:                                  PIN_PWR_EN_ARRIA_3 = 0;
35:                                  PIN_PWR_ARRIA_DIS_3 = 1;
36:                                  PIN_PWR_ARRIA_DIS_2 = 1;
37:                                  PIN_PWR_ARRIA_DIS_1 = 1;
38:                                  #endif
39:                              }else{
40:                                  #if defined (_PCB3_) || defined (_PCB4_)
41:                                  PIN_PWR_ARRIA_DIS_3 = 0;
42:                                  PIN_PWR_ARRIA_DIS_2 = 0;
43:                                  PIN_PWR_ARRIA_DIS_1 = 0;
44:                                  PIN_PWR_EN_ARRIA_1 = 1;
45:                                  PIN_PWR_EN_ARRIA_2 = 1;
46:                                  PIN_PWR_EN_ARRIA_3 = 1;
47:                                  #endif
48:                              }
49:                              break;
9D000B00  00000000   NOP
50:                  
51:                          // reset any chip (@ 20MHz a nop takes 50 ns to be executed, setting an io takes 200ns)
52:                          case REG_RESETS :
53:                              if (data&0x01) {PIN_ANX_DVI_RSTN = 0;   wait_250ns; PIN_ANX_DVI_RSTN = 1;}              // at least 150 ns
9D0002B8  93C20024   LBU V0, 36(S8)
9D0002BC  30420001   ANDI V0, V0, 1
9D0002C0  1040000F   BEQ V0, ZERO, 0x9D000300
9D0002C4  00000000   NOP
9D0002C8  3C03BF88   LUI V1, -16504
9D0002CC  94626060   LHU V0, 24672(V1)
9D0002D0  7C026304   INS V0, ZERO, 12, 1
9D0002D4  A4626060   SH V0, 24672(V1)
9D0002D8  00000000   NOP
9D0002DC  00000000   NOP
9D0002E0  00000000   NOP
9D0002E4  00000000   NOP
9D0002E8  00000000   NOP
9D0002EC  3C03BF88   LUI V1, -16504
9D0002F0  94626060   LHU V0, 24672(V1)
9D0002F4  24040001   ADDIU A0, ZERO, 1
9D0002F8  7C826304   INS V0, A0, 12, 1
9D0002FC  A4626060   SH V0, 24672(V1)
54:                              if (data&0x02) {PIN_ANX_HDMI_RSTN = 0;  wait_250ns; PIN_ANX_HDMI_RSTN = 1;}             // at least 150 ns
9D000300  93C20024   LBU V0, 36(S8)
9D000304  30420002   ANDI V0, V0, 2
9D000308  1040000F   BEQ V0, ZERO, 0x9D000348
9D00030C  00000000   NOP
9D000310  3C03BF88   LUI V1, -16504
9D000314  94626060   LHU V0, 24672(V1)
9D000318  7C026B44   INS V0, ZERO, 13, 1
9D00031C  A4626060   SH V0, 24672(V1)
9D000320  00000000   NOP
9D000324  00000000   NOP
9D000328  00000000   NOP
9D00032C  00000000   NOP
9D000330  00000000   NOP
9D000334  3C03BF88   LUI V1, -16504
9D000338  94626060   LHU V0, 24672(V1)
9D00033C  24040001   ADDIU A0, ZERO, 1
9D000340  7C826B44   INS V0, A0, 13, 1
9D000344  A4626060   SH V0, 24672(V1)
55:                              if (data&0x04) {PIN_DIR9001_1_RSTN = 0; wait_250ns; PIN_DIR9001_1_RSTN = 1;}            // not specified in datasheet
9D000348  93C20024   LBU V0, 36(S8)
9D00034C  30420004   ANDI V0, V0, 4
9D000350  1040000F   BEQ V0, ZERO, 0x9D000390
9D000354  00000000   NOP
9D000358  3C03BF88   LUI V1, -16504
9D00035C  94626120   LHU V0, 24864(V1)
9D000360  7C024204   INS V0, ZERO, 8, 1
9D000364  A4626120   SH V0, 24864(V1)
9D000368  00000000   NOP
9D00036C  00000000   NOP
9D000370  00000000   NOP
9D000374  00000000   NOP
9D000378  00000000   NOP
9D00037C  3C03BF88   LUI V1, -16504
9D000380  94626120   LHU V0, 24864(V1)
9D000384  24040001   ADDIU A0, ZERO, 1
9D000388  7C824204   INS V0, A0, 8, 1
9D00038C  A4626120   SH V0, 24864(V1)
56:                              if (data&0x08) {PIN_DIR9001_2_RSTN = 0; wait_250ns; PIN_DIR9001_2_RSTN = 1;}            // not specified in datasheet
9D000390  93C20024   LBU V0, 36(S8)
9D000394  30420008   ANDI V0, V0, 8
9D000398  1040000F   BEQ V0, ZERO, 0x9D0003D8
9D00039C  00000000   NOP
9D0003A0  3C03BF88   LUI V1, -16504
9D0003A4  94626120   LHU V0, 24864(V1)
9D0003A8  7C024A44   INS V0, ZERO, 9, 1
9D0003AC  A4626120   SH V0, 24864(V1)
9D0003B0  00000000   NOP
9D0003B4  00000000   NOP
9D0003B8  00000000   NOP
9D0003BC  00000000   NOP
9D0003C0  00000000   NOP
9D0003C4  3C03BF88   LUI V1, -16504
9D0003C8  94626120   LHU V0, 24864(V1)
9D0003CC  24040001   ADDIU A0, ZERO, 1
9D0003D0  7C824A44   INS V0, A0, 9, 1
9D0003D4  A4626120   SH V0, 24864(V1)
57:                              if (data&0x10) {PIN_TLV320_A_RSTN = 0;  wait_250ns; PIN_TLV320_A_RSTN = 1;}             // not specified in datasheet
9D0003D8  93C20024   LBU V0, 36(S8)
9D0003DC  30420010   ANDI V0, V0, 16
9D0003E0  1040000F   BEQ V0, ZERO, 0x9D000420
9D0003E4  00000000   NOP
9D0003E8  3C03BF88   LUI V1, -16504
9D0003EC  94626060   LHU V0, 24672(V1)
9D0003F0  7C027384   INS V0, ZERO, 14, 1
9D0003F4  A4626060   SH V0, 24672(V1)
9D0003F8  00000000   NOP
9D0003FC  00000000   NOP
9D000400  00000000   NOP
9D000404  00000000   NOP
9D000408  00000000   NOP
9D00040C  3C03BF88   LUI V1, -16504
9D000410  94626060   LHU V0, 24672(V1)
9D000414  24040001   ADDIU A0, ZERO, 1
9D000418  7C827384   INS V0, A0, 14, 1
9D00041C  A4626060   SH V0, 24672(V1)
58:                              if (data&0x20) {PIN_TLV320_B_RSTN = 0;  wait_250ns; PIN_TLV320_B_RSTN = 1;}             // not specified in datasheet
9D000420  93C20024   LBU V0, 36(S8)
9D000424  30420020   ANDI V0, V0, 32
9D000428  1040000F   BEQ V0, ZERO, 0x9D000468
9D00042C  00000000   NOP
9D000430  3C03BF88   LUI V1, -16504
9D000434  94626060   LHU V0, 24672(V1)
9D000438  7C027BC4   INS V0, ZERO, 15, 1
9D00043C  A4626060   SH V0, 24672(V1)
9D000440  00000000   NOP
9D000444  00000000   NOP
9D000448  00000000   NOP
9D00044C  00000000   NOP
9D000450  00000000   NOP
9D000454  3C03BF88   LUI V1, -16504
9D000458  94626060   LHU V0, 24672(V1)
9D00045C  24040001   ADDIU A0, ZERO, 1
9D000460  7C827BC4   INS V0, A0, 15, 1
9D000464  A4626060   SH V0, 24672(V1)
59:                              #ifdef _PCB1_
60:                              if (data&0x40) {PIN_VM4400_RSTN = 0;    wait_500ns; wait_500ns; PIN_VM4400_RSTN = 1;}   // at least 1 µs (not used on PCB > 1)
61:                              #endif
62:                              if (data&0x80) {PIN_CVBS_RSTN = 0;      delay_ms(1); PIN_CVBS_RSTN = 1;}                // at least 500 ns but it needs long reset because of the 1uF capa)
9D000468  83C20024   LB V0, 36(S8)
9D00046C  0441000D   BGEZ V0, 0x9D0004A4
9D000470  00000000   NOP
9D000474  3C03BF88   LUI V1, -16504
9D000478  946260E0   LHU V0, 24800(V1)
9D00047C  7C027BC4   INS V0, ZERO, 15, 1
9D000480  A46260E0   SH V0, 24800(V1)
9D000484  0F40218B   JAL delay_ms
9D000488  24040001   ADDIU A0, ZERO, 1
9D00048C  3C03BF88   LUI V1, -16504
9D000490  946260E0   LHU V0, 24800(V1)
9D000494  24040001   ADDIU A0, ZERO, 1
9D000498  7C827BC4   INS V0, A0, 15, 1
63:                              break;
9D00049C  0B4002C1   J 0x9D000B04
9D0004A0  A46260E0   SH V0, 24800(V1)
9D0004A4  0B4002C1   J 0x9D000B04
9D0004A8  00000000   NOP
64:                  
65:                          // clear interrupt flag
66:                          case REG_IT_CLEAR :
67:                              if (data&0x01) g.it_cause.temp_hot = 0;
9D0004AC  93C20024   LBU V0, 36(S8)
9D0004B0  30420001   ANDI V0, V0, 1
9D0004B4  10400006   BEQ V0, ZERO, 0x9D0004D0
9D0004B8  00000000   NOP
9D0004BC  3C02A000   LUI V0, -24576
9D0004C0  2443000C   ADDIU V1, V0, 12
9D0004C4  9062004A   LBU V0, 74(V1)
9D0004C8  7C020844   INS V0, ZERO, 1, 1
9D0004CC  A062004A   SB V0, 74(V1)
68:                              if (data&0x02) g.it_cause.temp_cold = 0;
9D0004D0  93C20024   LBU V0, 36(S8)
9D0004D4  30420002   ANDI V0, V0, 2
9D0004D8  10400006   BEQ V0, ZERO, 0x9D0004F4
9D0004DC  00000000   NOP
9D0004E0  3C02A000   LUI V0, -24576
9D0004E4  2443000C   ADDIU V1, V0, 12
9D0004E8  9062004A   LBU V0, 74(V1)
9D0004EC  7C021084   INS V0, ZERO, 2, 1
9D0004F0  A062004A   SB V0, 74(V1)
69:                              if (data&0x04) g.it_cause.fan_slow = 0;
9D0004F4  93C20024   LBU V0, 36(S8)
9D0004F8  30420004   ANDI V0, V0, 4
9D0004FC  10400006   BEQ V0, ZERO, 0x9D000518
9D000500  00000000   NOP
9D000504  3C02A000   LUI V0, -24576
9D000508  2443000C   ADDIU V1, V0, 12
9D00050C  9062004A   LBU V0, 74(V1)
9D000510  7C0218C4   INS V0, ZERO, 3, 1
9D000514  A062004A   SB V0, 74(V1)
70:                              if (data&0x08) g.it_cause.power_sup = 0;
9D000518  93C20024   LBU V0, 36(S8)
9D00051C  30420008   ANDI V0, V0, 8
9D000520  10400006   BEQ V0, ZERO, 0x9D00053C
9D000524  00000000   NOP
9D000528  3C02A000   LUI V0, -24576
9D00052C  2443000C   ADDIU V1, V0, 12
9D000530  9062004A   LBU V0, 74(V1)
9D000534  7C022104   INS V0, ZERO, 4, 1
9D000538  A062004A   SB V0, 74(V1)
71:                              if (data&0x10) g.it_cause.low_power = 0;
9D00053C  93C20024   LBU V0, 36(S8)
9D000540  30420010   ANDI V0, V0, 16
9D000544  10400007   BEQ V0, ZERO, 0x9D000564
9D000548  00000000   NOP
9D00054C  3C02A000   LUI V0, -24576
9D000550  2443000C   ADDIU V1, V0, 12
9D000554  9062004A   LBU V0, 74(V1)
9D000558  7C022944   INS V0, ZERO, 5, 1
72:                              break;
9D00055C  0B4002C1   J 0x9D000B04
9D000560  A062004A   SB V0, 74(V1)
9D000564  0B4002C1   J 0x9D000B04
9D000568  00000000   NOP
73:                  
74:                          // set high temperature threshold
75:                          case REG_TMP_THRES_L :
76:                              g.temp_too_low = data;
9D00056C  83C30024   LB V1, 36(S8)
9D000570  3C02A000   LUI V0, -24576
9D000574  2442000C   ADDIU V0, V0, 12
77:                              break;
9D000578  0B4002C1   J 0x9D000B04
9D00057C  A0430001   SB V1, 1(V0)
78:                  
79:                          // set low temperature threshold
80:                          case REG_TMP_THRES_H :
81:                              g.temp_warning = data;
9D000580  83C30024   LB V1, 36(S8)
9D000584  3C02A000   LUI V0, -24576
9D000588  2442000C   ADDIU V0, V0, 12
82:                              break;
9D00058C  0B4002C1   J 0x9D000B04
9D000590  A0430002   SB V1, 2(V0)
83:                  
84:                          // set speed threshold
85:                          case REG_SPD_THRES :
86:                              g.fan_speed_threshold = data;
9D000594  93C20024   LBU V0, 36(S8)
9D000598  3043FFFF   ANDI V1, V0, -1
9D00059C  3C02A000   LUI V0, -24576
9D0005A0  2442000C   ADDIU V0, V0, 12
87:                              break;
9D0005A4  0B4002C1   J 0x9D000B04
9D0005A8  A4430020   SH V1, 32(V0)
88:                  
89:                          // reboot SoC
90:                          case REG_RBT_SOC :
91:                              #if defined (_PCB1_) || defined (_PCB2_) || defined (_PCB3_) || defined (_PCB4_)
92:                                  PIN_SOC_RSTN = 0;
93:                                  wait_500ns;
94:                                  PIN_SOC_RSTN = 1;
95:                              #elif defined (_PCB5_)
96:                                  PIN_SOC_RSTN = 1;
9D0005AC  3C03BF88   LUI V1, -16504
9D0005B0  94626020   LHU V0, 24608(V1)
9D0005B4  24040001   ADDIU A0, ZERO, 1
9D0005B8  7C824A44   INS V0, A0, 9, 1
9D0005BC  A4626020   SH V0, 24608(V1)
97:                                  wait_500ns;
9D0005C0  00000000   NOP
9D0005C4  00000000   NOP
9D0005C8  00000000   NOP
9D0005CC  00000000   NOP
9D0005D0  00000000   NOP
9D0005D4  00000000   NOP
9D0005D8  00000000   NOP
9D0005DC  00000000   NOP
9D0005E0  00000000   NOP
9D0005E4  00000000   NOP
98:                                  PIN_SOC_RSTN = 0;
9D0005E8  3C03BF88   LUI V1, -16504
9D0005EC  94626020   LHU V0, 24608(V1)
9D0005F0  7C024A44   INS V0, ZERO, 9, 1
99:                              #endif
100:                             break;
9D0005F4  0B4002C1   J 0x9D000B04
9D0005F8  A4626020   SH V0, 24608(V1)
101:                 
102:                         // set the speed of blinking led
103:                         case REG_LED_SPEED :
104:                             g.led_speed = data;
9D0005FC  3C02A000   LUI V0, -24576
9D000600  2442000C   ADDIU V0, V0, 12
9D000604  93C30024   LBU V1, 36(S8)
9D000608  A0430048   SB V1, 72(V0)
105:                             if       (data <  50){
9D00060C  93C20024   LBU V0, 36(S8)
9D000610  2C420032   SLTIU V0, V0, 50
9D000614  10400006   BEQ V0, ZERO, 0x9D000630
9D000618  00000000   NOP
106:                                 timer_init(TIMER_1, TMR_10MS);
9D00061C  00002021   ADDU A0, ZERO, ZERO
9D000620  0F400F08   JAL timer_init
9D000624  24050C34   ADDIU A1, ZERO, 3124
9D000628  0B4001B8   J 0x9D0006E0
9D00062C  00000000   NOP
107:                             }else if (data >=  50 && data < 100){
9D000630  93C20024   LBU V0, 36(S8)
9D000634  2C420032   SLTIU V0, V0, 50
9D000638  1440000A   BNE V0, ZERO, 0x9D000664
9D00063C  00000000   NOP
9D000640  93C20024   LBU V0, 36(S8)
9D000644  2C420064   SLTIU V0, V0, 100
9D000648  10400006   BEQ V0, ZERO, 0x9D000664
9D00064C  00000000   NOP
108:                                 timer_init(TIMER_1, TMR_25MS);
9D000650  00002021   ADDU A0, ZERO, ZERO
9D000654  0F400F08   JAL timer_init
9D000658  24051E84   ADDIU A1, ZERO, 7812
9D00065C  0B4001B8   J 0x9D0006E0
9D000660  00000000   NOP
109:                             }else if (data >= 100 && data < 150){
9D000664  93C20024   LBU V0, 36(S8)
9D000668  2C420064   SLTIU V0, V0, 100
9D00066C  1440000A   BNE V0, ZERO, 0x9D000698
9D000670  00000000   NOP
9D000674  93C20024   LBU V0, 36(S8)
9D000678  2C420096   SLTIU V0, V0, 150
9D00067C  10400006   BEQ V0, ZERO, 0x9D000698
9D000680  00000000   NOP
110:                                 timer_init(TIMER_1, TMR_50MS);
9D000684  00002021   ADDU A0, ZERO, ZERO
9D000688  0F400F08   JAL timer_init
9D00068C  24053D08   ADDIU A1, ZERO, 15624
9D000690  0B4001B8   J 0x9D0006E0
9D000694  00000000   NOP
111:                             }else if (data >= 150 && data < 200){
9D000698  93C20024   LBU V0, 36(S8)
9D00069C  2C420096   SLTIU V0, V0, 150
9D0006A0  1440000A   BNE V0, ZERO, 0x9D0006CC
9D0006A4  00000000   NOP
9D0006A8  93C20024   LBU V0, 36(S8)
9D0006AC  2C4200C8   SLTIU V0, V0, 200
9D0006B0  10400006   BEQ V0, ZERO, 0x9D0006CC
9D0006B4  00000000   NOP
112:                                 timer_init(TIMER_1, TMR_100MS);
9D0006B8  00002021   ADDU A0, ZERO, ZERO
9D0006BC  0F400F08   JAL timer_init
9D0006C0  24057A10   ADDIU A1, ZERO, 31248
9D0006C4  0B4001B8   J 0x9D0006E0
9D0006C8  00000000   NOP
113:                             }else{
114:                                 timer_init(TIMER_1, TMR_200MS);
9D0006CC  00002021   ADDU A0, ZERO, ZERO
9D0006D0  0F400F08   JAL timer_init
9D0006D4  3405F424   ORI A1, ZERO, -3036
115:                             }
116:                             break;
9D0006D8  0B4002C1   J 0x9D000B04
9D0006DC  00000000   NOP
9D0006E0  0B4002C1   J 0x9D000B04
9D0006E4  00000000   NOP
117:                 
118:                         // set the speed of the fan
119:                         case REG_FAN_SET_SPEED :
120:                             lm63_set_fan_speed(I2C_BUS_2, data);            // either the LM63 controller
9D0006E8  93C20024   LBU V0, 36(S8)
9D0006EC  24040001   ADDIU A0, ZERO, 1
9D0006F0  0F40193E   JAL lm63_set_fan_speed
9D0006F4  00402821   ADDU A1, V0, ZERO
121:                 
122:                             if (data <= 100){
9D0006F8  93C20024   LBU V0, 36(S8)
9D0006FC  2C420065   SLTIU V0, V0, 101
9D000700  10400004   BEQ V0, ZERO, 0x9D000714
9D000704  00000000   NOP
123:                                 pwm_duty = data;
9D000708  93C20024   LBU V0, 36(S8)
9D00070C  0B4001C7   J 0x9D00071C
9D000710  AFC20010   SW V0, 16(S8)
124:                             }else{
125:                                 pwm_duty = 100;
9D000714  24020064   ADDIU V0, ZERO, 100
9D000718  AFC20010   SW V0, 16(S8)
126:                             }
127:                             pwm_set_duty_cycle(PWM_1, pwm_duty*PWM_FREQ_COEF);  // or the PWM of the PIC32
9D00071C  8FC20010   LW V0, 16(S8)
9D000720  00021040   SLL V0, V0, 1
9D000724  00021880   SLL V1, V0, 2
9D000728  00431021   ADDU V0, V0, V1
9D00072C  00002021   ADDU A0, ZERO, ZERO
9D000730  0F40205A   JAL pwm_set_duty_cycle
9D000734  00402821   ADDU A1, V0, ZERO
128:                             break;
9D000738  0B4002C1   J 0x9D000B04
9D00073C  00000000   NOP
129:                 
130:                         // the speed of the fan is setted by the SoC
131:                         case REG_FAN_SET_BY_SOC :
132:                             if (data) g.fan_speed_by_soc = true;
9D000740  93C20024   LBU V0, 36(S8)
9D000744  10400006   BEQ V0, ZERO, 0x9D000760
9D000748  00000000   NOP
9D00074C  3C02A000   LUI V0, -24576
9D000750  2442000C   ADDIU V0, V0, 12
9D000754  24030001   ADDIU V1, ZERO, 1
133:                             else      g.fan_speed_by_soc = false;
9D000760  3C02A000   LUI V0, -24576
9D000764  2442000C   ADDIU V0, V0, 12
134:                             break;
9D000758  0B4002C1   J 0x9D000B04
9D00075C  AC430044   SW V1, 68(V0)
9D000768  0B4002C1   J 0x9D000B04
9D00076C  AC400044   SW ZERO, 68(V0)
135:                 
136:                         // enable interrupts
137:                         case REG_IT_EN :
138:                             g.it_en.reg = data;
9D000770  3C02A000   LUI V0, -24576
9D000774  2442000C   ADDIU V0, V0, 12
9D000778  93C30024   LBU V1, 36(S8)
139:                             break;
9D00077C  0B4002C1   J 0x9D000B04
9D000780  A043004B   SB V1, 75(V0)
140:                 
141:                         // permits to debug r/w accesses
142:                         case REG_DEBUG :
143:                             g.reg_debug = data;
9D000784  3C02A000   LUI V0, -24576
9D000788  2442000C   ADDIU V0, V0, 12
9D00078C  93C30024   LBU V1, 36(S8)
144:                             break;
9D000790  0B4002C1   J 0x9D000B04
9D000794  A0430049   SB V1, 73(V0)
145:                 
146:                         // target temperature to be reached
147:                         case REG_TEMP_TARGET :
148:                             g.temp_target = data;
9D000798  83C30024   LB V1, 36(S8)
9D00079C  3C02A000   LUI V0, -24576
149:                             break;
9D0007A0  0B4002C1   J 0x9D000B04
9D0007A4  A043000C   SB V1, 12(V0)
150:                 
151:                         // critical temperature at which the system will shut down
152:                         case REG_TEMP_CRITICAL :
153:                             g.temp_critical = data;
9D0007A8  83C30024   LB V1, 36(S8)
9D0007AC  3C02A000   LUI V0, -24576
9D0007B0  2442000C   ADDIU V0, V0, 12
154:                             break;
9D0007B4  0B4002C1   J 0x9D000B04
9D0007B8  A0430004   SB V1, 4(V0)
155:                 
156:                         // temperature below which the fan is off
157:                         case REG_TEMP_NO_FAN :
158:                             g.temp_too_low = data;
9D0007BC  83C30024   LB V1, 36(S8)
9D0007C0  3C02A000   LUI V0, -24576
9D0007C4  2442000C   ADDIU V0, V0, 12
159:                             break;
9D0007C8  0B4002C1   J 0x9D000B04
9D0007CC  A0430001   SB V1, 1(V0)
160:                 
161:                         case REG_LED_PATTERN :
162:                             g.led_pattern = (LED_PATTERN)data;
9D0007D0  93C30024   LBU V1, 36(S8)
9D0007D4  3C02A000   LUI V0, -24576
9D0007D8  2442000C   ADDIU V0, V0, 12
163:                             break;
9D0007DC  0B4002C1   J 0x9D000B04
9D0007E0  AC43007C   SW V1, 124(V0)
164:                 
165:                         case REG_A10_ENC_TEMP_MSB :
166:                             if (g.arria_activated == true){
9D0007E4  3C02A000   LUI V0, -24576
9D0007E8  2442000C   ADDIU V0, V0, 12
9D0007EC  8C43001C   LW V1, 28(V0)
9D0007F0  24020001   ADDIU V0, ZERO, 1
9D0007F4  1462000F   BNE V1, V0, 0x9D000834
9D0007F8  00000000   NOP
167:                                 g.temp_sensors[FPGA_ENC] |= data<<8;
9D0007FC  3C02A000   LUI V0, -24576
9D000800  2442000C   ADDIU V0, V0, 12
9D000804  9442000E   LHU V0, 14(V0)
9D000808  7C021E20   SEH V1, V0
9D00080C  93C20024   LBU V0, 36(S8)
9D000810  00021200   SLL V0, V0, 8
9D000814  7C021620   SEH V0, V0
9D000818  00621025   OR V0, V1, V0
9D00081C  7C021620   SEH V0, V0
9D000820  3043FFFF   ANDI V1, V0, -1
9D000824  3C02A000   LUI V0, -24576
9D000828  2442000C   ADDIU V0, V0, 12
168:                             }
169:                             break;
9D00082C  0B4002C1   J 0x9D000B04
9D000830  A443000E   SH V1, 14(V0)
9D000834  0B4002C1   J 0x9D000B04
9D000838  00000000   NOP
170:                 
171:                         case REG_A10_ENC_TEMP_LSB :
172:                             if (g.arria_activated == true){
9D00083C  3C02A000   LUI V0, -24576
9D000840  2442000C   ADDIU V0, V0, 12
9D000844  8C43001C   LW V1, 28(V0)
9D000848  24020001   ADDIU V0, ZERO, 1
9D00084C  1462000C   BNE V1, V0, 0x9D000880
9D000850  00000000   NOP
173:                                 g.temp_sensors[FPGA_ENC] |= data;
9D000854  3C02A000   LUI V0, -24576
9D000858  2442000C   ADDIU V0, V0, 12
9D00085C  9443000E   LHU V1, 14(V0)
9D000860  93C20024   LBU V0, 36(S8)
9D000864  3042FFFF   ANDI V0, V0, -1
9D000868  00621025   OR V0, V1, V0
9D00086C  3043FFFF   ANDI V1, V0, -1
9D000870  3C02A000   LUI V0, -24576
9D000874  2442000C   ADDIU V0, V0, 12
174:                             }
175:                             break;
9D000878  0B4002C1   J 0x9D000B04
9D00087C  A443000E   SH V1, 14(V0)
9D000880  0B4002C1   J 0x9D000B04
9D000884  00000000   NOP
176:                 
177:                         case REG_A10_IO_TEMP_MSB :
178:                             if (g.arria_activated == true){
9D000888  3C02A000   LUI V0, -24576
9D00088C  2442000C   ADDIU V0, V0, 12
9D000890  8C43001C   LW V1, 28(V0)
9D000894  24020001   ADDIU V0, ZERO, 1
9D000898  1462000F   BNE V1, V0, 0x9D0008D8
9D00089C  00000000   NOP
179:                                 g.temp_sensors[FPGA_IO] |= data<<8;
9D0008A0  3C02A000   LUI V0, -24576
9D0008A4  2442000C   ADDIU V0, V0, 12
9D0008A8  94420010   LHU V0, 16(V0)
9D0008AC  7C021E20   SEH V1, V0
9D0008B0  93C20024   LBU V0, 36(S8)
9D0008B4  00021200   SLL V0, V0, 8
9D0008B8  7C021620   SEH V0, V0
9D0008BC  00621025   OR V0, V1, V0
9D0008C0  7C021620   SEH V0, V0
9D0008C4  3043FFFF   ANDI V1, V0, -1
9D0008C8  3C02A000   LUI V0, -24576
9D0008CC  2442000C   ADDIU V0, V0, 12
180:                             }
181:                             break;
9D0008D0  0B4002C1   J 0x9D000B04
9D0008D4  A4430010   SH V1, 16(V0)
9D0008D8  0B4002C1   J 0x9D000B04
9D0008DC  00000000   NOP
182:                 
183:                         case REG_A10_IO_TEMP_LSB :
184:                             if (g.arria_activated == true){
9D0008E0  3C02A000   LUI V0, -24576
9D0008E4  2442000C   ADDIU V0, V0, 12
9D0008E8  8C43001C   LW V1, 28(V0)
9D0008EC  24020001   ADDIU V0, ZERO, 1
9D0008F0  1462000C   BNE V1, V0, 0x9D000924
9D0008F4  00000000   NOP
185:                                 g.temp_sensors[FPGA_IO] |= data;
9D0008F8  3C02A000   LUI V0, -24576
9D0008FC  2442000C   ADDIU V0, V0, 12
9D000900  94430010   LHU V1, 16(V0)
9D000904  93C20024   LBU V0, 36(S8)
9D000908  3042FFFF   ANDI V0, V0, -1
9D00090C  00621025   OR V0, V1, V0
9D000910  3043FFFF   ANDI V1, V0, -1
9D000914  3C02A000   LUI V0, -24576
9D000918  2442000C   ADDIU V0, V0, 12
186:                             }
187:                             break;
9D00091C  0B4002C1   J 0x9D000B04
9D000920  A4430010   SH V1, 16(V0)
9D000924  0B4002C1   J 0x9D000B04
9D000928  00000000   NOP
188:                 
189:                         case REG_ARRIA_STATUS :
190:                             if (data){
9D00092C  93C20024   LBU V0, 36(S8)
9D000930  10400006   BEQ V0, ZERO, 0x9D00094C
9D000934  00000000   NOP
191:                                 g.arria_activated = true;
9D000938  3C02A000   LUI V0, -24576
9D00093C  2442000C   ADDIU V0, V0, 12
9D000940  24030001   ADDIU V1, ZERO, 1
192:                             }else{
193:                                 g.arria_activated = false;
9D00094C  3C02A000   LUI V0, -24576
9D000950  2442000C   ADDIU V0, V0, 12
194:                             }
195:                             break;
9D000944  0B4002C1   J 0x9D000B04
9D000948  AC43001C   SW V1, 28(V0)
9D000954  0B4002C1   J 0x9D000B04
9D000958  AC40001C   SW ZERO, 28(V0)
196:                 
197:                         case REG_I2C_ERROR :
198:                             if (data){
9D00095C  93C20024   LBU V0, 36(S8)
9D000960  10400005   BEQ V0, ZERO, 0x9D000978
9D000964  00000000   NOP
199:                                 g.i2c_error = false;
9D000968  3C02A000   LUI V0, -24576
9D00096C  2442000C   ADDIU V0, V0, 12
200:                             }
201:                             break;
9D000970  0B4002C1   J 0x9D000B04
9D000974  AC400080   SW ZERO, 128(V0)
9D000978  0B4002C1   J 0x9D000B04
9D00097C  00000000   NOP
202:                 
203:                         case REG_DISABLE_FAN_DCDC :
204:                             if (data == 0){
9D000980  93C20024   LBU V0, 36(S8)
9D000984  14400006   BNE V0, ZERO, 0x9D0009A0
9D000988  00000000   NOP
205:                                 PIN_PWR_EN_FAN = 0;
9D00098C  3C03BF88   LUI V1, -16504
9D000990  94626160   LHU V0, 24928(V1)
9D000994  7C020004   INS V0, ZERO, 0, 1
206:                             }else{
207:                                 PIN_PWR_EN_FAN = 1;
9D0009A0  3C03BF88   LUI V1, -16504
9D0009A4  94626160   LHU V0, 24928(V1)
9D0009A8  24040001   ADDIU A0, ZERO, 1
9D0009AC  7C820004   INS V0, A0, 0, 1
208:                             }
209:                             break;
9D000998  0B4002C1   J 0x9D000B04
9D00099C  A4626160   SH V0, 24928(V1)
9D0009B0  0B4002C1   J 0x9D000B04
9D0009B4  A4626160   SH V0, 24928(V1)
210:                 
211:                         // debug
212:                         case REG_DEBUG_0 :      g.debug0 = data;        break;
9D0009B8  3C02A000   LUI V0, -24576
9D0009BC  2442000C   ADDIU V0, V0, 12
9D0009C0  93C30024   LBU V1, 36(S8)
9D0009C4  0B4002C1   J 0x9D000B04
9D0009C8  A0430084   SB V1, 132(V0)
213:                         case REG_DEBUG_1 :      g.debug1 = data;        break;
9D0009CC  3C02A000   LUI V0, -24576
9D0009D0  2442000C   ADDIU V0, V0, 12
9D0009D4  93C30024   LBU V1, 36(S8)
9D0009D8  0B4002C1   J 0x9D000B04
9D0009DC  A0430085   SB V1, 133(V0)
214:                         case REG_DEBUG_2 :      g.debug2 = data;        break;
9D0009E0  3C02A000   LUI V0, -24576
9D0009E4  2442000C   ADDIU V0, V0, 12
9D0009E8  93C30024   LBU V1, 36(S8)
9D0009EC  0B4002C1   J 0x9D000B04
9D0009F0  A0430086   SB V1, 134(V0)
215:                         case REG_DEBUG_3 :      g.debug3 = data;        break;
9D0009F4  3C02A000   LUI V0, -24576
9D0009F8  2442000C   ADDIU V0, V0, 12
9D0009FC  93C30024   LBU V1, 36(S8)
9D000A00  0B4002C1   J 0x9D000B04
9D000A04  A0430087   SB V1, 135(V0)
216:                         case REG_DEBUG_4 :      g.debug4 = data;        break;
9D000A08  3C02A000   LUI V0, -24576
9D000A0C  2442000C   ADDIU V0, V0, 12
9D000A10  93C30024   LBU V1, 36(S8)
9D000A14  0B4002C1   J 0x9D000B04
9D000A18  A0430088   SB V1, 136(V0)
217:                         case REG_DEBUG_5 :      g.debug5 = data;        break;
9D000A1C  3C02A000   LUI V0, -24576
9D000A20  2442000C   ADDIU V0, V0, 12
9D000A24  93C30024   LBU V1, 36(S8)
9D000A28  0B4002C1   J 0x9D000B04
9D000A2C  A0430089   SB V1, 137(V0)
218:                         case REG_DEBUG_6 :      g.debug6 = data;        break;
9D000A30  3C02A000   LUI V0, -24576
9D000A34  2442000C   ADDIU V0, V0, 12
9D000A38  93C30024   LBU V1, 36(S8)
9D000A3C  0B4002C1   J 0x9D000B04
9D000A40  A043008A   SB V1, 138(V0)
219:                         case REG_DEBUG_7 :      g.debug7 = data;        break;
9D000A44  3C02A000   LUI V0, -24576
9D000A48  2442000C   ADDIU V0, V0, 12
9D000A4C  93C30024   LBU V1, 36(S8)
9D000A50  0B4002C1   J 0x9D000B04
9D000A54  A043008B   SB V1, 139(V0)
220:                         case REG_DEBUG_8 :      g.debug8 = data;        break;
9D000A58  3C02A000   LUI V0, -24576
9D000A5C  2442000C   ADDIU V0, V0, 12
9D000A60  93C30024   LBU V1, 36(S8)
9D000A64  0B4002C1   J 0x9D000B04
9D000A68  A043008C   SB V1, 140(V0)
221:                         case REG_DEBUG_9 :      g.debug9 = data;        break;
9D000A6C  3C02A000   LUI V0, -24576
9D000A70  2442000C   ADDIU V0, V0, 12
9D000A74  93C30024   LBU V1, 36(S8)
9D000A78  0B4002C1   J 0x9D000B04
9D000A7C  A043008D   SB V1, 141(V0)
222:                         case REG_DEBUG_10 :     g.debug9 = data;        break;
9D000A80  3C02A000   LUI V0, -24576
9D000A84  2442000C   ADDIU V0, V0, 12
9D000A88  93C30024   LBU V1, 36(S8)
9D000A8C  0B4002C1   J 0x9D000B04
9D000A90  A043008D   SB V1, 141(V0)
223:                         case REG_DEBUG_11 :     g.debug9 = data;        break;
9D000A94  3C02A000   LUI V0, -24576
9D000A98  2442000C   ADDIU V0, V0, 12
9D000A9C  93C30024   LBU V1, 36(S8)
9D000AA0  0B4002C1   J 0x9D000B04
9D000AA4  A043008D   SB V1, 141(V0)
224:                         case REG_DEBUG_12 :     g.debug9 = data;        break;
9D000AA8  3C02A000   LUI V0, -24576
9D000AAC  2442000C   ADDIU V0, V0, 12
9D000AB0  93C30024   LBU V1, 36(S8)
9D000AB4  0B4002C1   J 0x9D000B04
9D000AB8  A043008D   SB V1, 141(V0)
225:                         case REG_DEBUG_13 :     g.debug9 = data;        break;
9D000ABC  3C02A000   LUI V0, -24576
9D000AC0  2442000C   ADDIU V0, V0, 12
9D000AC4  93C30024   LBU V1, 36(S8)
9D000AC8  0B4002C1   J 0x9D000B04
9D000ACC  A043008D   SB V1, 141(V0)
226:                         case REG_DEBUG_14 :     g.debug9 = data;        break;
9D000AD0  3C02A000   LUI V0, -24576
9D000AD4  2442000C   ADDIU V0, V0, 12
9D000AD8  93C30024   LBU V1, 36(S8)
9D000ADC  0B4002C1   J 0x9D000B04
9D000AE0  A043008D   SB V1, 141(V0)
227:                         case REG_DEBUG_15 :     g.debug9 = data;        break;
9D000AE4  3C02A000   LUI V0, -24576
9D000AE8  2442000C   ADDIU V0, V0, 12
9D000AEC  93C30024   LBU V1, 36(S8)
9D000AF0  0B4002C1   J 0x9D000B04
9D000AF4  A043008D   SB V1, 141(V0)
228:                 
229:                         default :
230:                             return WARNING;
9D000AF8  0B4002C2   J 0x9D000B08
9D000AFC  24020003   ADDIU V0, ZERO, 3
231:                             break;
232:                     }
233:                 
234:                     return SUCCESS;
9D000B04  00001021   ADDU V0, ZERO, ZERO
235:                 }
9D000B08  03C0E821   ADDU SP, S8, ZERO
9D000B0C  8FBF001C   LW RA, 28(SP)
9D000B10  8FBE0018   LW S8, 24(SP)
9D000B14  03E00008   JR RA
9D000B18  27BD0020   ADDIU SP, SP, 32
236:                 
237:                 
238:                 
239:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
240:                 //---------------------------- I2C Read Operation -----------------------------
241:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
242:                 RESULT i2c_read_to_master(u8 address, u8 *data)
243:                 {
9D000B1C  27BDFFF8   ADDIU SP, SP, -8
9D000B20  AFBE0004   SW S8, 4(SP)
9D000B24  03A0F021   ADDU S8, SP, ZERO
9D000B28  00801021   ADDU V0, A0, ZERO
9D000B2C  AFC5000C   SW A1, 12(S8)
9D000B30  A3C20008   SB V0, 8(S8)
244:                     switch (address)
9D000B34  93C20008   LBU V0, 8(S8)
9D000B38  2C430090   SLTIU V1, V0, 144
9D000B3C  106002BF   BEQ V1, ZERO, 0x9D00163C
9D000B40  00000000   NOP
9D000B44  00021880   SLL V1, V0, 2
9D000B48  3C029D00   LUI V0, -25344
9D000B4C  24420B60   ADDIU V0, V0, 2912
9D000B50  00621021   ADDU V0, V1, V0
9D000B54  8C420000   LW V0, 0(V0)
9D000B58  00400008   JR V0
9D000B5C  00000000   NOP
245:                     {
246:                         // firmware version
247:                         case REG_FIRM_VERS :        *data = VERSION;                                break;
9D000DA0  8FC2000C   LW V0, 12(S8)
9D000DA4  24030035   ADDIU V1, ZERO, 53
9D000DA8  A0430000   SB V1, 0(V0)
9D000DAC  0B400595   J 0x9D001654
9D000DB0  00000000   NOP
248:                 
249:                         // reset any chips
250:                         case REG_RESETS :           *data = 0;                                      break;
9D000DB4  8FC2000C   LW V0, 12(S8)
9D000DB8  A0400000   SB ZERO, 0(V0)
9D000DBC  0B400595   J 0x9D001654
9D000DC0  00000000   NOP
251:                 
252:                         // temperature from sensor #1
253:                         case REG_TMP_1H :           *data = (u8)(g.temp_sensors[TMP75_BR] >> 4);    break;
9D000DC4  3C02A000   LUI V0, -24576
9D000DC8  2442000C   ADDIU V0, V0, 12
9D000DCC  94420006   LHU V0, 6(V0)
9D000DD0  00021102   SRL V0, V0, 4
9D000DD4  3042FFFF   ANDI V0, V0, -1
9D000DD8  304300FF   ANDI V1, V0, 255
9D000DDC  8FC2000C   LW V0, 12(S8)
9D000DE0  A0430000   SB V1, 0(V0)
9D000DE4  0B400595   J 0x9D001654
9D000DE8  00000000   NOP
254:                         case REG_TMP_1L :           *data = (u8)(g.temp_sensors[TMP75_BR] & 0x0F);  break;
9D000DEC  3C02A000   LUI V0, -24576
9D000DF0  2442000C   ADDIU V0, V0, 12
9D000DF4  94420006   LHU V0, 6(V0)
9D000DF8  304200FF   ANDI V0, V0, 255
9D000DFC  3042000F   ANDI V0, V0, 15
9D000E00  304300FF   ANDI V1, V0, 255
9D000E04  8FC2000C   LW V0, 12(S8)
9D000E08  A0430000   SB V1, 0(V0)
9D000E0C  0B400595   J 0x9D001654
9D000E10  00000000   NOP
255:                 
256:                         // temperature from sensor #2
257:                         case REG_TMP_2H :           *data = (u8)(g.temp_sensors[TMP75_TM] >> 4);    break;
9D000E14  3C02A000   LUI V0, -24576
9D000E18  2442000C   ADDIU V0, V0, 12
9D000E1C  94420008   LHU V0, 8(V0)
9D000E20  00021102   SRL V0, V0, 4
9D000E24  3042FFFF   ANDI V0, V0, -1
9D000E28  304300FF   ANDI V1, V0, 255
9D000E2C  8FC2000C   LW V0, 12(S8)
9D000E30  A0430000   SB V1, 0(V0)
9D000E34  0B400595   J 0x9D001654
9D000E38  00000000   NOP
258:                         case REG_TMP_2L :           *data = (u8)(g.temp_sensors[TMP75_TM] & 0x0F);  break;
9D000E3C  3C02A000   LUI V0, -24576
9D000E40  2442000C   ADDIU V0, V0, 12
9D000E44  94420008   LHU V0, 8(V0)
9D000E48  304200FF   ANDI V0, V0, 255
9D000E4C  3042000F   ANDI V0, V0, 15
9D000E50  304300FF   ANDI V1, V0, 255
9D000E54  8FC2000C   LW V0, 12(S8)
9D000E58  A0430000   SB V1, 0(V0)
9D000E5C  0B400595   J 0x9D001654
9D000E60  00000000   NOP
259:                 
260:                         // temperature from sensor #3
261:                         case REG_TMP_3H :           *data = (u8)(g.temp_sensors[TMP75_MD] >> 4);    break;
9D000E64  3C02A000   LUI V0, -24576
9D000E68  2442000C   ADDIU V0, V0, 12
9D000E6C  9442000A   LHU V0, 10(V0)
9D000E70  00021102   SRL V0, V0, 4
9D000E74  3042FFFF   ANDI V0, V0, -1
9D000E78  304300FF   ANDI V1, V0, 255
9D000E7C  8FC2000C   LW V0, 12(S8)
9D000E80  A0430000   SB V1, 0(V0)
9D000E84  0B400595   J 0x9D001654
9D000E88  00000000   NOP
262:                         case REG_TMP_3L :           *data = (u8)(g.temp_sensors[TMP75_MD] & 0x0F);  break;
9D000E8C  3C02A000   LUI V0, -24576
9D000E90  2442000C   ADDIU V0, V0, 12
9D000E94  9442000A   LHU V0, 10(V0)
9D000E98  304200FF   ANDI V0, V0, 255
9D000E9C  3042000F   ANDI V0, V0, 15
9D000EA0  304300FF   ANDI V1, V0, 255
9D000EA4  8FC2000C   LW V0, 12(S8)
9D000EA8  A0430000   SB V1, 0(V0)
9D000EAC  0B400595   J 0x9D001654
9D000EB0  00000000   NOP
263:                 
264:                         // temperature from sensor #4
265:                         case REG_TMP_4H :           *data = (u8)(g.temp_sensors[TMP75_LM] >> 4);    break;
9D000EB4  3C02A000   LUI V0, -24576
9D000EB8  2442000C   ADDIU V0, V0, 12
9D000EBC  9442000C   LHU V0, 12(V0)
9D000EC0  00021102   SRL V0, V0, 4
9D000EC4  3042FFFF   ANDI V0, V0, -1
9D000EC8  304300FF   ANDI V1, V0, 255
9D000ECC  8FC2000C   LW V0, 12(S8)
9D000ED0  A0430000   SB V1, 0(V0)
9D000ED4  0B400595   J 0x9D001654
9D000ED8  00000000   NOP
266:                         case REG_TMP_4L :           *data = (u8)(g.temp_sensors[TMP75_LM] & 0x0F);  break;
9D000EDC  3C02A000   LUI V0, -24576
9D000EE0  2442000C   ADDIU V0, V0, 12
9D000EE4  9442000C   LHU V0, 12(V0)
9D000EE8  304200FF   ANDI V0, V0, 255
9D000EEC  3042000F   ANDI V0, V0, 15
9D000EF0  304300FF   ANDI V1, V0, 255
9D000EF4  8FC2000C   LW V0, 12(S8)
9D000EF8  A0430000   SB V1, 0(V0)
9D000EFC  0B400595   J 0x9D001654
9D000F00  00000000   NOP
267:                 
268:                         // temperature from lm63
269:                         case REG_TMP_LM63 :         *data = (u8)(g.lm63_data_1.temp_die);           break;
9D000F04  3C02A000   LUI V0, -24576
9D000F08  2442000C   ADDIU V0, V0, 12
9D000F0C  80420030   LB V0, 48(V0)
9D000F10  304300FF   ANDI V1, V0, 255
9D000F14  8FC2000C   LW V0, 12(S8)
9D000F18  A0430000   SB V1, 0(V0)
9D000F1C  0B400595   J 0x9D001654
9D000F20  00000000   NOP
270:                         case REG_TMP_LM63_2 :       *data = (u8)(g.lm63_data_2.temp_die);           break;
9D000F24  3C02A000   LUI V0, -24576
9D000F28  2442000C   ADDIU V0, V0, 12
9D000F2C  8042003E   LB V0, 62(V0)
9D000F30  304300FF   ANDI V1, V0, 255
9D000F34  8FC2000C   LW V0, 12(S8)
9D000F38  A0430000   SB V1, 0(V0)
9D000F3C  0B400595   J 0x9D001654
9D000F40  00000000   NOP
271:                         case REG_LM63_DIODE_TEMP_1 :*data = (u8)(g.lm63_data_1.temp_diode);         break;
9D000F44  3C02A000   LUI V0, -24576
9D000F48  2442000C   ADDIU V0, V0, 12
9D000F4C  80420032   LB V0, 50(V0)
9D000F50  304300FF   ANDI V1, V0, 255
9D000F54  8FC2000C   LW V0, 12(S8)
9D000F58  A0430000   SB V1, 0(V0)
9D000F5C  0B400595   J 0x9D001654
9D000F60  00000000   NOP
272:                         case REG_LM63_DIODE_TEMP_2 :*data = (u8)(g.lm63_data_2.temp_diode);         break;
9D000F64  3C02A000   LUI V0, -24576
9D000F68  2442000C   ADDIU V0, V0, 12
9D000F6C  80420040   LB V0, 64(V0)
9D000F70  304300FF   ANDI V1, V0, 255
9D000F74  8FC2000C   LW V0, 12(S8)
9D000F78  A0430000   SB V1, 0(V0)
9D000F7C  0B400595   J 0x9D001654
9D000F80  00000000   NOP
273:                 
274:                         // fan speed from lm63
275:                         case REG_FAN_SPD_H :        *data = (u8)(g.lm63_data_1.fan_speed>>8);       break;
9D000F84  3C02A000   LUI V0, -24576
9D000F88  2442000C   ADDIU V0, V0, 12
9D000F8C  9442002A   LHU V0, 42(V0)
9D000F90  00021202   SRL V0, V0, 8
9D000F94  3042FFFF   ANDI V0, V0, -1
9D000F98  304300FF   ANDI V1, V0, 255
9D000F9C  8FC2000C   LW V0, 12(S8)
9D000FA0  A0430000   SB V1, 0(V0)
9D000FA4  0B400595   J 0x9D001654
9D000FA8  00000000   NOP
276:                         case REG_FAN_SPD_L :        *data = (u8)(g.lm63_data_1.fan_speed&0xff);     break;
9D000FAC  3C02A000   LUI V0, -24576
9D000FB0  2442000C   ADDIU V0, V0, 12
9D000FB4  9442002A   LHU V0, 42(V0)
9D000FB8  304300FF   ANDI V1, V0, 255
9D000FBC  8FC2000C   LW V0, 12(S8)
9D000FC0  A0430000   SB V1, 0(V0)
9D000FC4  0B400595   J 0x9D001654
9D000FC8  00000000   NOP
277:                         case REG_FAN_SPD_H_2 :      *data = (u8)(g.lm63_data_2.fan_speed>>8);       break;
9D000FCC  3C02A000   LUI V0, -24576
9D000FD0  2442000C   ADDIU V0, V0, 12
9D000FD4  94420038   LHU V0, 56(V0)
9D000FD8  00021202   SRL V0, V0, 8
9D000FDC  3042FFFF   ANDI V0, V0, -1
9D000FE0  304300FF   ANDI V1, V0, 255
9D000FE4  8FC2000C   LW V0, 12(S8)
9D000FE8  A0430000   SB V1, 0(V0)
9D000FEC  0B400595   J 0x9D001654
9D000FF0  00000000   NOP
278:                         case REG_FAN_SPD_L_2 :      *data = (u8)(g.lm63_data_2.fan_speed&0xff);     break;
9D000FF4  3C02A000   LUI V0, -24576
9D000FF8  2442000C   ADDIU V0, V0, 12
9D000FFC  94420038   LHU V0, 56(V0)
9D001000  304300FF   ANDI V1, V0, 255
9D001004  8FC2000C   LW V0, 12(S8)
9D001008  A0430000   SB V1, 0(V0)
9D00100C  0B400595   J 0x9D001654
9D001010  00000000   NOP
279:                         
280:                         // power-in voltage
281:                         case REG_VOLT_IN :          *data = (u8)(g.power_in >> 2);                  break;
9D001014  3C02A000   LUI V0, -24576
9D001018  2442000C   ADDIU V0, V0, 12
9D00101C  8C420050   LW V0, 80(V0)
9D001020  00021082   SRL V0, V0, 2
9D001024  304300FF   ANDI V1, V0, 255
9D001028  8FC2000C   LW V0, 12(S8)
9D00102C  A0430000   SB V1, 0(V0)
9D001030  0B400595   J 0x9D001654
9D001034  00000000   NOP
282:                         case REG_VOLTAGE_START :    *data = (u8)(g.power_in_at_startup >> 2 );      break;
9D001038  3C02A000   LUI V0, -24576
9D00103C  2442000C   ADDIU V0, V0, 12
9D001040  8C42004C   LW V0, 76(V0)
9D001044  00021082   SRL V0, V0, 2
9D001048  304300FF   ANDI V1, V0, 255
9D00104C  8FC2000C   LW V0, 12(S8)
9D001050  A0430000   SB V1, 0(V0)
9D001054  0B400595   J 0x9D001654
9D001058  00000000   NOP
283:                         case REG_PWR_0V9_ENC :      *data = (u8)(g.power_0v9_enc >> 2);             break;
9D00105C  3C02A000   LUI V0, -24576
9D001060  2442000C   ADDIU V0, V0, 12
9D001064  8C420058   LW V0, 88(V0)
9D001068  00021082   SRL V0, V0, 2
9D00106C  304300FF   ANDI V1, V0, 255
9D001070  8FC2000C   LW V0, 12(S8)
9D001074  A0430000   SB V1, 0(V0)
9D001078  0B400595   J 0x9D001654
9D00107C  00000000   NOP
284:                         case REG_PWR_0V9_IO :       *data = (u8)(g.power_0v9_io >> 2);              break;
9D001080  3C02A000   LUI V0, -24576
9D001084  2442000C   ADDIU V0, V0, 12
9D001088  8C420054   LW V0, 84(V0)
9D00108C  00021082   SRL V0, V0, 2
9D001090  304300FF   ANDI V1, V0, 255
9D001094  8FC2000C   LW V0, 12(S8)
9D001098  A0430000   SB V1, 0(V0)
9D00109C  0B400595   J 0x9D001654
9D0010A0  00000000   NOP
285:                         case REG_PWR_1V8 :          *data = (u8)(g.power_1v8 >> 2);                 break;
9D0010A4  3C02A000   LUI V0, -24576
9D0010A8  2442000C   ADDIU V0, V0, 12
9D0010AC  8C42005C   LW V0, 92(V0)
9D0010B0  00021082   SRL V0, V0, 2
9D0010B4  304300FF   ANDI V1, V0, 255
9D0010B8  8FC2000C   LW V0, 12(S8)
9D0010BC  A0430000   SB V1, 0(V0)
9D0010C0  0B400595   J 0x9D001654
9D0010C4  00000000   NOP
286:                         case REG_PWR_3V3 :          *data = (u8)(g.power_3v3 >> 2);                 break;
9D0010C8  3C02A000   LUI V0, -24576
9D0010CC  2442000C   ADDIU V0, V0, 12
9D0010D0  8C420060   LW V0, 96(V0)
9D0010D4  00021082   SRL V0, V0, 2
9D0010D8  304300FF   ANDI V1, V0, 255
9D0010DC  8FC2000C   LW V0, 12(S8)
9D0010E0  A0430000   SB V1, 0(V0)
9D0010E4  0B400595   J 0x9D001654
9D0010E8  00000000   NOP
287:                         case REG_PWR_1V1 :          *data = (u8)(g.power_1v1 >> 2);                 break;
9D0010EC  3C02A000   LUI V0, -24576
9D0010F0  2442000C   ADDIU V0, V0, 12
9D0010F4  8C420064   LW V0, 100(V0)
9D0010F8  00021082   SRL V0, V0, 2
9D0010FC  304300FF   ANDI V1, V0, 255
9D001100  8FC2000C   LW V0, 12(S8)
9D001104  A0430000   SB V1, 0(V0)
9D001108  0B400595   J 0x9D001654
9D00110C  00000000   NOP
288:                         case REG_PWR_1V5 :          *data = (u8)(g.power_1v5 >> 2);                 break;
9D001110  3C02A000   LUI V0, -24576
9D001114  2442000C   ADDIU V0, V0, 12
9D001118  8C420068   LW V0, 104(V0)
9D00111C  00021082   SRL V0, V0, 2
9D001120  304300FF   ANDI V1, V0, 255
9D001124  8FC2000C   LW V0, 12(S8)
9D001128  A0430000   SB V1, 0(V0)
9D00112C  0B400595   J 0x9D001654
9D001130  00000000   NOP
289:                         case REG_PWR_1V0 :          *data = (u8)(g.power_1v0 >> 2);                 break;
9D001134  3C02A000   LUI V0, -24576
9D001138  2442000C   ADDIU V0, V0, 12
9D00113C  8C42006C   LW V0, 108(V0)
9D001140  00021082   SRL V0, V0, 2
9D001144  304300FF   ANDI V1, V0, 255
9D001148  8FC2000C   LW V0, 12(S8)
9D00114C  A0430000   SB V1, 0(V0)
9D001150  0B400595   J 0x9D001654
9D001154  00000000   NOP
290:                         case REG_PWR_0V9_CPU :      *data = (u8)(g.power_0v9_cpu >> 2);             break;
9D001158  3C02A000   LUI V0, -24576
9D00115C  2442000C   ADDIU V0, V0, 12
9D001160  8C420070   LW V0, 112(V0)
9D001164  00021082   SRL V0, V0, 2
9D001168  304300FF   ANDI V1, V0, 255
9D00116C  8FC2000C   LW V0, 12(S8)
9D001170  A0430000   SB V1, 0(V0)
9D001174  0B400595   J 0x9D001654
9D001178  00000000   NOP
291:                 
292:                         // interrupt cause
293:                         case REG_IT_CAUSE :         *data = g.it_cause.reg;                         break;
9D00117C  3C02A000   LUI V0, -24576
9D001180  2442000C   ADDIU V0, V0, 12
9D001184  9043004A   LBU V1, 74(V0)
9D001188  8FC2000C   LW V0, 12(S8)
9D00118C  A0430000   SB V1, 0(V0)
9D001190  0B400595   J 0x9D001654
9D001194  00000000   NOP
294:                 
295:                         // high temperature threshold
296:                         case REG_TMP_THRES_H :      *data = g.temp_warning;                         break;
9D001198  3C02A000   LUI V0, -24576
9D00119C  2442000C   ADDIU V0, V0, 12
9D0011A0  80420002   LB V0, 2(V0)
9D0011A4  304300FF   ANDI V1, V0, 255
9D0011A8  8FC2000C   LW V0, 12(S8)
9D0011AC  A0430000   SB V1, 0(V0)
9D0011B0  0B400595   J 0x9D001654
9D0011B4  00000000   NOP
297:                 
298:                         // low temperature threshold
299:                         case REG_TMP_THRES_L :      *data = g.temp_too_low;                         break;
9D0011B8  3C02A000   LUI V0, -24576
9D0011BC  2442000C   ADDIU V0, V0, 12
9D0011C0  80420001   LB V0, 1(V0)
9D0011C4  304300FF   ANDI V1, V0, 255
9D0011C8  8FC2000C   LW V0, 12(S8)
9D0011CC  A0430000   SB V1, 0(V0)
9D0011D0  0B400595   J 0x9D001654
9D0011D4  00000000   NOP
300:                 
301:                         // low fan speed threshold
302:                         case REG_SPD_THRES :        *data = g.fan_speed_threshold;                  break;
9D0011D8  3C02A000   LUI V0, -24576
9D0011DC  2442000C   ADDIU V0, V0, 12
9D0011E0  94420020   LHU V0, 32(V0)
9D0011E4  304300FF   ANDI V1, V0, 255
9D0011E8  8FC2000C   LW V0, 12(S8)
9D0011EC  A0430000   SB V1, 0(V0)
9D0011F0  0B400595   J 0x9D001654
9D0011F4  00000000   NOP
303:                 
304:                         // enable interrupts
305:                         case REG_IT_EN :            *data = g.it_en.reg;                            break;
9D0011F8  3C02A000   LUI V0, -24576
9D0011FC  2442000C   ADDIU V0, V0, 12
9D001200  9043004B   LBU V1, 75(V0)
9D001204  8FC2000C   LW V0, 12(S8)
9D001208  A0430000   SB V1, 0(V0)
9D00120C  0B400595   J 0x9D001654
9D001210  00000000   NOP
306:                 
307:                         // status of all power supplies
308:                         case REG_PS_STATUS :        *data = (u8)(g.pwr_status&0xff);                break;
9D001214  3C02A000   LUI V0, -24576
9D001218  2442000C   ADDIU V0, V0, 12
9D00121C  9442007A   LHU V0, 122(V0)
9D001220  304300FF   ANDI V1, V0, 255
9D001224  8FC2000C   LW V0, 12(S8)
9D001228  A0430000   SB V1, 0(V0)
9D00122C  0B400595   J 0x9D001654
9D001230  00000000   NOP
309:                         case REG_PS_STATUS_2 :      *data = (u8)(g.pwr_status>>8);                  break;
9D001234  3C02A000   LUI V0, -24576
9D001238  2442000C   ADDIU V0, V0, 12
9D00123C  9442007A   LHU V0, 122(V0)
9D001240  00021202   SRL V0, V0, 8
9D001244  3042FFFF   ANDI V0, V0, -1
9D001248  304300FF   ANDI V1, V0, 255
9D00124C  8FC2000C   LW V0, 12(S8)
9D001250  A0430000   SB V1, 0(V0)
9D001254  0B400595   J 0x9D001654
9D001258  00000000   NOP
310:                 
311:                         // speed of the blinking led
312:                         case REG_LED_SPEED :        *data = g.led_speed;                            break;
9D00125C  3C02A000   LUI V0, -24576
9D001260  2442000C   ADDIU V0, V0, 12
9D001264  90430048   LBU V1, 72(V0)
9D001268  8FC2000C   LW V0, 12(S8)
9D00126C  A0430000   SB V1, 0(V0)
9D001270  0B400595   J 0x9D001654
9D001274  00000000   NOP
313:                 
314:                         // the speed of the fan is controlled either by the pic or by the SoC
315:                         case REG_FAN_SET_BY_SOC :   *data = g.fan_speed_by_soc;                     break;
9D001278  3C02A000   LUI V0, -24576
9D00127C  2442000C   ADDIU V0, V0, 12
9D001280  8C420044   LW V0, 68(V0)
9D001284  304300FF   ANDI V1, V0, 255
9D001288  8FC2000C   LW V0, 12(S8)
9D00128C  A0430000   SB V1, 0(V0)
9D001290  0B400595   J 0x9D001654
9D001294  00000000   NOP
316:                 
317:                         // target temperature to be reached
318:                         case REG_TEMP_TARGET :      *data = g.temp_target;                          break;
9D001298  3C02A000   LUI V0, -24576
9D00129C  8042000C   LB V0, 12(V0)
9D0012A0  304300FF   ANDI V1, V0, 255
9D0012A4  8FC2000C   LW V0, 12(S8)
9D0012A8  A0430000   SB V1, 0(V0)
9D0012AC  0B400595   J 0x9D001654
9D0012B0  00000000   NOP
319:                 
320:                         // critical temperature at which the system will shut down
321:                         case REG_TEMP_CRITICAL :    *data = g.temp_critical;                        break;
9D0012B4  3C02A000   LUI V0, -24576
9D0012B8  2442000C   ADDIU V0, V0, 12
9D0012BC  80420004   LB V0, 4(V0)
9D0012C0  304300FF   ANDI V1, V0, 255
9D0012C4  8FC2000C   LW V0, 12(S8)
9D0012C8  A0430000   SB V1, 0(V0)
9D0012CC  0B400595   J 0x9D001654
9D0012D0  00000000   NOP
322:                 
323:                         // temperature below which the fan is off
324:                         case REG_TEMP_NO_FAN :      *data = g.temp_fan_off;                         break;
9D0012D4  3C02A000   LUI V0, -24576
9D0012D8  2442000C   ADDIU V0, V0, 12
9D0012DC  80420003   LB V0, 3(V0)
9D0012E0  304300FF   ANDI V1, V0, 255
9D0012E4  8FC2000C   LW V0, 12(S8)
9D0012E8  A0430000   SB V1, 0(V0)
9D0012EC  0B400595   J 0x9D001654
9D0012F0  00000000   NOP
325:                 
326:                         // permits to debug r/w accesses
327:                         case REG_DEBUG :            *data = g.reg_debug;                            break;
9D0012F4  3C02A000   LUI V0, -24576
9D0012F8  2442000C   ADDIU V0, V0, 12
9D0012FC  90430049   LBU V1, 73(V0)
9D001300  8FC2000C   LW V0, 12(S8)
9D001304  A0430000   SB V1, 0(V0)
9D001308  0B400595   J 0x9D001654
9D00130C  00000000   NOP
328:                 
329:                         // LM63 status
330:                         case REG_FAN_CFG1 :         *data = g.lm63_data_1.config;                   break;
9D001310  3C02A000   LUI V0, -24576
9D001314  2442000C   ADDIU V0, V0, 12
9D001318  90430028   LBU V1, 40(V0)
9D00131C  8FC2000C   LW V0, 12(S8)
9D001320  A0430000   SB V1, 0(V0)
9D001324  0B400595   J 0x9D001654
9D001328  00000000   NOP
331:                         case REG_FAN_CFG2 :         *data = g.lm63_data_1.config_fan;               break;
9D00132C  3C02A000   LUI V0, -24576
9D001330  2442000C   ADDIU V0, V0, 12
9D001334  90430029   LBU V1, 41(V0)
9D001338  8FC2000C   LW V0, 12(S8)
9D00133C  A0430000   SB V1, 0(V0)
9D001340  0B400595   J 0x9D001654
9D001344  00000000   NOP
332:                         case REG_FAN_PWM_FREQ :     *data = g.lm63_data_1.pwm_freq;                 break;
9D001348  3C02A000   LUI V0, -24576
9D00134C  2442000C   ADDIU V0, V0, 12
9D001350  9043002E   LBU V1, 46(V0)
9D001354  8FC2000C   LW V0, 12(S8)
9D001358  A0430000   SB V1, 0(V0)
9D00135C  0B400595   J 0x9D001654
9D001360  00000000   NOP
333:                         case REG_FAN_PWM_VAL :      *data = g.lm63_data_1.pwm_value;                break;
9D001364  3C02A000   LUI V0, -24576
9D001368  2442000C   ADDIU V0, V0, 12
9D00136C  9043002F   LBU V1, 47(V0)
9D001370  8FC2000C   LW V0, 12(S8)
9D001374  A0430000   SB V1, 0(V0)
9D001378  0B400595   J 0x9D001654
9D00137C  00000000   NOP
334:                         case REG_FAN_SET_SPEED :    *data = (u8)(OC1RS / PWM_FREQ_COEF);            break;
9D001380  3C02BF80   LUI V0, -16512
9D001384  8C433020   LW V1, 12320(V0)
9D001388  3C02CCCC   LUI V0, -13108
9D00138C  3442CCCD   ORI V0, V0, -13107
9D001390  00620019   MULTU 0, V1, V0
9D001394  00001010   MFHI V0
9D001398  000210C2   SRL V0, V0, 3
9D00139C  304300FF   ANDI V1, V0, 255
9D0013A0  8FC2000C   LW V0, 12(S8)
9D0013A4  A0430000   SB V1, 0(V0)
9D0013A8  0B400595   J 0x9D001654
9D0013AC  00000000   NOP
335:                         case REG_FAN_STATUS :       *data = g.lm63_data_1.status;                   break;
9D0013B0  3C02A000   LUI V0, -24576
9D0013B4  2442000C   ADDIU V0, V0, 12
9D0013B8  90430035   LBU V1, 53(V0)
9D0013BC  8FC2000C   LW V0, 12(S8)
9D0013C0  A0430000   SB V1, 0(V0)
9D0013C4  0B400595   J 0x9D001654
9D0013C8  00000000   NOP
336:                 
337:                         // temperature from ARRIA
338:                         case REG_A10_ENC_TEMP_MSB : *data = (u8)g.temp_sensors[FPGA_ENC] >> 8;      break;
9D0013CC  3C02A000   LUI V0, -24576
9D0013D0  2442000C   ADDIU V0, V0, 12
9D0013D4  9442000E   LHU V0, 14(V0)
9D0013D8  304200FF   ANDI V0, V0, 255
9D0013DC  00021203   SRA V0, V0, 8
9D0013E0  304300FF   ANDI V1, V0, 255
9D0013E4  8FC2000C   LW V0, 12(S8)
9D0013E8  A0430000   SB V1, 0(V0)
9D0013EC  0B400595   J 0x9D001654
9D0013F0  00000000   NOP
339:                         case REG_A10_ENC_TEMP_LSB : *data = (u8)g.temp_sensors[FPGA_ENC] & 0xff;    break;
9D0013F4  3C02A000   LUI V0, -24576
9D0013F8  2442000C   ADDIU V0, V0, 12
9D0013FC  9442000E   LHU V0, 14(V0)
9D001400  304300FF   ANDI V1, V0, 255
9D001404  8FC2000C   LW V0, 12(S8)
9D001408  A0430000   SB V1, 0(V0)
9D00140C  0B400595   J 0x9D001654
9D001410  00000000   NOP
340:                         case REG_A10_IO_TEMP_MSB :  *data = (u8)g.temp_sensors[FPGA_IO]  >> 8;      break;
9D001414  3C02A000   LUI V0, -24576
9D001418  2442000C   ADDIU V0, V0, 12
9D00141C  94420010   LHU V0, 16(V0)
9D001420  304200FF   ANDI V0, V0, 255
9D001424  00021203   SRA V0, V0, 8
9D001428  304300FF   ANDI V1, V0, 255
9D00142C  8FC2000C   LW V0, 12(S8)
9D001430  A0430000   SB V1, 0(V0)
9D001434  0B400595   J 0x9D001654
9D001438  00000000   NOP
341:                         case REG_A10_IO_TEMP_LSB :  *data = (u8)g.temp_sensors[FPGA_IO]  & 0xff;    break;
9D00143C  3C02A000   LUI V0, -24576
9D001440  2442000C   ADDIU V0, V0, 12
9D001444  94420010   LHU V0, 16(V0)
9D001448  304300FF   ANDI V1, V0, 255
9D00144C  8FC2000C   LW V0, 12(S8)
9D001450  A0430000   SB V1, 0(V0)
9D001454  0B400595   J 0x9D001654
9D001458  00000000   NOP
342:                 
343:                         // i2c error
344:                         case REG_I2C_ERROR :        *data = (u8)g.i2c_error;                        break;
9D00145C  3C02A000   LUI V0, -24576
9D001460  2442000C   ADDIU V0, V0, 12
9D001464  8C420080   LW V0, 128(V0)
9D001468  304300FF   ANDI V1, V0, 255
9D00146C  8FC2000C   LW V0, 12(S8)
9D001470  A0430000   SB V1, 0(V0)
9D001474  0B400595   J 0x9D001654
9D001478  00000000   NOP
345:                 
346:                         // debug
347:                         case REG_DEBUG_0 :          *data = g.debug0;                               break;
9D00147C  3C02A000   LUI V0, -24576
9D001480  2442000C   ADDIU V0, V0, 12
9D001484  90430084   LBU V1, 132(V0)
9D001488  8FC2000C   LW V0, 12(S8)
9D00148C  A0430000   SB V1, 0(V0)
9D001490  0B400595   J 0x9D001654
9D001494  00000000   NOP
348:                         case REG_DEBUG_1 :          *data = g.debug1;                               break;
9D001498  3C02A000   LUI V0, -24576
9D00149C  2442000C   ADDIU V0, V0, 12
9D0014A0  90430085   LBU V1, 133(V0)
9D0014A4  8FC2000C   LW V0, 12(S8)
9D0014A8  A0430000   SB V1, 0(V0)
9D0014AC  0B400595   J 0x9D001654
9D0014B0  00000000   NOP
349:                         case REG_DEBUG_2 :          *data = g.debug2;                               break;
9D0014B4  3C02A000   LUI V0, -24576
9D0014B8  2442000C   ADDIU V0, V0, 12
9D0014BC  90430086   LBU V1, 134(V0)
9D0014C0  8FC2000C   LW V0, 12(S8)
9D0014C4  A0430000   SB V1, 0(V0)
9D0014C8  0B400595   J 0x9D001654
9D0014CC  00000000   NOP
350:                         case REG_DEBUG_3 :          *data = g.debug3;                               break;
9D0014D0  3C02A000   LUI V0, -24576
9D0014D4  2442000C   ADDIU V0, V0, 12
9D0014D8  90430087   LBU V1, 135(V0)
9D0014DC  8FC2000C   LW V0, 12(S8)
9D0014E0  A0430000   SB V1, 0(V0)
9D0014E4  0B400595   J 0x9D001654
9D0014E8  00000000   NOP
351:                         case REG_DEBUG_4 :          *data = g.debug4;                               break;
9D0014EC  3C02A000   LUI V0, -24576
9D0014F0  2442000C   ADDIU V0, V0, 12
9D0014F4  90430088   LBU V1, 136(V0)
9D0014F8  8FC2000C   LW V0, 12(S8)
9D0014FC  A0430000   SB V1, 0(V0)
9D001500  0B400595   J 0x9D001654
9D001504  00000000   NOP
352:                         case REG_DEBUG_5 :          *data = g.debug5;                               break;
9D001508  3C02A000   LUI V0, -24576
9D00150C  2442000C   ADDIU V0, V0, 12
9D001510  90430089   LBU V1, 137(V0)
9D001514  8FC2000C   LW V0, 12(S8)
9D001518  A0430000   SB V1, 0(V0)
9D00151C  0B400595   J 0x9D001654
9D001520  00000000   NOP
353:                         case REG_DEBUG_6 :          *data = g.debug6;                               break;
9D001524  3C02A000   LUI V0, -24576
9D001528  2442000C   ADDIU V0, V0, 12
9D00152C  9043008A   LBU V1, 138(V0)
9D001530  8FC2000C   LW V0, 12(S8)
9D001534  A0430000   SB V1, 0(V0)
9D001538  0B400595   J 0x9D001654
9D00153C  00000000   NOP
354:                         case REG_DEBUG_7 :          *data = g.debug7;                               break;
9D001540  3C02A000   LUI V0, -24576
9D001544  2442000C   ADDIU V0, V0, 12
9D001548  9043008B   LBU V1, 139(V0)
9D00154C  8FC2000C   LW V0, 12(S8)
9D001550  A0430000   SB V1, 0(V0)
9D001554  0B400595   J 0x9D001654
9D001558  00000000   NOP
355:                         case REG_DEBUG_8 :          *data = g.debug8;                               break;
9D00155C  3C02A000   LUI V0, -24576
9D001560  2442000C   ADDIU V0, V0, 12
9D001564  9043008C   LBU V1, 140(V0)
9D001568  8FC2000C   LW V0, 12(S8)
9D00156C  A0430000   SB V1, 0(V0)
9D001570  0B400595   J 0x9D001654
9D001574  00000000   NOP
356:                         case REG_DEBUG_9 :          *data = g.debug9;                               break;
9D001578  3C02A000   LUI V0, -24576
9D00157C  2442000C   ADDIU V0, V0, 12
9D001580  9043008D   LBU V1, 141(V0)
9D001584  8FC2000C   LW V0, 12(S8)
9D001588  A0430000   SB V1, 0(V0)
9D00158C  0B400595   J 0x9D001654
9D001590  00000000   NOP
357:                         case REG_DEBUG_10 :         *data = g.debug10;                              break;
9D001594  3C02A000   LUI V0, -24576
9D001598  2442000C   ADDIU V0, V0, 12
9D00159C  9043008E   LBU V1, 142(V0)
9D0015A0  8FC2000C   LW V0, 12(S8)
9D0015A4  A0430000   SB V1, 0(V0)
9D0015A8  0B400595   J 0x9D001654
9D0015AC  00000000   NOP
358:                         case REG_DEBUG_11 :         *data = g.debug11;                              break;
9D0015B0  3C02A000   LUI V0, -24576
9D0015B4  2442000C   ADDIU V0, V0, 12
9D0015B8  9043008F   LBU V1, 143(V0)
9D0015BC  8FC2000C   LW V0, 12(S8)
9D0015C0  A0430000   SB V1, 0(V0)
9D0015C4  0B400595   J 0x9D001654
9D0015C8  00000000   NOP
359:                         case REG_DEBUG_12 :         *data = g.debug12;                              break;
9D0015CC  3C02A000   LUI V0, -24576
9D0015D0  2442000C   ADDIU V0, V0, 12
9D0015D4  90430090   LBU V1, 144(V0)
9D0015D8  8FC2000C   LW V0, 12(S8)
9D0015DC  A0430000   SB V1, 0(V0)
9D0015E0  0B400595   J 0x9D001654
9D0015E4  00000000   NOP
360:                         case REG_DEBUG_13 :         *data = g.debug13;                              break;
9D0015E8  3C02A000   LUI V0, -24576
9D0015EC  2442000C   ADDIU V0, V0, 12
9D0015F0  90430091   LBU V1, 145(V0)
9D0015F4  8FC2000C   LW V0, 12(S8)
9D0015F8  A0430000   SB V1, 0(V0)
9D0015FC  0B400595   J 0x9D001654
9D001600  00000000   NOP
361:                         case REG_DEBUG_14 :         *data = g.debug14;                              break;
9D001604  3C02A000   LUI V0, -24576
9D001608  2442000C   ADDIU V0, V0, 12
9D00160C  90430092   LBU V1, 146(V0)
9D001610  8FC2000C   LW V0, 12(S8)
9D001614  A0430000   SB V1, 0(V0)
9D001618  0B400595   J 0x9D001654
9D00161C  00000000   NOP
362:                         case REG_DEBUG_15 :         *data = g.debug15;                              break;
9D001620  3C02A000   LUI V0, -24576
9D001624  2442000C   ADDIU V0, V0, 12
9D001628  90430093   LBU V1, 147(V0)
9D00162C  8FC2000C   LW V0, 12(S8)
9D001630  A0430000   SB V1, 0(V0)
9D001634  0B400595   J 0x9D001654
9D001638  00000000   NOP
363:                 
364:                         default :
365:                             *data = 0xFF;
9D00163C  8FC2000C   LW V0, 12(S8)
9D001640  2403FFFF   ADDIU V1, ZERO, -1
9D001644  A0430000   SB V1, 0(V0)
366:                             return WARNING;
9D001648  24020003   ADDIU V0, ZERO, 3
9D00164C  0B400596   J 0x9D001658
9D001650  00000000   NOP
367:                             break;
368:                     }
369:                 
370:                     return SUCCESS;
9D001654  00001021   ADDU V0, ZERO, ZERO
371:                 }
9D001658  03C0E821   ADDU SP, S8, ZERO
9D00165C  8FBE0004   LW S8, 4(SP)
9D001660  27BD0008   ADDIU SP, SP, 8
9D001664  03E00008   JR RA
9D001668  00000000   NOP
9D00166C  27BDFFE8   ADDIU SP, SP, -24
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Version     :   v1.3                                                &&&
4:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:                   //&&&   Description :   - functions for i2c master bus                      &&&
6:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
7:                   //&&&   History     :                                                       &&&
8:                   //&&&   1.0 - 2015/06/30 - PBL - Creation                                   &&&
9:                   //&&&   1.1 - 2015/06/29 - PBL - Added bus id in each functions             &&&
10:                  //&&&   1.2 - 2015/09/18 - PBL - Reworked idle function                     &&&
11:                  //&&&   1.3 - 2016/09/07 - PBL - Made library independant of Microchip's one&&&
12:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
13:                  
14:                  #include "hardware_profile.h"
15:                  #include "types.h"
16:                  #include "delays.h"
17:                  #include "i2c_master.h"
18:                  
19:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
20:                  //------------------------- Init I2C slave bus --------------------------------
21:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
22:                  RESULT i2c_master_init(I2C_BUS bus_id, u32 freq)
23:                  {
9D00166C  27BDFFE8   ADDIU SP, SP, -24
9D001670  AFBF0014   SW RA, 20(SP)
9D001674  AFBE0010   SW S8, 16(SP)
9D001678  03A0F021   ADDU S8, SP, ZERO
9D00167C  AFC40018   SW A0, 24(S8)
9D001680  AFC5001C   SW A1, 28(S8)
24:                      // I2CxBRG = (((1 / (2 * Fscl)) - TPGD) * Fpb) - 2
25:                  
26:                      if      (bus_id == I2C_BUS_1){
9D001684  8FC20018   LW V0, 24(S8)
9D001688  14400037   BNE V0, ZERO, 0x9D001768
9D00168C  00000000   NOP
27:                          // Set the I2C baud rate
28:                          I2C1BRG = (u8)((((1 / (2.0f * freq)) - 0.000000104) * 20000000) - 2);
9D001690  8FC4001C   LW A0, 28(S8)
9D001694  0F4022E2   JAL __floatunsisf
9D001698  00000000   NOP
9D00169C  00402021   ADDU A0, V0, ZERO
9D0016A0  00402821   ADDU A1, V0, ZERO
9D0016A4  0F401EF9   JAL fpadd
9D0016A8  00000000   NOP
9D0016AC  3C039D01   LUI V1, -25343
9D0016B0  8C648DC4   LW A0, -29244(V1)
9D0016B4  00402821   ADDU A1, V0, ZERO
9D0016B8  0F401F95   JAL __divsf3
9D0016BC  00000000   NOP
9D0016C0  00401821   ADDU V1, V0, ZERO
9D0016C4  3C029D01   LUI V0, -25343
9D0016C8  00602021   ADDU A0, V1, ZERO
9D0016CC  8C458DC8   LW A1, -29240(V0)
9D0016D0  0F401EF7   JAL fpsub
9D0016D4  00000000   NOP
9D0016D8  00401821   ADDU V1, V0, ZERO
9D0016DC  3C029D01   LUI V0, -25343
9D0016E0  00602021   ADDU A0, V1, ZERO
9D0016E4  8C458DCC   LW A1, -29236(V0)
9D0016E8  0F402106   JAL fpmul
9D0016EC  00000000   NOP
9D0016F0  00401821   ADDU V1, V0, ZERO
9D0016F4  3C029D01   LUI V0, -25343
9D0016F8  00602021   ADDU A0, V1, ZERO
9D0016FC  8C458DD0   LW A1, -29232(V0)
9D001700  0F401EF7   JAL fpsub
9D001704  00000000   NOP
9D001708  00402021   ADDU A0, V0, ZERO
9D00170C  0F4021E5   JAL __fixunssfsi
9D001710  00000000   NOP
9D001714  304200FF   ANDI V0, V0, 255
9D001718  00401821   ADDU V1, V0, ZERO
9D00171C  3C02BF80   LUI V0, -16512
9D001720  AC435340   SW V1, 21312(V0)
29:                  
30:                          // use default values
31:                          I2C1CON = 0;
9D001724  3C02BF80   LUI V0, -16512
9D001728  AC405300   SW ZERO, 21248(V0)
32:                  
33:                          // use 7-bit addresses
34:                          I2C1CONbits.A10M = 0;
9D00172C  3C03BF80   LUI V1, -16512
9D001730  94625300   LHU V0, 21248(V1)
9D001734  7C025284   INS V0, ZERO, 10, 1
9D001738  A4625300   SH V0, 21248(V1)
35:                  
36:                          // Slew rate control enabled for High Speed mode (400 kHz)
37:                          I2C1CONbits.DISSLW = 0;
9D00173C  3C03BF80   LUI V1, -16512
9D001740  94625300   LHU V0, 21248(V1)
9D001744  7C024A44   INS V0, ZERO, 9, 1
9D001748  A4625300   SH V0, 21248(V1)
38:                  
39:                          // Enable the I2C bus
40:                          I2C1CONbits.ON = 1;
9D00174C  3C03BF80   LUI V1, -16512
9D001750  94625300   LHU V0, 21248(V1)
9D001754  24040001   ADDIU A0, ZERO, 1
9D001758  7C827BC4   INS V0, A0, 15, 1
9D00175C  A4625300   SH V0, 21248(V1)
9D001760  0B4006C5   J 0x9D001B14
9D001764  00000000   NOP
41:                  
42:                      }else if(bus_id == I2C_BUS_2){
9D001768  8FC30018   LW V1, 24(S8)
9D00176C  24020001   ADDIU V0, ZERO, 1
9D001770  14620037   BNE V1, V0, 0x9D001850
9D001774  00000000   NOP
43:                          // Set the I2C baud rate
44:                          I2C2BRG = (u8)((((1 / (2.0f * freq)) - 0.000000104) * 20000000) - 2);
9D001778  8FC4001C   LW A0, 28(S8)
9D00177C  0F4022E2   JAL __floatunsisf
9D001780  00000000   NOP
9D001784  00402021   ADDU A0, V0, ZERO
9D001788  00402821   ADDU A1, V0, ZERO
9D00178C  0F401EF9   JAL fpadd
9D001790  00000000   NOP
9D001794  3C039D01   LUI V1, -25343
9D001798  8C648DC4   LW A0, -29244(V1)
9D00179C  00402821   ADDU A1, V0, ZERO
9D0017A0  0F401F95   JAL __divsf3
9D0017A4  00000000   NOP
9D0017A8  00401821   ADDU V1, V0, ZERO
9D0017AC  3C029D01   LUI V0, -25343
9D0017B0  00602021   ADDU A0, V1, ZERO
9D0017B4  8C458DC8   LW A1, -29240(V0)
9D0017B8  0F401EF7   JAL fpsub
9D0017BC  00000000   NOP
9D0017C0  00401821   ADDU V1, V0, ZERO
9D0017C4  3C029D01   LUI V0, -25343
9D0017C8  00602021   ADDU A0, V1, ZERO
9D0017CC  8C458DCC   LW A1, -29236(V0)
9D0017D0  0F402106   JAL fpmul
9D0017D4  00000000   NOP
9D0017D8  00401821   ADDU V1, V0, ZERO
9D0017DC  3C029D01   LUI V0, -25343
9D0017E0  00602021   ADDU A0, V1, ZERO
9D0017E4  8C458DD0   LW A1, -29232(V0)
9D0017E8  0F401EF7   JAL fpsub
9D0017EC  00000000   NOP
9D0017F0  00402021   ADDU A0, V0, ZERO
9D0017F4  0F4021E5   JAL __fixunssfsi
9D0017F8  00000000   NOP
9D0017FC  304200FF   ANDI V0, V0, 255
9D001800  00401821   ADDU V1, V0, ZERO
9D001804  3C02BF80   LUI V0, -16512
9D001808  AC435440   SW V1, 21568(V0)
45:                  
46:                          // use default values
47:                          I2C2CON = 0;
9D00180C  3C02BF80   LUI V0, -16512
9D001810  AC405400   SW ZERO, 21504(V0)
48:                  
49:                          // use 7-bit addresses
50:                          I2C2CONbits.A10M = 0;
9D001814  3C03BF80   LUI V1, -16512
9D001818  94625400   LHU V0, 21504(V1)
9D00181C  7C025284   INS V0, ZERO, 10, 1
9D001820  A4625400   SH V0, 21504(V1)
51:                  
52:                          // Slew rate control enabled for High Speed mode (400 kHz)
53:                          I2C2CONbits.DISSLW = 0;
9D001824  3C03BF80   LUI V1, -16512
9D001828  94625400   LHU V0, 21504(V1)
9D00182C  7C024A44   INS V0, ZERO, 9, 1
9D001830  A4625400   SH V0, 21504(V1)
54:                  
55:                          // Enable the I2C bus
56:                          I2C2CONbits.ON = 1;
9D001834  3C03BF80   LUI V1, -16512
9D001838  94625400   LHU V0, 21504(V1)
9D00183C  24040001   ADDIU A0, ZERO, 1
9D001840  7C827BC4   INS V0, A0, 15, 1
9D001844  A4625400   SH V0, 21504(V1)
9D001848  0B4006C5   J 0x9D001B14
9D00184C  00000000   NOP
57:                  
58:                      }else if(bus_id == I2C_BUS_3){
9D001850  8FC30018   LW V1, 24(S8)
9D001854  24020002   ADDIU V0, ZERO, 2
9D001858  14620037   BNE V1, V0, 0x9D001938
9D00185C  00000000   NOP
59:                          // Set the I2C baud rate
60:                          I2C3BRG = (u8)((((1 / (2.0f * freq)) - 0.000000104) * 20000000) - 2);
9D001860  8FC4001C   LW A0, 28(S8)
9D001864  0F4022E2   JAL __floatunsisf
9D001868  00000000   NOP
9D00186C  00402021   ADDU A0, V0, ZERO
9D001870  00402821   ADDU A1, V0, ZERO
9D001874  0F401EF9   JAL fpadd
9D001878  00000000   NOP
9D00187C  3C039D01   LUI V1, -25343
9D001880  8C648DC4   LW A0, -29244(V1)
9D001884  00402821   ADDU A1, V0, ZERO
9D001888  0F401F95   JAL __divsf3
9D00188C  00000000   NOP
9D001890  00401821   ADDU V1, V0, ZERO
9D001894  3C029D01   LUI V0, -25343
9D001898  00602021   ADDU A0, V1, ZERO
9D00189C  8C458DC8   LW A1, -29240(V0)
9D0018A0  0F401EF7   JAL fpsub
9D0018A4  00000000   NOP
9D0018A8  00401821   ADDU V1, V0, ZERO
9D0018AC  3C029D01   LUI V0, -25343
9D0018B0  00602021   ADDU A0, V1, ZERO
9D0018B4  8C458DCC   LW A1, -29236(V0)
9D0018B8  0F402106   JAL fpmul
9D0018BC  00000000   NOP
9D0018C0  00401821   ADDU V1, V0, ZERO
9D0018C4  3C029D01   LUI V0, -25343
9D0018C8  00602021   ADDU A0, V1, ZERO
9D0018CC  8C458DD0   LW A1, -29232(V0)
9D0018D0  0F401EF7   JAL fpsub
9D0018D4  00000000   NOP
9D0018D8  00402021   ADDU A0, V0, ZERO
9D0018DC  0F4021E5   JAL __fixunssfsi
9D0018E0  00000000   NOP
9D0018E4  304200FF   ANDI V0, V0, 255
9D0018E8  00401821   ADDU V1, V0, ZERO
9D0018EC  3C02BF80   LUI V0, -16512
9D0018F0  AC435040   SW V1, 20544(V0)
61:                  
62:                          // use default values
63:                          I2C3CON = 0;
9D0018F4  3C02BF80   LUI V0, -16512
9D0018F8  AC405000   SW ZERO, 20480(V0)
64:                  
65:                          // use 7-bit addresses
66:                          I2C3CONbits.A10M = 0;
9D0018FC  3C03BF80   LUI V1, -16512
9D001900  94625000   LHU V0, 20480(V1)
9D001904  7C025284   INS V0, ZERO, 10, 1
9D001908  A4625000   SH V0, 20480(V1)
67:                  
68:                          // Slew rate control enabled for High Speed mode (400 kHz)
69:                          I2C3CONbits.DISSLW = 0;
9D00190C  3C03BF80   LUI V1, -16512
9D001910  94625000   LHU V0, 20480(V1)
9D001914  7C024A44   INS V0, ZERO, 9, 1
9D001918  A4625000   SH V0, 20480(V1)
70:                  
71:                          // Enable the I2C bus
72:                          I2C3CONbits.ON = 1;
9D00191C  3C03BF80   LUI V1, -16512
9D001920  94625000   LHU V0, 20480(V1)
9D001924  24040001   ADDIU A0, ZERO, 1
9D001928  7C827BC4   INS V0, A0, 15, 1
9D00192C  A4625000   SH V0, 20480(V1)
9D001930  0B4006C5   J 0x9D001B14
9D001934  00000000   NOP
73:                  
74:                      }else if(bus_id == I2C_BUS_4){
9D001938  8FC30018   LW V1, 24(S8)
9D00193C  24020003   ADDIU V0, ZERO, 3
9D001940  14620037   BNE V1, V0, 0x9D001A20
9D001944  00000000   NOP
75:                          // Set the I2C baud rate
76:                          I2C4BRG = (u8)((((1 / (2.0f * freq)) - 0.000000104) * 20000000) - 2);
9D001948  8FC4001C   LW A0, 28(S8)
9D00194C  0F4022E2   JAL __floatunsisf
9D001950  00000000   NOP
9D001954  00402021   ADDU A0, V0, ZERO
9D001958  00402821   ADDU A1, V0, ZERO
9D00195C  0F401EF9   JAL fpadd
9D001960  00000000   NOP
9D001964  3C039D01   LUI V1, -25343
9D001968  8C648DC4   LW A0, -29244(V1)
9D00196C  00402821   ADDU A1, V0, ZERO
9D001970  0F401F95   JAL __divsf3
9D001974  00000000   NOP
9D001978  00401821   ADDU V1, V0, ZERO
9D00197C  3C029D01   LUI V0, -25343
9D001980  00602021   ADDU A0, V1, ZERO
9D001984  8C458DC8   LW A1, -29240(V0)
9D001988  0F401EF7   JAL fpsub
9D00198C  00000000   NOP
9D001990  00401821   ADDU V1, V0, ZERO
9D001994  3C029D01   LUI V0, -25343
9D001998  00602021   ADDU A0, V1, ZERO
9D00199C  8C458DCC   LW A1, -29236(V0)
9D0019A0  0F402106   JAL fpmul
9D0019A4  00000000   NOP
9D0019A8  00401821   ADDU V1, V0, ZERO
9D0019AC  3C029D01   LUI V0, -25343
9D0019B0  00602021   ADDU A0, V1, ZERO
9D0019B4  8C458DD0   LW A1, -29232(V0)
9D0019B8  0F401EF7   JAL fpsub
9D0019BC  00000000   NOP
9D0019C0  00402021   ADDU A0, V0, ZERO
9D0019C4  0F4021E5   JAL __fixunssfsi
9D0019C8  00000000   NOP
9D0019CC  304200FF   ANDI V0, V0, 255
9D0019D0  00401821   ADDU V1, V0, ZERO
9D0019D4  3C02BF80   LUI V0, -16512
9D0019D8  AC435140   SW V1, 20800(V0)
77:                  
78:                          // use default values
79:                          I2C4CON = 0;
9D0019DC  3C02BF80   LUI V0, -16512
9D0019E0  AC405100   SW ZERO, 20736(V0)
80:                  
81:                          // use 7-bit addresses
82:                          I2C4CONbits.A10M = 0;
9D0019E4  3C03BF80   LUI V1, -16512
9D0019E8  94625100   LHU V0, 20736(V1)
9D0019EC  7C025284   INS V0, ZERO, 10, 1
9D0019F0  A4625100   SH V0, 20736(V1)
83:                  
84:                          // Slew rate control enabled for High Speed mode (400 kHz)
85:                          I2C4CONbits.DISSLW = 0;
9D0019F4  3C03BF80   LUI V1, -16512
9D0019F8  94625100   LHU V0, 20736(V1)
9D0019FC  7C024A44   INS V0, ZERO, 9, 1
9D001A00  A4625100   SH V0, 20736(V1)
86:                  
87:                          // Enable the I2C bus
88:                          I2C4CONbits.ON = 1;
9D001A04  3C03BF80   LUI V1, -16512
9D001A08  94625100   LHU V0, 20736(V1)
9D001A0C  24040001   ADDIU A0, ZERO, 1
9D001A10  7C827BC4   INS V0, A0, 15, 1
9D001A14  A4625100   SH V0, 20736(V1)
9D001A18  0B4006C5   J 0x9D001B14
9D001A1C  00000000   NOP
89:                  
90:                      }else if(bus_id == I2C_BUS_5){
9D001A20  8FC30018   LW V1, 24(S8)
9D001A24  24020004   ADDIU V0, ZERO, 4
9D001A28  14620037   BNE V1, V0, 0x9D001B08
9D001A2C  00000000   NOP
91:                          // Set the I2C baud rate
92:                          I2C5BRG = (u8)((((1 / (2.0f * freq)) - 0.000000104) * 20000000) - 2);
9D001A30  8FC4001C   LW A0, 28(S8)
9D001A34  0F4022E2   JAL __floatunsisf
9D001A38  00000000   NOP
9D001A3C  00402021   ADDU A0, V0, ZERO
9D001A40  00402821   ADDU A1, V0, ZERO
9D001A44  0F401EF9   JAL fpadd
9D001A48  00000000   NOP
9D001A4C  3C039D01   LUI V1, -25343
9D001A50  8C648DC4   LW A0, -29244(V1)
9D001A54  00402821   ADDU A1, V0, ZERO
9D001A58  0F401F95   JAL __divsf3
9D001A5C  00000000   NOP
9D001A60  00401821   ADDU V1, V0, ZERO
9D001A64  3C029D01   LUI V0, -25343
9D001A68  00602021   ADDU A0, V1, ZERO
9D001A6C  8C458DC8   LW A1, -29240(V0)
9D001A70  0F401EF7   JAL fpsub
9D001A74  00000000   NOP
9D001A78  00401821   ADDU V1, V0, ZERO
9D001A7C  3C029D01   LUI V0, -25343
9D001A80  00602021   ADDU A0, V1, ZERO
9D001A84  8C458DCC   LW A1, -29236(V0)
9D001A88  0F402106   JAL fpmul
9D001A8C  00000000   NOP
9D001A90  00401821   ADDU V1, V0, ZERO
9D001A94  3C029D01   LUI V0, -25343
9D001A98  00602021   ADDU A0, V1, ZERO
9D001A9C  8C458DD0   LW A1, -29232(V0)
9D001AA0  0F401EF7   JAL fpsub
9D001AA4  00000000   NOP
9D001AA8  00402021   ADDU A0, V0, ZERO
9D001AAC  0F4021E5   JAL __fixunssfsi
9D001AB0  00000000   NOP
9D001AB4  304200FF   ANDI V0, V0, 255
9D001AB8  00401821   ADDU V1, V0, ZERO
9D001ABC  3C02BF80   LUI V0, -16512
9D001AC0  AC435240   SW V1, 21056(V0)
93:                  
94:                          // use default values
95:                          I2C5CON = 0;
9D001AC4  3C02BF80   LUI V0, -16512
9D001AC8  AC405200   SW ZERO, 20992(V0)
96:                  
97:                          // use 7-bit addresses
98:                          I2C5CONbits.A10M = 0;
9D001ACC  3C03BF80   LUI V1, -16512
9D001AD0  94625200   LHU V0, 20992(V1)
9D001AD4  7C025284   INS V0, ZERO, 10, 1
9D001AD8  A4625200   SH V0, 20992(V1)
99:                  
100:                         // Slew rate control enabled for High Speed mode (400 kHz)
101:                         I2C5CONbits.DISSLW = 0;
9D001ADC  3C03BF80   LUI V1, -16512
9D001AE0  94625200   LHU V0, 20992(V1)
9D001AE4  7C024A44   INS V0, ZERO, 9, 1
9D001AE8  A4625200   SH V0, 20992(V1)
102:                 
103:                         // Enable the I2C bus
104:                         I2C5CONbits.ON = 1;
9D001AEC  3C03BF80   LUI V1, -16512
9D001AF0  94625200   LHU V0, 20992(V1)
9D001AF4  24040001   ADDIU A0, ZERO, 1
9D001AF8  7C827BC4   INS V0, A0, 15, 1
9D001AFC  A4625200   SH V0, 20992(V1)
9D001B00  0B4006C5   J 0x9D001B14
9D001B04  00000000   NOP
105:                 
106:                     }else{
107:                         return ERROR;
9D001B08  24020001   ADDIU V0, ZERO, 1
9D001B0C  0B4006C6   J 0x9D001B18
9D001B10  00000000   NOP
108:                     }
109:                 
110:                     return SUCCESS;
9D001B14  00001021   ADDU V0, ZERO, ZERO
111:                 }
9D001B18  03C0E821   ADDU SP, S8, ZERO
9D001B1C  8FBF0014   LW RA, 20(SP)
9D001B20  8FBE0010   LW S8, 16(SP)
9D001B24  27BD0018   ADDIU SP, SP, 24
9D001B28  03E00008   JR RA
9D001B2C  00000000   NOP
112:                 
113:                 
114:                 
115:                 
116:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
117:                 //------------------------- Send start condition ------------------------------
118:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
119:                 RESULT i2c_start(I2C_BUS bus_id)
120:                 {
9D001B30  27BDFFE8   ADDIU SP, SP, -24
9D001B34  AFBF0014   SW RA, 20(SP)
9D001B38  AFBE0010   SW S8, 16(SP)
9D001B3C  03A0F021   ADDU S8, SP, ZERO
9D001B40  AFC40018   SW A0, 24(S8)
121:                     if      (bus_id == I2C_BUS_1){
9D001B44  8FC20018   LW V0, 24(S8)
9D001B48  14400009   BNE V0, ZERO, 0x9D001B70
9D001B4C  00000000   NOP
122:                         I2C1CONSET = _I2C1CON_SEN_MASK;     // Send the start condition
9D001B50  3C02BF80   LUI V0, -16512
9D001B54  24030001   ADDIU V1, ZERO, 1
9D001B58  AC435308   SW V1, 21256(V0)
123:                         return i2c_wait(bus_id);            // Wait to complete
9D001B5C  8FC40018   LW A0, 24(S8)
9D001B60  0F4007A1   JAL i2c_wait
9D001B64  00000000   NOP
9D001B68  0B40070D   J 0x9D001C34
9D001B6C  00000000   NOP
124:                 
125:                     }else if(bus_id == I2C_BUS_2){
9D001B70  8FC30018   LW V1, 24(S8)
9D001B74  24020001   ADDIU V0, ZERO, 1
9D001B78  14620009   BNE V1, V0, 0x9D001BA0
9D001B7C  00000000   NOP
126:                         I2C2CONSET = _I2C2CON_SEN_MASK;     // Send the start condition
9D001B80  3C02BF80   LUI V0, -16512
9D001B84  24030001   ADDIU V1, ZERO, 1
9D001B88  AC435408   SW V1, 21512(V0)
127:                         return i2c_wait(bus_id);            // Wait to complete
9D001B8C  8FC40018   LW A0, 24(S8)
9D001B90  0F4007A1   JAL i2c_wait
9D001B94  00000000   NOP
9D001B98  0B40070D   J 0x9D001C34
9D001B9C  00000000   NOP
128:                 
129:                     }else if(bus_id == I2C_BUS_3){
9D001BA0  8FC30018   LW V1, 24(S8)
9D001BA4  24020002   ADDIU V0, ZERO, 2
9D001BA8  14620009   BNE V1, V0, 0x9D001BD0
9D001BAC  00000000   NOP
130:                         I2C3CONSET = _I2C3CON_SEN_MASK;     // Send the start condition
9D001BB0  3C02BF80   LUI V0, -16512
9D001BB4  24030001   ADDIU V1, ZERO, 1
9D001BB8  AC435008   SW V1, 20488(V0)
131:                         return i2c_wait(bus_id);            // Wait to complete
9D001BBC  8FC40018   LW A0, 24(S8)
9D001BC0  0F4007A1   JAL i2c_wait
9D001BC4  00000000   NOP
9D001BC8  0B40070D   J 0x9D001C34
9D001BCC  00000000   NOP
132:                 
133:                     }else if(bus_id == I2C_BUS_4){
9D001BD0  8FC30018   LW V1, 24(S8)
9D001BD4  24020003   ADDIU V0, ZERO, 3
9D001BD8  14620009   BNE V1, V0, 0x9D001C00
9D001BDC  00000000   NOP
134:                         I2C4CONSET = _I2C4CON_SEN_MASK;     // Send the start condition
9D001BE0  3C02BF80   LUI V0, -16512
9D001BE4  24030001   ADDIU V1, ZERO, 1
9D001BE8  AC435108   SW V1, 20744(V0)
135:                         return i2c_wait(bus_id);            // Wait to complete
9D001BEC  8FC40018   LW A0, 24(S8)
9D001BF0  0F4007A1   JAL i2c_wait
9D001BF4  00000000   NOP
9D001BF8  0B40070D   J 0x9D001C34
9D001BFC  00000000   NOP
136:                 
137:                     }else if(bus_id == I2C_BUS_5){
9D001C00  8FC30018   LW V1, 24(S8)
9D001C04  24020004   ADDIU V0, ZERO, 4
9D001C08  14620009   BNE V1, V0, 0x9D001C30
9D001C0C  00000000   NOP
138:                         I2C5CONSET = _I2C5CON_SEN_MASK;     // Send the start condition
9D001C10  3C02BF80   LUI V0, -16512
9D001C14  24030001   ADDIU V1, ZERO, 1
9D001C18  AC435208   SW V1, 21000(V0)
139:                         return i2c_wait(bus_id);            // Wait to complete
9D001C1C  8FC40018   LW A0, 24(S8)
9D001C20  0F4007A1   JAL i2c_wait
9D001C24  00000000   NOP
9D001C28  0B40070D   J 0x9D001C34
9D001C2C  00000000   NOP
140:                 
141:                     }else{
142:                         return ERROR;
9D001C30  24020001   ADDIU V0, ZERO, 1
143:                     }
144:                 }
9D001C34  03C0E821   ADDU SP, S8, ZERO
9D001C38  8FBF0014   LW RA, 20(SP)
9D001C3C  8FBE0010   LW S8, 16(SP)
9D001C40  27BD0018   ADDIU SP, SP, 24
9D001C44  03E00008   JR RA
9D001C48  00000000   NOP
145:                 
146:                 
147:                 
148:                 
149:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
150:                 //------------------------ Send restart condition -----------------------------
151:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
152:                 RESULT i2c_rstart(I2C_BUS bus_id)
153:                 {
9D001C4C  27BDFFE8   ADDIU SP, SP, -24
9D001C50  AFBF0014   SW RA, 20(SP)
9D001C54  AFBE0010   SW S8, 16(SP)
9D001C58  03A0F021   ADDU S8, SP, ZERO
9D001C5C  AFC40018   SW A0, 24(S8)
154:                     if      (bus_id == I2C_BUS_1){
9D001C60  8FC20018   LW V0, 24(S8)
9D001C64  14400009   BNE V0, ZERO, 0x9D001C8C
9D001C68  00000000   NOP
155:                         I2C1CONSET = _I2C1CON_RSEN_MASK;    // Send the re start condition
9D001C6C  3C02BF80   LUI V0, -16512
9D001C70  24030002   ADDIU V1, ZERO, 2
9D001C74  AC435308   SW V1, 21256(V0)
156:                         return i2c_wait(bus_id);            // Wait to complete
9D001C78  8FC40018   LW A0, 24(S8)
9D001C7C  0F4007A1   JAL i2c_wait
9D001C80  00000000   NOP
9D001C84  0B400754   J 0x9D001D50
9D001C88  00000000   NOP
157:                 
158:                     }else if(bus_id == I2C_BUS_2){
9D001C8C  8FC30018   LW V1, 24(S8)
9D001C90  24020001   ADDIU V0, ZERO, 1
9D001C94  14620009   BNE V1, V0, 0x9D001CBC
9D001C98  00000000   NOP
159:                         I2C2CONSET = _I2C2CON_RSEN_MASK;    // Send the re start condition
9D001C9C  3C02BF80   LUI V0, -16512
9D001CA0  24030002   ADDIU V1, ZERO, 2
9D001CA4  AC435408   SW V1, 21512(V0)
160:                         return i2c_wait(bus_id);            // Wait to complete
9D001CA8  8FC40018   LW A0, 24(S8)
9D001CAC  0F4007A1   JAL i2c_wait
9D001CB0  00000000   NOP
9D001CB4  0B400754   J 0x9D001D50
9D001CB8  00000000   NOP
161:                 
162:                     }else if(bus_id == I2C_BUS_3){
9D001CBC  8FC30018   LW V1, 24(S8)
9D001CC0  24020002   ADDIU V0, ZERO, 2
9D001CC4  14620009   BNE V1, V0, 0x9D001CEC
9D001CC8  00000000   NOP
163:                         I2C3CONSET = _I2C3CON_RSEN_MASK;    // Send the re start condition
9D001CCC  3C02BF80   LUI V0, -16512
9D001CD0  24030002   ADDIU V1, ZERO, 2
9D001CD4  AC435008   SW V1, 20488(V0)
164:                         return i2c_wait(bus_id);            // Wait to complete
9D001CD8  8FC40018   LW A0, 24(S8)
9D001CDC  0F4007A1   JAL i2c_wait
9D001CE0  00000000   NOP
9D001CE4  0B400754   J 0x9D001D50
9D001CE8  00000000   NOP
165:                 
166:                     }else if(bus_id == I2C_BUS_4){
9D001CEC  8FC30018   LW V1, 24(S8)
9D001CF0  24020003   ADDIU V0, ZERO, 3
9D001CF4  14620009   BNE V1, V0, 0x9D001D1C
9D001CF8  00000000   NOP
167:                         I2C4CONSET = _I2C4CON_RSEN_MASK;    // Send the re start condition
9D001CFC  3C02BF80   LUI V0, -16512
9D001D00  24030002   ADDIU V1, ZERO, 2
9D001D04  AC435108   SW V1, 20744(V0)
168:                         return i2c_wait(bus_id);            // Wait to complete
9D001D08  8FC40018   LW A0, 24(S8)
9D001D0C  0F4007A1   JAL i2c_wait
9D001D10  00000000   NOP
9D001D14  0B400754   J 0x9D001D50
9D001D18  00000000   NOP
169:                 
170:                     }else if(bus_id == I2C_BUS_5){
9D001D1C  8FC30018   LW V1, 24(S8)
9D001D20  24020004   ADDIU V0, ZERO, 4
9D001D24  14620009   BNE V1, V0, 0x9D001D4C
9D001D28  00000000   NOP
171:                         I2C5CONSET = _I2C5CON_RSEN_MASK;    // Send the re start condition
9D001D2C  3C02BF80   LUI V0, -16512
9D001D30  24030002   ADDIU V1, ZERO, 2
9D001D34  AC435208   SW V1, 21000(V0)
172:                         return i2c_wait(bus_id);            // Wait to complete
9D001D38  8FC40018   LW A0, 24(S8)
9D001D3C  0F4007A1   JAL i2c_wait
9D001D40  00000000   NOP
9D001D44  0B400754   J 0x9D001D50
9D001D48  00000000   NOP
173:                 
174:                     }else{
175:                         return ERROR;
9D001D4C  24020001   ADDIU V0, ZERO, 1
176:                     }
177:                 }
9D001D50  03C0E821   ADDU SP, S8, ZERO
9D001D54  8FBF0014   LW RA, 20(SP)
9D001D58  8FBE0010   LW S8, 16(SP)
9D001D5C  27BD0018   ADDIU SP, SP, 24
9D001D60  03E00008   JR RA
9D001D64  00000000   NOP
178:                 
179:                 
180:                 
181:                 
182:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
183:                 //------------------------- Send stop condition -------------------------------
184:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
185:                 RESULT i2c_stop(I2C_BUS bus_id)
186:                 {
9D001D68  27BDFFE8   ADDIU SP, SP, -24
9D001D6C  AFBF0014   SW RA, 20(SP)
9D001D70  AFBE0010   SW S8, 16(SP)
9D001D74  03A0F021   ADDU S8, SP, ZERO
9D001D78  AFC40018   SW A0, 24(S8)
187:                     if      (bus_id == I2C_BUS_1){
9D001D7C  8FC20018   LW V0, 24(S8)
9D001D80  14400009   BNE V0, ZERO, 0x9D001DA8
9D001D84  00000000   NOP
188:                         I2C1CONSET = _I2C1CON_PEN_MASK;     // Send the Stop condition
9D001D88  3C02BF80   LUI V0, -16512
9D001D8C  24030004   ADDIU V1, ZERO, 4
9D001D90  AC435308   SW V1, 21256(V0)
189:                         return i2c_wait(bus_id);            // Wait to complete
9D001D94  8FC40018   LW A0, 24(S8)
9D001D98  0F4007A1   JAL i2c_wait
9D001D9C  00000000   NOP
9D001DA0  0B40079B   J 0x9D001E6C
9D001DA4  00000000   NOP
190:                 
191:                     }else if(bus_id == I2C_BUS_2){
9D001DA8  8FC30018   LW V1, 24(S8)
9D001DAC  24020001   ADDIU V0, ZERO, 1
9D001DB0  14620009   BNE V1, V0, 0x9D001DD8
9D001DB4  00000000   NOP
192:                         I2C2CONSET = _I2C2CON_PEN_MASK;     // Send the Stop condition
9D001DB8  3C02BF80   LUI V0, -16512
9D001DBC  24030004   ADDIU V1, ZERO, 4
9D001DC0  AC435408   SW V1, 21512(V0)
193:                         return i2c_wait(bus_id);            // Wait to complete
9D001DC4  8FC40018   LW A0, 24(S8)
9D001DC8  0F4007A1   JAL i2c_wait
9D001DCC  00000000   NOP
9D001DD0  0B40079B   J 0x9D001E6C
9D001DD4  00000000   NOP
194:                 
195:                     }else if(bus_id == I2C_BUS_3){
9D001DD8  8FC30018   LW V1, 24(S8)
9D001DDC  24020002   ADDIU V0, ZERO, 2
9D001DE0  14620009   BNE V1, V0, 0x9D001E08
9D001DE4  00000000   NOP
196:                         I2C3CONSET = _I2C3CON_PEN_MASK;     // Send the Stop condition
9D001DE8  3C02BF80   LUI V0, -16512
9D001DEC  24030004   ADDIU V1, ZERO, 4
9D001DF0  AC435008   SW V1, 20488(V0)
197:                         return i2c_wait(bus_id);            // Wait to complete
9D001DF4  8FC40018   LW A0, 24(S8)
9D001DF8  0F4007A1   JAL i2c_wait
9D001DFC  00000000   NOP
9D001E00  0B40079B   J 0x9D001E6C
9D001E04  00000000   NOP
198:                 
199:                     }else if(bus_id == I2C_BUS_4){
9D001E08  8FC30018   LW V1, 24(S8)
9D001E0C  24020003   ADDIU V0, ZERO, 3
9D001E10  14620009   BNE V1, V0, 0x9D001E38
9D001E14  00000000   NOP
200:                         I2C4CONSET = _I2C4CON_PEN_MASK;     // Send the Stop condition
9D001E18  3C02BF80   LUI V0, -16512
9D001E1C  24030004   ADDIU V1, ZERO, 4
9D001E20  AC435108   SW V1, 20744(V0)
201:                         return i2c_wait(bus_id);            // Wait to complete
9D001E24  8FC40018   LW A0, 24(S8)
9D001E28  0F4007A1   JAL i2c_wait
9D001E2C  00000000   NOP
9D001E30  0B40079B   J 0x9D001E6C
9D001E34  00000000   NOP
202:                 
203:                     }else if(bus_id == I2C_BUS_5){
9D001E38  8FC30018   LW V1, 24(S8)
9D001E3C  24020004   ADDIU V0, ZERO, 4
9D001E40  14620009   BNE V1, V0, 0x9D001E68
9D001E44  00000000   NOP
204:                         I2C5CONSET = _I2C5CON_PEN_MASK;     // Send the Stop condition
9D001E48  3C02BF80   LUI V0, -16512
9D001E4C  24030004   ADDIU V1, ZERO, 4
9D001E50  AC435208   SW V1, 21000(V0)
205:                         return i2c_wait(bus_id);            // Wait to complete
9D001E54  8FC40018   LW A0, 24(S8)
9D001E58  0F4007A1   JAL i2c_wait
9D001E5C  00000000   NOP
9D001E60  0B40079B   J 0x9D001E6C
9D001E64  00000000   NOP
206:                 
207:                     }else{
208:                         return ERROR;
9D001E68  24020001   ADDIU V0, ZERO, 1
209:                     }
210:                 }
9D001E6C  03C0E821   ADDU SP, S8, ZERO
9D001E70  8FBF0014   LW RA, 20(SP)
9D001E74  8FBE0010   LW S8, 16(SP)
9D001E78  27BD0018   ADDIU SP, SP, 24
9D001E7C  03E00008   JR RA
9D001E80  00000000   NOP
211:                 
212:                 
213:                 
214:                 
215:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
216:                 //------------------ Wait for the i2c bus to be available ---------------------
217:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
218:                 #define TIMEOUT 1000
219:                 
220:                 RESULT i2c_wait(I2C_BUS bus_id)
221:                 {
9D001E84  27BDFFE0   ADDIU SP, SP, -32
9D001E88  AFBF001C   SW RA, 28(SP)
9D001E8C  AFBE0018   SW S8, 24(SP)
9D001E90  03A0F021   ADDU S8, SP, ZERO
9D001E94  AFC40020   SW A0, 32(S8)
222:                     u32 timeout = 0;
9D001E98  AFC00010   SW ZERO, 16(S8)
223:                 
224:                     if (bus_id == I2C_BUS_1){
9D001E9C  8FC20020   LW V0, 32(S8)
9D001EA0  1440002D   BNE V0, ZERO, 0x9D001F58
9D001EA4  00000000   NOP
225:                         do{
226:                             delay_us(1);
9D001EA8  24040001   ADDIU A0, ZERO, 1
9D001EAC  0F402175   JAL delay_us
9D001EB0  00000000   NOP
227:                             if (timeout++ >= TIMEOUT){
9D001EB4  8FC20010   LW V0, 16(S8)
9D001EB8  24430001   ADDIU V1, V0, 1
9D001EBC  AFC30010   SW V1, 16(S8)
9D001EC0  2C4203E8   SLTIU V0, V0, 1000
9D001EC4  14400004   BNE V0, ZERO, 0x9D001ED8
9D001EC8  00000000   NOP
228:                                 return ERROR;
9D001ECC  24020001   ADDIU V0, ZERO, 1
9D001ED0  0B40089A   J 0x9D002268
9D001ED4  00000000   NOP
229:                             }
230:                         }while(I2C1CONbits.SEN ||
9D001ED8  3C02BF80   LUI V0, -16512
9D001EDC  8C425300   LW V0, 21248(V0)
9D001EE0  30420001   ANDI V0, V0, 1
9D001EEC  3C02BF80   LUI V0, -16512
9D001EF0  8C425300   LW V0, 21248(V0)
9D001EF4  30420004   ANDI V0, V0, 4
9D001EF8  1440FFEB   BNE V0, ZERO, 0x9D001EA8
9D001EFC  00000000   NOP
231:                                I2C1CONbits.PEN ||
9D001F00  3C02BF80   LUI V0, -16512
9D001F04  8C425300   LW V0, 21248(V0)
9D001F08  30420008   ANDI V0, V0, 8
9D001F0C  1440FFE6   BNE V0, ZERO, 0x9D001EA8
9D001F10  00000000   NOP
232:                                I2C1CONbits.RCEN ||
9D001F14  3C02BF80   LUI V0, -16512
9D001F18  8C425300   LW V0, 21248(V0)
9D001F1C  30420002   ANDI V0, V0, 2
9D001F20  1440FFE1   BNE V0, ZERO, 0x9D001EA8
9D001F24  00000000   NOP
233:                                I2C1CONbits.RSEN ||
9D001F28  3C02BF80   LUI V0, -16512
9D001F2C  8C425300   LW V0, 21248(V0)
9D001F30  30420010   ANDI V0, V0, 16
9D001F34  1440FFDC   BNE V0, ZERO, 0x9D001EA8
9D001F38  00000000   NOP
234:                                I2C1CONbits.ACKEN ||
9D001F3C  3C02BF80   LUI V0, -16512
9D001F40  8C425310   LW V0, 21264(V0)
9D001F44  30424000   ANDI V0, V0, 16384
9D001F48  1440FFD7   BNE V0, ZERO, 0x9D001EA8
9D001F4C  00000000   NOP
9D001F50  0B400899   J 0x9D002264
9D001F54  00000000   NOP
235:                                I2C1STATbits.TRSTAT);
9D001EE4  1440FFF0   BNE V0, ZERO, 0x9D001EA8
9D001EE8  00000000   NOP
236:                 
237:                     }else if(bus_id == I2C_BUS_2){
9D001F58  8FC30020   LW V1, 32(S8)
9D001F5C  24020001   ADDIU V0, ZERO, 1
9D001F60  1462002D   BNE V1, V0, 0x9D002018
9D001F64  00000000   NOP
238:                         do{
239:                             delay_us(1);
9D001F68  24040001   ADDIU A0, ZERO, 1
9D001F6C  0F402175   JAL delay_us
9D001F70  00000000   NOP
240:                             if (timeout++ >= TIMEOUT){
9D001F74  8FC20010   LW V0, 16(S8)
9D001F78  24430001   ADDIU V1, V0, 1
9D001F7C  AFC30010   SW V1, 16(S8)
9D001F80  2C4203E8   SLTIU V0, V0, 1000
9D001F84  14400004   BNE V0, ZERO, 0x9D001F98
9D001F88  00000000   NOP
241:                                 return ERROR;
9D001F8C  24020001   ADDIU V0, ZERO, 1
9D001F90  0B40089A   J 0x9D002268
9D001F94  00000000   NOP
242:                             }
243:                         }while(I2C2CONbits.SEN ||
9D001F98  3C02BF80   LUI V0, -16512
9D001F9C  8C425400   LW V0, 21504(V0)
9D001FA0  30420001   ANDI V0, V0, 1
9D001FAC  3C02BF80   LUI V0, -16512
9D001FB0  8C425400   LW V0, 21504(V0)
9D001FB4  30420004   ANDI V0, V0, 4
9D001FB8  1440FFEB   BNE V0, ZERO, 0x9D001F68
9D001FBC  00000000   NOP
244:                                I2C2CONbits.PEN ||
9D001FC0  3C02BF80   LUI V0, -16512
9D001FC4  8C425400   LW V0, 21504(V0)
9D001FC8  30420008   ANDI V0, V0, 8
9D001FCC  1440FFE6   BNE V0, ZERO, 0x9D001F68
9D001FD0  00000000   NOP
245:                                I2C2CONbits.RCEN ||
9D001FD4  3C02BF80   LUI V0, -16512
9D001FD8  8C425400   LW V0, 21504(V0)
9D001FDC  30420002   ANDI V0, V0, 2
9D001FE0  1440FFE1   BNE V0, ZERO, 0x9D001F68
9D001FE4  00000000   NOP
246:                                I2C2CONbits.RSEN ||
9D001FE8  3C02BF80   LUI V0, -16512
9D001FEC  8C425400   LW V0, 21504(V0)
9D001FF0  30420010   ANDI V0, V0, 16
9D001FF4  1440FFDC   BNE V0, ZERO, 0x9D001F68
9D001FF8  00000000   NOP
247:                                I2C2CONbits.ACKEN ||
9D001FFC  3C02BF80   LUI V0, -16512
9D002000  8C425410   LW V0, 21520(V0)
9D002004  30424000   ANDI V0, V0, 16384
9D002008  1440FFD7   BNE V0, ZERO, 0x9D001F68
9D00200C  00000000   NOP
9D002010  0B400899   J 0x9D002264
9D002014  00000000   NOP
248:                                I2C2STATbits.TRSTAT);
9D001FA4  1440FFF0   BNE V0, ZERO, 0x9D001F68
9D001FA8  00000000   NOP
249:                 
250:                     }else if(bus_id == I2C_BUS_3){
9D002018  8FC30020   LW V1, 32(S8)
9D00201C  24020002   ADDIU V0, ZERO, 2
9D002020  1462002D   BNE V1, V0, 0x9D0020D8
9D002024  00000000   NOP
251:                         do{
252:                             delay_us(1);
9D002028  24040001   ADDIU A0, ZERO, 1
9D00202C  0F402175   JAL delay_us
9D002030  00000000   NOP
253:                             if (timeout++ >= TIMEOUT){
9D002034  8FC20010   LW V0, 16(S8)
9D002038  24430001   ADDIU V1, V0, 1
9D00203C  AFC30010   SW V1, 16(S8)
9D002040  2C4203E8   SLTIU V0, V0, 1000
9D002044  14400004   BNE V0, ZERO, 0x9D002058
9D002048  00000000   NOP
254:                                 return ERROR;
9D00204C  24020001   ADDIU V0, ZERO, 1
9D002050  0B40089A   J 0x9D002268
9D002054  00000000   NOP
255:                             }
256:                         }while(I2C3CONbits.SEN ||
9D002058  3C02BF80   LUI V0, -16512
9D00205C  8C425000   LW V0, 20480(V0)
9D002060  30420001   ANDI V0, V0, 1
9D00206C  3C02BF80   LUI V0, -16512
9D002070  8C425000   LW V0, 20480(V0)
9D002074  30420004   ANDI V0, V0, 4
9D002078  1440FFEB   BNE V0, ZERO, 0x9D002028
9D00207C  00000000   NOP
257:                                I2C3CONbits.PEN ||
9D002080  3C02BF80   LUI V0, -16512
9D002084  8C425000   LW V0, 20480(V0)
9D002088  30420008   ANDI V0, V0, 8
9D00208C  1440FFE6   BNE V0, ZERO, 0x9D002028
9D002090  00000000   NOP
258:                                I2C3CONbits.RCEN ||
9D002094  3C02BF80   LUI V0, -16512
9D002098  8C425000   LW V0, 20480(V0)
9D00209C  30420002   ANDI V0, V0, 2
9D0020A0  1440FFE1   BNE V0, ZERO, 0x9D002028
9D0020A4  00000000   NOP
259:                                I2C3CONbits.RSEN ||
9D0020A8  3C02BF80   LUI V0, -16512
9D0020AC  8C425000   LW V0, 20480(V0)
9D0020B0  30420010   ANDI V0, V0, 16
9D0020B4  1440FFDC   BNE V0, ZERO, 0x9D002028
9D0020B8  00000000   NOP
260:                                I2C3CONbits.ACKEN ||
9D0020BC  3C02BF80   LUI V0, -16512
9D0020C0  8C425010   LW V0, 20496(V0)
9D0020C4  30424000   ANDI V0, V0, 16384
9D0020C8  1440FFD7   BNE V0, ZERO, 0x9D002028
9D0020CC  00000000   NOP
9D0020D0  0B400899   J 0x9D002264
9D0020D4  00000000   NOP
261:                                I2C3STATbits.TRSTAT);
9D002064  1440FFF0   BNE V0, ZERO, 0x9D002028
9D002068  00000000   NOP
262:                 
263:                     }else if(bus_id == I2C_BUS_4){
9D0020D8  8FC30020   LW V1, 32(S8)
9D0020DC  24020003   ADDIU V0, ZERO, 3
9D0020E0  1462002D   BNE V1, V0, 0x9D002198
9D0020E4  00000000   NOP
264:                         do{
265:                             delay_us(1);
9D0020E8  24040001   ADDIU A0, ZERO, 1
9D0020EC  0F402175   JAL delay_us
9D0020F0  00000000   NOP
266:                             if (timeout++ >= TIMEOUT){
9D0020F4  8FC20010   LW V0, 16(S8)
9D0020F8  24430001   ADDIU V1, V0, 1
9D0020FC  AFC30010   SW V1, 16(S8)
9D002100  2C4203E8   SLTIU V0, V0, 1000
9D002104  14400004   BNE V0, ZERO, 0x9D002118
9D002108  00000000   NOP
267:                                 return ERROR;
9D00210C  24020001   ADDIU V0, ZERO, 1
9D002110  0B40089A   J 0x9D002268
9D002114  00000000   NOP
268:                             }
269:                         }while(I2C4CONbits.SEN ||
9D002118  3C02BF80   LUI V0, -16512
9D00211C  8C425100   LW V0, 20736(V0)
9D002120  30420001   ANDI V0, V0, 1
9D00212C  3C02BF80   LUI V0, -16512
9D002130  8C425100   LW V0, 20736(V0)
9D002134  30420004   ANDI V0, V0, 4
9D002138  1440FFEB   BNE V0, ZERO, 0x9D0020E8
9D00213C  00000000   NOP
270:                                I2C4CONbits.PEN ||
9D002140  3C02BF80   LUI V0, -16512
9D002144  8C425100   LW V0, 20736(V0)
9D002148  30420008   ANDI V0, V0, 8
9D00214C  1440FFE6   BNE V0, ZERO, 0x9D0020E8
9D002150  00000000   NOP
271:                                I2C4CONbits.RCEN ||
9D002154  3C02BF80   LUI V0, -16512
9D002158  8C425100   LW V0, 20736(V0)
9D00215C  30420002   ANDI V0, V0, 2
9D002160  1440FFE1   BNE V0, ZERO, 0x9D0020E8
9D002164  00000000   NOP
272:                                I2C4CONbits.RSEN ||
9D002168  3C02BF80   LUI V0, -16512
9D00216C  8C425100   LW V0, 20736(V0)
9D002170  30420010   ANDI V0, V0, 16
9D002174  1440FFDC   BNE V0, ZERO, 0x9D0020E8
9D002178  00000000   NOP
273:                                I2C4CONbits.ACKEN ||
9D00217C  3C02BF80   LUI V0, -16512
9D002180  8C425110   LW V0, 20752(V0)
9D002184  30424000   ANDI V0, V0, 16384
9D002188  1440FFD7   BNE V0, ZERO, 0x9D0020E8
9D00218C  00000000   NOP
9D002190  0B400899   J 0x9D002264
9D002194  00000000   NOP
274:                                I2C4STATbits.TRSTAT);
9D002124  1440FFF0   BNE V0, ZERO, 0x9D0020E8
9D002128  00000000   NOP
275:                 
276:                     }else if(bus_id == I2C_BUS_5){
9D002198  8FC30020   LW V1, 32(S8)
9D00219C  24020004   ADDIU V0, ZERO, 4
9D0021A0  1462002D   BNE V1, V0, 0x9D002258
9D0021A4  00000000   NOP
277:                         do{
278:                             delay_us(1);
9D0021A8  24040001   ADDIU A0, ZERO, 1
9D0021AC  0F402175   JAL delay_us
9D0021B0  00000000   NOP
279:                             if (timeout++ >= TIMEOUT){
9D0021B4  8FC20010   LW V0, 16(S8)
9D0021B8  24430001   ADDIU V1, V0, 1
9D0021BC  AFC30010   SW V1, 16(S8)
9D0021C0  2C4203E8   SLTIU V0, V0, 1000
9D0021C4  14400004   BNE V0, ZERO, 0x9D0021D8
9D0021C8  00000000   NOP
280:                                 return ERROR;
9D0021CC  24020001   ADDIU V0, ZERO, 1
9D0021D0  0B40089A   J 0x9D002268
9D0021D4  00000000   NOP
281:                             }
282:                         }while(I2C5CONbits.SEN ||
9D0021D8  3C02BF80   LUI V0, -16512
9D0021DC  8C425200   LW V0, 20992(V0)
9D0021E0  30420001   ANDI V0, V0, 1
9D0021EC  3C02BF80   LUI V0, -16512
9D0021F0  8C425200   LW V0, 20992(V0)
9D0021F4  30420004   ANDI V0, V0, 4
9D0021F8  1440FFEB   BNE V0, ZERO, 0x9D0021A8
9D0021FC  00000000   NOP
283:                                I2C5CONbits.PEN ||
9D002200  3C02BF80   LUI V0, -16512
9D002204  8C425200   LW V0, 20992(V0)
9D002208  30420008   ANDI V0, V0, 8
9D00220C  1440FFE6   BNE V0, ZERO, 0x9D0021A8
9D002210  00000000   NOP
284:                                I2C5CONbits.RCEN ||
9D002214  3C02BF80   LUI V0, -16512
9D002218  8C425200   LW V0, 20992(V0)
9D00221C  30420002   ANDI V0, V0, 2
9D002220  1440FFE1   BNE V0, ZERO, 0x9D0021A8
9D002224  00000000   NOP
285:                                I2C5CONbits.RSEN ||
9D002228  3C02BF80   LUI V0, -16512
9D00222C  8C425200   LW V0, 20992(V0)
9D002230  30420010   ANDI V0, V0, 16
9D002234  1440FFDC   BNE V0, ZERO, 0x9D0021A8
9D002238  00000000   NOP
286:                                I2C5CONbits.ACKEN ||
9D00223C  3C02BF80   LUI V0, -16512
9D002240  8C425210   LW V0, 21008(V0)
9D002244  30424000   ANDI V0, V0, 16384
9D002248  1440FFD7   BNE V0, ZERO, 0x9D0021A8
9D00224C  00000000   NOP
9D002250  0B400899   J 0x9D002264
9D002254  00000000   NOP
287:                                I2C5STATbits.TRSTAT);
9D0021E4  1440FFF0   BNE V0, ZERO, 0x9D0021A8
9D0021E8  00000000   NOP
288:                 
289:                     }else{
290:                         return ERROR;
9D002258  24020001   ADDIU V0, ZERO, 1
9D00225C  0B40089A   J 0x9D002268
9D002260  00000000   NOP
291:                     }
292:                 
293:                     return SUCCESS;
9D002264  00001021   ADDU V0, ZERO, ZERO
294:                 }
9D002268  03C0E821   ADDU SP, S8, ZERO
9D00226C  8FBF001C   LW RA, 28(SP)
9D002270  8FBE0018   LW S8, 24(SP)
9D002274  27BD0020   ADDIU SP, SP, 32
9D002278  03E00008   JR RA
9D00227C  00000000   NOP
295:                 
296:                 
297:                 
298:                 
299:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
300:                 //--------------------------- Read operation ----------------------------------
301:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
302:                 RESULT i2c_read(I2C_BUS bus_id, u8 *data, u8 ack)
303:                 {
9D002280  27BDFFE0   ADDIU SP, SP, -32
9D002284  AFBF001C   SW RA, 28(SP)
9D002288  AFBE0018   SW S8, 24(SP)
9D00228C  03A0F021   ADDU S8, SP, ZERO
9D002290  AFC40020   SW A0, 32(S8)
9D002294  AFC50024   SW A1, 36(S8)
9D002298  00C01021   ADDU V0, A2, ZERO
9D00229C  A3C20028   SB V0, 40(S8)
304:                     RESULT result = SUCCESS;
9D0022A0  AFC00010   SW ZERO, 16(S8)
305:                 
306:                     if      (bus_id == I2C_BUS_1){
9D0022A4  8FC20020   LW V0, 32(S8)
9D0022A8  14400020   BNE V0, ZERO, 0x9D00232C
9D0022AC  00000000   NOP
307:                         result = i2c_wait(bus_id);           // Wait to complete
9D0022B0  8FC40020   LW A0, 32(S8)
9D0022B4  0F4007A1   JAL i2c_wait
9D0022B8  00000000   NOP
9D0022BC  AFC20010   SW V0, 16(S8)
308:                         I2C1CONbits.RCEN = 1;
9D0022C0  3C03BF80   LUI V1, -16512
9D0022C4  94625300   LHU V0, 21248(V1)
9D0022C8  24040001   ADDIU A0, ZERO, 1
9D0022CC  7C8218C4   INS V0, A0, 3, 1
9D0022D0  A4625300   SH V0, 21248(V1)
309:                         while(I2C1CONbits.RCEN);
9D0022D4  00000000   NOP
9D0022D8  3C02BF80   LUI V0, -16512
9D0022DC  8C425300   LW V0, 21248(V0)
9D0022E0  30420008   ANDI V0, V0, 8
9D0022E4  1440FFFC   BNE V0, ZERO, 0x9D0022D8
9D0022E8  00000000   NOP
310:                         I2C1STATbits.I2COV = 0;
9D0022EC  3C03BF80   LUI V1, -16512
9D0022F0  94625310   LHU V0, 21264(V1)
9D0022F4  7C023184   INS V0, ZERO, 6, 1
9D0022F8  A4625310   SH V0, 21264(V1)
311:                         *data = I2C1RCV;
9D0022FC  3C02BF80   LUI V0, -16512
9D002300  8C425360   LW V0, 21344(V0)
9D002304  304300FF   ANDI V1, V0, 255
9D002308  8FC20024   LW V0, 36(S8)
9D00230C  A0430000   SB V1, 0(V0)
312:                         i2c_send_ack(bus_id, ack);
9D002310  93C20028   LBU V0, 40(S8)
9D002314  8FC40020   LW A0, 32(S8)
9D002318  00402821   ADDU A1, V0, ZERO
9D00231C  0F400A1D   JAL i2c_send_ack
9D002320  00000000   NOP
9D002324  0B40095A   J 0x9D002568
9D002328  00000000   NOP
313:                 
314:                     }else if(bus_id == I2C_BUS_2){
9D00232C  8FC30020   LW V1, 32(S8)
9D002330  24020001   ADDIU V0, ZERO, 1
9D002334  14620020   BNE V1, V0, 0x9D0023B8
9D002338  00000000   NOP
315:                         result = i2c_wait(bus_id);           // Wait to complete
9D00233C  8FC40020   LW A0, 32(S8)
9D002340  0F4007A1   JAL i2c_wait
9D002344  00000000   NOP
9D002348  AFC20010   SW V0, 16(S8)
316:                         I2C2CONbits.RCEN = 1;
9D00234C  3C03BF80   LUI V1, -16512
9D002350  94625400   LHU V0, 21504(V1)
9D002354  24040001   ADDIU A0, ZERO, 1
9D002358  7C8218C4   INS V0, A0, 3, 1
9D00235C  A4625400   SH V0, 21504(V1)
317:                         while(I2C2CONbits.RCEN);
9D002360  00000000   NOP
9D002364  3C02BF80   LUI V0, -16512
9D002368  8C425400   LW V0, 21504(V0)
9D00236C  30420008   ANDI V0, V0, 8
9D002370  1440FFFC   BNE V0, ZERO, 0x9D002364
9D002374  00000000   NOP
318:                         I2C2STATbits.I2COV = 0;
9D002378  3C03BF80   LUI V1, -16512
9D00237C  94625410   LHU V0, 21520(V1)
9D002380  7C023184   INS V0, ZERO, 6, 1
9D002384  A4625410   SH V0, 21520(V1)
319:                         *data = I2C2RCV;
9D002388  3C02BF80   LUI V0, -16512
9D00238C  8C425460   LW V0, 21600(V0)
9D002390  304300FF   ANDI V1, V0, 255
9D002394  8FC20024   LW V0, 36(S8)
9D002398  A0430000   SB V1, 0(V0)
320:                         i2c_send_ack(bus_id, ack);
9D00239C  93C20028   LBU V0, 40(S8)
9D0023A0  8FC40020   LW A0, 32(S8)
9D0023A4  00402821   ADDU A1, V0, ZERO
9D0023A8  0F400A1D   JAL i2c_send_ack
9D0023AC  00000000   NOP
9D0023B0  0B40095A   J 0x9D002568
9D0023B4  00000000   NOP
321:                 
322:                     }else if(bus_id == I2C_BUS_3){
9D0023B8  8FC30020   LW V1, 32(S8)
9D0023BC  24020002   ADDIU V0, ZERO, 2
9D0023C0  14620020   BNE V1, V0, 0x9D002444
9D0023C4  00000000   NOP
323:                         result = i2c_wait(bus_id);           // Wait to complete
9D0023C8  8FC40020   LW A0, 32(S8)
9D0023CC  0F4007A1   JAL i2c_wait
9D0023D0  00000000   NOP
9D0023D4  AFC20010   SW V0, 16(S8)
324:                         I2C3CONbits.RCEN = 1;
9D0023D8  3C03BF80   LUI V1, -16512
9D0023DC  94625000   LHU V0, 20480(V1)
9D0023E0  24040001   ADDIU A0, ZERO, 1
9D0023E4  7C8218C4   INS V0, A0, 3, 1
9D0023E8  A4625000   SH V0, 20480(V1)
325:                         while(I2C3CONbits.RCEN);
9D0023EC  00000000   NOP
9D0023F0  3C02BF80   LUI V0, -16512
9D0023F4  8C425000   LW V0, 20480(V0)
9D0023F8  30420008   ANDI V0, V0, 8
9D0023FC  1440FFFC   BNE V0, ZERO, 0x9D0023F0
9D002400  00000000   NOP
326:                         I2C3STATbits.I2COV = 0;
9D002404  3C03BF80   LUI V1, -16512
9D002408  94625010   LHU V0, 20496(V1)
9D00240C  7C023184   INS V0, ZERO, 6, 1
9D002410  A4625010   SH V0, 20496(V1)
327:                         *data = I2C3RCV;
9D002414  3C02BF80   LUI V0, -16512
9D002418  8C425060   LW V0, 20576(V0)
9D00241C  304300FF   ANDI V1, V0, 255
9D002420  8FC20024   LW V0, 36(S8)
9D002424  A0430000   SB V1, 0(V0)
328:                         i2c_send_ack(bus_id, ack);
9D002428  93C20028   LBU V0, 40(S8)
9D00242C  8FC40020   LW A0, 32(S8)
9D002430  00402821   ADDU A1, V0, ZERO
9D002434  0F400A1D   JAL i2c_send_ack
9D002438  00000000   NOP
9D00243C  0B40095A   J 0x9D002568
9D002440  00000000   NOP
329:                 
330:                     }else if(bus_id == I2C_BUS_4){
9D002444  8FC30020   LW V1, 32(S8)
9D002448  24020003   ADDIU V0, ZERO, 3
9D00244C  14620020   BNE V1, V0, 0x9D0024D0
9D002450  00000000   NOP
331:                         result = i2c_wait(bus_id);           // Wait to complete
9D002454  8FC40020   LW A0, 32(S8)
9D002458  0F4007A1   JAL i2c_wait
9D00245C  00000000   NOP
9D002460  AFC20010   SW V0, 16(S8)
332:                         I2C4CONbits.RCEN = 1;
9D002464  3C03BF80   LUI V1, -16512
9D002468  94625100   LHU V0, 20736(V1)
9D00246C  24040001   ADDIU A0, ZERO, 1
9D002470  7C8218C4   INS V0, A0, 3, 1
9D002474  A4625100   SH V0, 20736(V1)
333:                         while(I2C4CONbits.RCEN);
9D002478  00000000   NOP
9D00247C  3C02BF80   LUI V0, -16512
9D002480  8C425100   LW V0, 20736(V0)
9D002484  30420008   ANDI V0, V0, 8
9D002488  1440FFFC   BNE V0, ZERO, 0x9D00247C
9D00248C  00000000   NOP
334:                         I2C4STATbits.I2COV = 0;
9D002490  3C03BF80   LUI V1, -16512
9D002494  94625110   LHU V0, 20752(V1)
9D002498  7C023184   INS V0, ZERO, 6, 1
9D00249C  A4625110   SH V0, 20752(V1)
335:                         *data = I2C4RCV;
9D0024A0  3C02BF80   LUI V0, -16512
9D0024A4  8C425160   LW V0, 20832(V0)
9D0024A8  304300FF   ANDI V1, V0, 255
9D0024AC  8FC20024   LW V0, 36(S8)
9D0024B0  A0430000   SB V1, 0(V0)
336:                         i2c_send_ack(bus_id, ack);
9D0024B4  93C20028   LBU V0, 40(S8)
9D0024B8  8FC40020   LW A0, 32(S8)
9D0024BC  00402821   ADDU A1, V0, ZERO
9D0024C0  0F400A1D   JAL i2c_send_ack
9D0024C4  00000000   NOP
9D0024C8  0B40095A   J 0x9D002568
9D0024CC  00000000   NOP
337:                 
338:                     }else if(bus_id == I2C_BUS_5){
9D0024D0  8FC30020   LW V1, 32(S8)
9D0024D4  24020004   ADDIU V0, ZERO, 4
9D0024D8  14620020   BNE V1, V0, 0x9D00255C
9D0024DC  00000000   NOP
339:                         result = i2c_wait(bus_id);           // Wait to complete
9D0024E0  8FC40020   LW A0, 32(S8)
9D0024E4  0F4007A1   JAL i2c_wait
9D0024E8  00000000   NOP
9D0024EC  AFC20010   SW V0, 16(S8)
340:                         I2C5CONbits.RCEN = 1;
9D0024F0  3C03BF80   LUI V1, -16512
9D0024F4  94625200   LHU V0, 20992(V1)
9D0024F8  24040001   ADDIU A0, ZERO, 1
9D0024FC  7C8218C4   INS V0, A0, 3, 1
9D002500  A4625200   SH V0, 20992(V1)
341:                         while(I2C5CONbits.RCEN);
9D002504  00000000   NOP
9D002508  3C02BF80   LUI V0, -16512
9D00250C  8C425200   LW V0, 20992(V0)
9D002510  30420008   ANDI V0, V0, 8
9D002514  1440FFFC   BNE V0, ZERO, 0x9D002508
9D002518  00000000   NOP
342:                         I2C5STATbits.I2COV = 0;
9D00251C  3C03BF80   LUI V1, -16512
9D002520  94625210   LHU V0, 21008(V1)
9D002524  7C023184   INS V0, ZERO, 6, 1
9D002528  A4625210   SH V0, 21008(V1)
343:                         *data = I2C5RCV;
9D00252C  3C02BF80   LUI V0, -16512
9D002530  8C425260   LW V0, 21088(V0)
9D002534  304300FF   ANDI V1, V0, 255
9D002538  8FC20024   LW V0, 36(S8)
9D00253C  A0430000   SB V1, 0(V0)
344:                         i2c_send_ack(bus_id, ack);
9D002540  93C20028   LBU V0, 40(S8)
9D002544  8FC40020   LW A0, 32(S8)
9D002548  00402821   ADDU A1, V0, ZERO
9D00254C  0F400A1D   JAL i2c_send_ack
9D002550  00000000   NOP
9D002554  0B40095A   J 0x9D002568
9D002558  00000000   NOP
345:                 
346:                     }else{
347:                         return ERROR;
9D00255C  24020001   ADDIU V0, ZERO, 1
9D002560  0B40095B   J 0x9D00256C
9D002564  00000000   NOP
348:                     }
349:                 
350:                     return result;
9D002568  8FC20010   LW V0, 16(S8)
351:                 
352:                 }
9D00256C  03C0E821   ADDU SP, S8, ZERO
9D002570  8FBF001C   LW RA, 28(SP)
9D002574  8FBE0018   LW S8, 24(SP)
9D002578  27BD0020   ADDIU SP, SP, 32
9D00257C  03E00008   JR RA
9D002580  00000000   NOP
353:                 
354:                 
355:                 
356:                 
357:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
358:                 //--------------------------- Write operation ---------------------------------
359:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
360:                 RESULT i2c_write(I2C_BUS bus_id, u8 data)
361:                 {
9D002584  27BDFFE8   ADDIU SP, SP, -24
9D002588  AFBF0014   SW RA, 20(SP)
9D00258C  AFBE0010   SW S8, 16(SP)
9D002590  03A0F021   ADDU S8, SP, ZERO
9D002594  AFC40018   SW A0, 24(S8)
9D002598  00A01021   ADDU V0, A1, ZERO
9D00259C  A3C2001C   SB V0, 28(S8)
362:                     if      (bus_id == I2C_BUS_1){
9D0025A0  8FC20018   LW V0, 24(S8)
9D0025A4  14400020   BNE V0, ZERO, 0x9D002628
9D0025A8  00000000   NOP
363:                         I2C1TRN = data;
9D0025AC  93C3001C   LBU V1, 28(S8)
9D0025B0  3C02BF80   LUI V0, -16512
9D0025B4  AC435350   SW V1, 21328(V0)
364:                         if (I2C1STATbits.IWCOL)             // If write collision occurs,return error
9D0025B8  3C02BF80   LUI V0, -16512
9D0025BC  8C425310   LW V0, 21264(V0)
9D0025C0  30420080   ANDI V0, V0, 128
9D0025C4  10400004   BEQ V0, ZERO, 0x9D0025D8
9D0025C8  00000000   NOP
365:                             return ERROR;
9D0025CC  24020001   ADDIU V0, ZERO, 1
9D0025D0  0B400A17   J 0x9D00285C
9D0025D4  00000000   NOP
366:                         else
367:                         {
368:                             while(I2C1STATbits.TRSTAT);     // wait until write cycle is complete
9D0025D8  00000000   NOP
9D0025DC  3C02BF80   LUI V0, -16512
9D0025E0  8C425310   LW V0, 21264(V0)
9D0025E4  30424000   ANDI V0, V0, 16384
9D0025E8  1440FFFC   BNE V0, ZERO, 0x9D0025DC
9D0025EC  00000000   NOP
369:                             i2c_wait(bus_id);               // Wait to complete
9D0025F0  8FC40018   LW A0, 24(S8)
9D0025F4  0F4007A1   JAL i2c_wait
9D0025F8  00000000   NOP
370:                             if (I2C1STATbits.ACKSTAT){      // test for ACK condition received (1 = not received)
9D0025FC  3C02BF80   LUI V0, -16512
9D002600  8C425310   LW V0, 21264(V0)
9D002604  30428000   ANDI V0, V0, -32768
9D002608  10400004   BEQ V0, ZERO, 0x9D00261C
9D00260C  00000000   NOP
371:                                 return ERROR;
9D002610  24020001   ADDIU V0, ZERO, 1
9D002614  0B400A17   J 0x9D00285C
9D002618  00000000   NOP
372:                             }else{
373:                                 return SUCCESS;             // if WCOL bit is not set return non-negative #
9D00261C  00001021   ADDU V0, ZERO, ZERO
9D002620  0B400A17   J 0x9D00285C
9D002624  00000000   NOP
374:                             }
375:                         }
376:                 
377:                     }else if(bus_id == I2C_BUS_2){
9D002628  8FC30018   LW V1, 24(S8)
9D00262C  24020001   ADDIU V0, ZERO, 1
9D002630  14620020   BNE V1, V0, 0x9D0026B4
9D002634  00000000   NOP
378:                         I2C2TRN = data;
9D002638  93C3001C   LBU V1, 28(S8)
9D00263C  3C02BF80   LUI V0, -16512
9D002640  AC435450   SW V1, 21584(V0)
379:                         if (I2C2STATbits.IWCOL)             // If write collision occurs,return error
9D002644  3C02BF80   LUI V0, -16512
9D002648  8C425410   LW V0, 21520(V0)
9D00264C  30420080   ANDI V0, V0, 128
9D002650  10400004   BEQ V0, ZERO, 0x9D002664
9D002654  00000000   NOP
380:                             return ERROR;
9D002658  24020001   ADDIU V0, ZERO, 1
9D00265C  0B400A17   J 0x9D00285C
9D002660  00000000   NOP
381:                         else
382:                         {
383:                             while(I2C2STATbits.TRSTAT);     // wait until write cycle is complete
9D002664  00000000   NOP
9D002668  3C02BF80   LUI V0, -16512
9D00266C  8C425410   LW V0, 21520(V0)
9D002670  30424000   ANDI V0, V0, 16384
9D002674  1440FFFC   BNE V0, ZERO, 0x9D002668
9D002678  00000000   NOP
384:                             i2c_wait(bus_id);               // Wait to complete
9D00267C  8FC40018   LW A0, 24(S8)
9D002680  0F4007A1   JAL i2c_wait
9D002684  00000000   NOP
385:                             if (I2C2STATbits.ACKSTAT){      // test for ACK condition received (1 = not received)
9D002688  3C02BF80   LUI V0, -16512
9D00268C  8C425410   LW V0, 21520(V0)
9D002690  30428000   ANDI V0, V0, -32768
9D002694  10400004   BEQ V0, ZERO, 0x9D0026A8
9D002698  00000000   NOP
386:                                 return ERROR;
9D00269C  24020001   ADDIU V0, ZERO, 1
9D0026A0  0B400A17   J 0x9D00285C
9D0026A4  00000000   NOP
387:                             }else{
388:                                 return SUCCESS;             // if WCOL bit is not set return non-negative #
9D0026A8  00001021   ADDU V0, ZERO, ZERO
9D0026AC  0B400A17   J 0x9D00285C
9D0026B0  00000000   NOP
389:                             }
390:                         }
391:                 
392:                     }else if(bus_id == I2C_BUS_3){
9D0026B4  8FC30018   LW V1, 24(S8)
9D0026B8  24020002   ADDIU V0, ZERO, 2
9D0026BC  14620020   BNE V1, V0, 0x9D002740
9D0026C0  00000000   NOP
393:                         I2C3TRN = data;
9D0026C4  93C3001C   LBU V1, 28(S8)
9D0026C8  3C02BF80   LUI V0, -16512
9D0026CC  AC435050   SW V1, 20560(V0)
394:                         if (I2C3STATbits.IWCOL)             // If write collision occurs,return error
9D0026D0  3C02BF80   LUI V0, -16512
9D0026D4  8C425010   LW V0, 20496(V0)
9D0026D8  30420080   ANDI V0, V0, 128
9D0026DC  10400004   BEQ V0, ZERO, 0x9D0026F0
9D0026E0  00000000   NOP
395:                             return ERROR;
9D0026E4  24020001   ADDIU V0, ZERO, 1
9D0026E8  0B400A17   J 0x9D00285C
9D0026EC  00000000   NOP
396:                         else
397:                         {
398:                             while(I2C3STATbits.TRSTAT);     // wait until write cycle is complete
9D0026F0  00000000   NOP
9D0026F4  3C02BF80   LUI V0, -16512
9D0026F8  8C425010   LW V0, 20496(V0)
9D0026FC  30424000   ANDI V0, V0, 16384
9D002700  1440FFFC   BNE V0, ZERO, 0x9D0026F4
9D002704  00000000   NOP
399:                             i2c_wait(bus_id);               // Wait to complete
9D002708  8FC40018   LW A0, 24(S8)
9D00270C  0F4007A1   JAL i2c_wait
9D002710  00000000   NOP
400:                             if (I2C3STATbits.ACKSTAT){      // test for ACK condition received (1 = not received)
9D002714  3C02BF80   LUI V0, -16512
9D002718  8C425010   LW V0, 20496(V0)
9D00271C  30428000   ANDI V0, V0, -32768
9D002720  10400004   BEQ V0, ZERO, 0x9D002734
9D002724  00000000   NOP
401:                                 return ERROR;
9D002728  24020001   ADDIU V0, ZERO, 1
9D00272C  0B400A17   J 0x9D00285C
9D002730  00000000   NOP
402:                             }else{
403:                                 return SUCCESS;             // if WCOL bit is not set return non-negative #
9D002734  00001021   ADDU V0, ZERO, ZERO
9D002738  0B400A17   J 0x9D00285C
9D00273C  00000000   NOP
404:                             }
405:                         }
406:                 
407:                     }else if(bus_id == I2C_BUS_4){
9D002740  8FC30018   LW V1, 24(S8)
9D002744  24020003   ADDIU V0, ZERO, 3
9D002748  14620020   BNE V1, V0, 0x9D0027CC
9D00274C  00000000   NOP
408:                         I2C4TRN = data;
9D002750  93C3001C   LBU V1, 28(S8)
9D002754  3C02BF80   LUI V0, -16512
9D002758  AC435150   SW V1, 20816(V0)
409:                         if (I2C4STATbits.IWCOL)             // If write collision occurs,return error
9D00275C  3C02BF80   LUI V0, -16512
9D002760  8C425110   LW V0, 20752(V0)
9D002764  30420080   ANDI V0, V0, 128
9D002768  10400004   BEQ V0, ZERO, 0x9D00277C
9D00276C  00000000   NOP
410:                             return ERROR;
9D002770  24020001   ADDIU V0, ZERO, 1
9D002774  0B400A17   J 0x9D00285C
9D002778  00000000   NOP
411:                         else
412:                         {
413:                             while(I2C4STATbits.TRSTAT);     // wait until write cycle is complete
9D00277C  00000000   NOP
9D002780  3C02BF80   LUI V0, -16512
9D002784  8C425110   LW V0, 20752(V0)
9D002788  30424000   ANDI V0, V0, 16384
9D00278C  1440FFFC   BNE V0, ZERO, 0x9D002780
9D002790  00000000   NOP
414:                             i2c_wait(bus_id);               // Wait to complete
9D002794  8FC40018   LW A0, 24(S8)
9D002798  0F4007A1   JAL i2c_wait
9D00279C  00000000   NOP
415:                             if (I2C4STATbits.ACKSTAT){      // test for ACK condition received (1 = not received)
9D0027A0  3C02BF80   LUI V0, -16512
9D0027A4  8C425110   LW V0, 20752(V0)
9D0027A8  30428000   ANDI V0, V0, -32768
9D0027AC  10400004   BEQ V0, ZERO, 0x9D0027C0
9D0027B0  00000000   NOP
416:                                 return ERROR;
9D0027B4  24020001   ADDIU V0, ZERO, 1
9D0027B8  0B400A17   J 0x9D00285C
9D0027BC  00000000   NOP
417:                             }else{
418:                                 return SUCCESS;             // if WCOL bit is not set return non-negative #
9D0027C0  00001021   ADDU V0, ZERO, ZERO
9D0027C4  0B400A17   J 0x9D00285C
9D0027C8  00000000   NOP
419:                             }
420:                         }
421:                 
422:                     }else if(bus_id == I2C_BUS_5){
9D0027CC  8FC30018   LW V1, 24(S8)
9D0027D0  24020004   ADDIU V0, ZERO, 4
9D0027D4  14620020   BNE V1, V0, 0x9D002858
9D0027D8  00000000   NOP
423:                         I2C5TRN = data;
9D0027DC  93C3001C   LBU V1, 28(S8)
9D0027E0  3C02BF80   LUI V0, -16512
9D0027E4  AC435250   SW V1, 21072(V0)
424:                         if (I2C5STATbits.IWCOL)             // If write collision occurs,return error
9D0027E8  3C02BF80   LUI V0, -16512
9D0027EC  8C425210   LW V0, 21008(V0)
9D0027F0  30420080   ANDI V0, V0, 128
9D0027F4  10400004   BEQ V0, ZERO, 0x9D002808
9D0027F8  00000000   NOP
425:                             return ERROR;
9D0027FC  24020001   ADDIU V0, ZERO, 1
9D002800  0B400A17   J 0x9D00285C
9D002804  00000000   NOP
426:                         else
427:                         {
428:                             while(I2C5STATbits.TRSTAT);     // wait until write cycle is complete
9D002808  00000000   NOP
9D00280C  3C02BF80   LUI V0, -16512
9D002810  8C425210   LW V0, 21008(V0)
9D002814  30424000   ANDI V0, V0, 16384
9D002818  1440FFFC   BNE V0, ZERO, 0x9D00280C
9D00281C  00000000   NOP
429:                             i2c_wait(bus_id);               // Wait to complete
9D002820  8FC40018   LW A0, 24(S8)
9D002824  0F4007A1   JAL i2c_wait
9D002828  00000000   NOP
430:                             if (I2C5STATbits.ACKSTAT){      // test for ACK condition received (1 = not received)
9D00282C  3C02BF80   LUI V0, -16512
9D002830  8C425210   LW V0, 21008(V0)
9D002834  30428000   ANDI V0, V0, -32768
9D002838  10400004   BEQ V0, ZERO, 0x9D00284C
9D00283C  00000000   NOP
431:                                 return ERROR;
9D002840  24020001   ADDIU V0, ZERO, 1
9D002844  0B400A17   J 0x9D00285C
9D002848  00000000   NOP
432:                             }else{
433:                                 return SUCCESS;             // if WCOL bit is not set return non-negative #
9D00284C  00001021   ADDU V0, ZERO, ZERO
9D002850  0B400A17   J 0x9D00285C
9D002854  00000000   NOP
434:                             }
435:                         }
436:                 
437:                     }else{
438:                         return ERROR;
9D002858  24020001   ADDIU V0, ZERO, 1
439:                     }
440:                 }
9D00285C  03C0E821   ADDU SP, S8, ZERO
9D002860  8FBF0014   LW RA, 20(SP)
9D002864  8FBE0010   LW S8, 16(SP)
9D002868  27BD0018   ADDIU SP, SP, 24
9D00286C  03E00008   JR RA
9D002870  00000000   NOP
441:                 
442:                 
443:                 
444:                 
445:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
446:                 //------------------------ Send Ack or Nack to a slave ------------------------
447:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
448:                 RESULT i2c_send_ack(I2C_BUS bus_id, u8 ack)
449:                 {
9D002874  27BDFFF8   ADDIU SP, SP, -8
9D002878  AFBE0004   SW S8, 4(SP)
9D00287C  03A0F021   ADDU S8, SP, ZERO
9D002880  AFC40008   SW A0, 8(S8)
9D002884  00A01021   ADDU V0, A1, ZERO
9D002888  A3C2000C   SB V0, 12(S8)
450:                     if      (bus_id == I2C_BUS_1){
9D00288C  8FC20008   LW V0, 8(S8)
9D002890  14400014   BNE V0, ZERO, 0x9D0028E4
9D002894  00000000   NOP
451:                         if (ack){
9D002898  93C2000C   LBU V0, 12(S8)
9D00289C  10400009   BEQ V0, ZERO, 0x9D0028C4
9D0028A0  00000000   NOP
452:                             I2C1CONCLR = _I2C1CON_ACKDT_MASK;
9D0028A4  3C02BF80   LUI V0, -16512
9D0028A8  24030020   ADDIU V1, ZERO, 32
9D0028AC  AC435304   SW V1, 21252(V0)
453:                             I2C1CONSET = _I2C1CON_ACKEN_MASK;
9D0028B0  3C02BF80   LUI V0, -16512
9D0028B4  24030010   ADDIU V1, ZERO, 16
9D0028B8  AC435308   SW V1, 21256(V0)
9D0028BC  0B400A98   J 0x9D002A60
9D0028C0  00000000   NOP
454:                         }else{
455:                             I2C1CONSET = _I2C1CON_ACKDT_MASK;
9D0028C4  3C02BF80   LUI V0, -16512
9D0028C8  24030020   ADDIU V1, ZERO, 32
9D0028CC  AC435308   SW V1, 21256(V0)
456:                             I2C1CONSET = _I2C1CON_ACKEN_MASK;
9D0028D0  3C02BF80   LUI V0, -16512
9D0028D4  24030010   ADDIU V1, ZERO, 16
9D0028D8  AC435308   SW V1, 21256(V0)
9D0028DC  0B400A98   J 0x9D002A60
9D0028E0  00000000   NOP
457:                         }
458:                 
459:                     }else if(bus_id == I2C_BUS_2){
9D0028E4  8FC30008   LW V1, 8(S8)
9D0028E8  24020001   ADDIU V0, ZERO, 1
9D0028EC  14620014   BNE V1, V0, 0x9D002940
9D0028F0  00000000   NOP
460:                         if (ack){
9D0028F4  93C2000C   LBU V0, 12(S8)
9D0028F8  10400009   BEQ V0, ZERO, 0x9D002920
9D0028FC  00000000   NOP
461:                             I2C2CONCLR = _I2C2CON_ACKDT_MASK;
9D002900  3C02BF80   LUI V0, -16512
9D002904  24030020   ADDIU V1, ZERO, 32
9D002908  AC435404   SW V1, 21508(V0)
462:                             I2C2CONSET = _I2C2CON_ACKEN_MASK;
9D00290C  3C02BF80   LUI V0, -16512
9D002910  24030010   ADDIU V1, ZERO, 16
9D002914  AC435408   SW V1, 21512(V0)
9D002918  0B400A98   J 0x9D002A60
9D00291C  00000000   NOP
463:                         }else{
464:                             I2C2CONSET = _I2C2CON_ACKDT_MASK;
9D002920  3C02BF80   LUI V0, -16512
9D002924  24030020   ADDIU V1, ZERO, 32
9D002928  AC435408   SW V1, 21512(V0)
465:                             I2C2CONSET = _I2C2CON_ACKEN_MASK;
9D00292C  3C02BF80   LUI V0, -16512
9D002930  24030010   ADDIU V1, ZERO, 16
9D002934  AC435408   SW V1, 21512(V0)
9D002938  0B400A98   J 0x9D002A60
9D00293C  00000000   NOP
466:                         }
467:                 
468:                     }else if(bus_id == I2C_BUS_3){
9D002940  8FC30008   LW V1, 8(S8)
9D002944  24020002   ADDIU V0, ZERO, 2
9D002948  14620014   BNE V1, V0, 0x9D00299C
9D00294C  00000000   NOP
469:                         if (ack){
9D002950  93C2000C   LBU V0, 12(S8)
9D002954  10400009   BEQ V0, ZERO, 0x9D00297C
9D002958  00000000   NOP
470:                             I2C3CONCLR = _I2C3CON_ACKDT_MASK;
9D00295C  3C02BF80   LUI V0, -16512
9D002960  24030020   ADDIU V1, ZERO, 32
9D002964  AC435004   SW V1, 20484(V0)
471:                             I2C3CONSET = _I2C3CON_ACKEN_MASK;
9D002968  3C02BF80   LUI V0, -16512
9D00296C  24030010   ADDIU V1, ZERO, 16
9D002970  AC435008   SW V1, 20488(V0)
9D002974  0B400A98   J 0x9D002A60
9D002978  00000000   NOP
472:                         }else{
473:                             I2C3CONSET = _I2C3CON_ACKDT_MASK;
9D00297C  3C02BF80   LUI V0, -16512
9D002980  24030020   ADDIU V1, ZERO, 32
9D002984  AC435008   SW V1, 20488(V0)
474:                             I2C3CONSET = _I2C3CON_ACKEN_MASK;
9D002988  3C02BF80   LUI V0, -16512
9D00298C  24030010   ADDIU V1, ZERO, 16
9D002990  AC435008   SW V1, 20488(V0)
9D002994  0B400A98   J 0x9D002A60
9D002998  00000000   NOP
475:                         }
476:                 
477:                     }else if(bus_id == I2C_BUS_4){
9D00299C  8FC30008   LW V1, 8(S8)
9D0029A0  24020003   ADDIU V0, ZERO, 3
9D0029A4  14620014   BNE V1, V0, 0x9D0029F8
9D0029A8  00000000   NOP
478:                         if (ack){
9D0029AC  93C2000C   LBU V0, 12(S8)
9D0029B0  10400009   BEQ V0, ZERO, 0x9D0029D8
9D0029B4  00000000   NOP
479:                             I2C4CONCLR = _I2C4CON_ACKDT_MASK;
9D0029B8  3C02BF80   LUI V0, -16512
9D0029BC  24030020   ADDIU V1, ZERO, 32
9D0029C0  AC435104   SW V1, 20740(V0)
480:                             I2C4CONSET = _I2C4CON_ACKEN_MASK;
9D0029C4  3C02BF80   LUI V0, -16512
9D0029C8  24030010   ADDIU V1, ZERO, 16
9D0029CC  AC435108   SW V1, 20744(V0)
9D0029D0  0B400A98   J 0x9D002A60
9D0029D4  00000000   NOP
481:                         }else{
482:                             I2C4CONSET = _I2C4CON_ACKDT_MASK;
9D0029D8  3C02BF80   LUI V0, -16512
9D0029DC  24030020   ADDIU V1, ZERO, 32
9D0029E0  AC435108   SW V1, 20744(V0)
483:                             I2C4CONSET = _I2C4CON_ACKEN_MASK;
9D0029E4  3C02BF80   LUI V0, -16512
9D0029E8  24030010   ADDIU V1, ZERO, 16
9D0029EC  AC435108   SW V1, 20744(V0)
9D0029F0  0B400A98   J 0x9D002A60
9D0029F4  00000000   NOP
484:                         }
485:                 
486:                     }else if(bus_id == I2C_BUS_5){
9D0029F8  8FC30008   LW V1, 8(S8)
9D0029FC  24020004   ADDIU V0, ZERO, 4
9D002A00  14620014   BNE V1, V0, 0x9D002A54
9D002A04  00000000   NOP
487:                         if (ack){
9D002A08  93C2000C   LBU V0, 12(S8)
9D002A0C  10400009   BEQ V0, ZERO, 0x9D002A34
9D002A10  00000000   NOP
488:                             I2C5CONCLR = _I2C5CON_ACKDT_MASK;
9D002A14  3C02BF80   LUI V0, -16512
9D002A18  24030020   ADDIU V1, ZERO, 32
9D002A1C  AC435204   SW V1, 20996(V0)
489:                             I2C5CONSET = _I2C5CON_ACKEN_MASK;
9D002A20  3C02BF80   LUI V0, -16512
9D002A24  24030010   ADDIU V1, ZERO, 16
9D002A28  AC435208   SW V1, 21000(V0)
9D002A2C  0B400A98   J 0x9D002A60
9D002A30  00000000   NOP
490:                         }else{
491:                             I2C5CONSET = _I2C5CON_ACKDT_MASK;
9D002A34  3C02BF80   LUI V0, -16512
9D002A38  24030020   ADDIU V1, ZERO, 32
9D002A3C  AC435208   SW V1, 21000(V0)
492:                             I2C5CONSET = _I2C5CON_ACKEN_MASK;
9D002A40  3C02BF80   LUI V0, -16512
9D002A44  24030010   ADDIU V1, ZERO, 16
9D002A48  AC435208   SW V1, 21000(V0)
9D002A4C  0B400A98   J 0x9D002A60
9D002A50  00000000   NOP
493:                         }
494:                 
495:                     }else{
496:                         return ERROR;
9D002A54  24020001   ADDIU V0, ZERO, 1
9D002A58  0B400A99   J 0x9D002A64
9D002A5C  00000000   NOP
497:                     }
498:                 
499:                     return SUCCESS;
9D002A60  00001021   ADDU V0, ZERO, ZERO
500:                 
501:                 }
9D002A64  03C0E821   ADDU SP, S8, ZERO
9D002A68  8FBE0004   LW S8, 4(SP)
9D002A6C  27BD0008   ADDIU SP, SP, 8
9D002A70  03E00008   JR RA
9D002A74  00000000   NOP
502:                 
503:                 
504:                 
505:                 
506:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
507:                 //------------------------- Read a register of a chip -------------------------
508:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
509:                 RESULT i2c_read_reg(I2C_BUS bus_id, u8 adr_chip, u8 adr_reg, u8 *data)
510:                 {
9D002A78  27BDFFE0   ADDIU SP, SP, -32
9D002A7C  AFBF001C   SW RA, 28(SP)
9D002A80  AFBE0018   SW S8, 24(SP)
9D002A84  03A0F021   ADDU S8, SP, ZERO
9D002A88  AFC40020   SW A0, 32(S8)
9D002A8C  00A01821   ADDU V1, A1, ZERO
9D002A90  00C01021   ADDU V0, A2, ZERO
9D002A94  AFC7002C   SW A3, 44(S8)
9D002A98  A3C30024   SB V1, 36(S8)
9D002A9C  A3C20028   SB V0, 40(S8)
511:                     RESULT result = SUCCESS;
9D002AA0  AFC00010   SW ZERO, 16(S8)
512:                 
513:                     // start condition
514:                     if (result == SUCCESS)
9D002AA4  8FC20010   LW V0, 16(S8)
9D002AA8  14400005   BNE V0, ZERO, 0x9D002AC0
9D002AAC  00000000   NOP
515:                         result = i2c_start (bus_id);
9D002AB0  8FC40020   LW A0, 32(S8)
9D002AB4  0F4006CC   JAL i2c_start
9D002AB8  00000000   NOP
9D002ABC  AFC20010   SW V0, 16(S8)
516:                 
517:                     // address of the chip
518:                     if (result == SUCCESS)
9D002AC0  8FC20010   LW V0, 16(S8)
9D002AC4  14400009   BNE V0, ZERO, 0x9D002AEC
9D002AC8  00000000   NOP
519:                         result = i2c_write (bus_id, (adr_chip<<1) & 0xFE);
9D002ACC  93C20024   LBU V0, 36(S8)
9D002AD0  00021040   SLL V0, V0, 1
9D002AD4  304200FF   ANDI V0, V0, 255
9D002AD8  8FC40020   LW A0, 32(S8)
9D002ADC  00402821   ADDU A1, V0, ZERO
9D002AE0  0F400961   JAL i2c_write
9D002AE4  00000000   NOP
9D002AE8  AFC20010   SW V0, 16(S8)
520:                 
521:                     // address of the register
522:                     if (result == SUCCESS)
9D002AEC  8FC20010   LW V0, 16(S8)
9D002AF0  14400007   BNE V0, ZERO, 0x9D002B10
9D002AF4  00000000   NOP
523:                         result = i2c_write (bus_id, adr_reg);
9D002AF8  93C20028   LBU V0, 40(S8)
9D002AFC  8FC40020   LW A0, 32(S8)
9D002B00  00402821   ADDU A1, V0, ZERO
9D002B04  0F400961   JAL i2c_write
9D002B08  00000000   NOP
9D002B0C  AFC20010   SW V0, 16(S8)
524:                 
525:                     // repeated-start condition
526:                     if (result == SUCCESS)
9D002B10  8FC20010   LW V0, 16(S8)
9D002B14  14400005   BNE V0, ZERO, 0x9D002B2C
9D002B18  00000000   NOP
527:                         result = i2c_rstart (bus_id);
9D002B1C  8FC40020   LW A0, 32(S8)
9D002B20  0F400713   JAL i2c_rstart
9D002B24  00000000   NOP
9D002B28  AFC20010   SW V0, 16(S8)
528:                 
529:                     // next operation is a reading
530:                     if (result == SUCCESS)
9D002B2C  8FC20010   LW V0, 16(S8)
9D002B30  1440000C   BNE V0, ZERO, 0x9D002B64
9D002B34  00000000   NOP
531:                         result = i2c_write (bus_id, (adr_chip<<1) | 0x01);
9D002B38  93C20024   LBU V0, 36(S8)
9D002B3C  00021040   SLL V0, V0, 1
9D002B40  7C021420   SEB V0, V0
9D002B44  34420001   ORI V0, V0, 1
9D002B48  7C021420   SEB V0, V0
9D002B4C  304200FF   ANDI V0, V0, 255
9D002B50  8FC40020   LW A0, 32(S8)
9D002B54  00402821   ADDU A1, V0, ZERO
9D002B58  0F400961   JAL i2c_write
9D002B5C  00000000   NOP
9D002B60  AFC20010   SW V0, 16(S8)
532:                 
533:                     // read data
534:                     if (result == SUCCESS)
9D002B64  8FC20010   LW V0, 16(S8)
9D002B68  14400007   BNE V0, ZERO, 0x9D002B88
9D002B6C  00000000   NOP
535:                         result = i2c_read (bus_id, data, NACK);
9D002B70  8FC40020   LW A0, 32(S8)
9D002B74  8FC5002C   LW A1, 44(S8)
9D002B78  00003021   ADDU A2, ZERO, ZERO
9D002B7C  0F4008A0   JAL i2c_read
9D002B80  00000000   NOP
9D002B84  AFC20010   SW V0, 16(S8)
536:                 
537:                     // stop condition
538:                     if (result == SUCCESS)
9D002B88  8FC20010   LW V0, 16(S8)
9D002B8C  14400005   BNE V0, ZERO, 0x9D002BA4
9D002B90  00000000   NOP
539:                         result = i2c_stop (bus_id);
9D002B94  8FC40020   LW A0, 32(S8)
9D002B98  0F40075A   JAL i2c_stop
9D002B9C  00000000   NOP
9D002BA0  AFC20010   SW V0, 16(S8)
540:                 
541:                     return result;
9D002BA4  8FC20010   LW V0, 16(S8)
542:                 }
9D002BA8  03C0E821   ADDU SP, S8, ZERO
9D002BAC  8FBF001C   LW RA, 28(SP)
9D002BB0  8FBE0018   LW S8, 24(SP)
9D002BB4  27BD0020   ADDIU SP, SP, 32
9D002BB8  03E00008   JR RA
9D002BBC  00000000   NOP
543:                 
544:                 
545:                 
546:                 
547:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
548:                 //----------------------- Write in a register of a chip -----------------------
549:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
550:                 RESULT i2c_write_reg(I2C_BUS bus_id, u8 adr_chip, u8 adr_reg, u8 data)
551:                 {
9D002BC0  27BDFFE0   ADDIU SP, SP, -32
9D002BC4  AFBF001C   SW RA, 28(SP)
9D002BC8  AFBE0018   SW S8, 24(SP)
9D002BCC  03A0F021   ADDU S8, SP, ZERO
9D002BD0  AFC40020   SW A0, 32(S8)
9D002BD4  00A02021   ADDU A0, A1, ZERO
9D002BD8  00C01821   ADDU V1, A2, ZERO
9D002BDC  00E01021   ADDU V0, A3, ZERO
9D002BE0  A3C40024   SB A0, 36(S8)
9D002BE4  A3C30028   SB V1, 40(S8)
9D002BE8  A3C2002C   SB V0, 44(S8)
552:                     RESULT result = SUCCESS;
9D002BEC  AFC00010   SW ZERO, 16(S8)
553:                 
554:                     // start condition
555:                     if (result == SUCCESS)
9D002BF0  8FC20010   LW V0, 16(S8)
9D002BF4  14400005   BNE V0, ZERO, 0x9D002C0C
9D002BF8  00000000   NOP
556:                         result = i2c_start (bus_id);
9D002BFC  8FC40020   LW A0, 32(S8)
9D002C00  0F4006CC   JAL i2c_start
9D002C04  00000000   NOP
9D002C08  AFC20010   SW V0, 16(S8)
557:                 
558:                     // address of the chip
559:                     if (result == SUCCESS)
9D002C0C  8FC20010   LW V0, 16(S8)
9D002C10  14400009   BNE V0, ZERO, 0x9D002C38
9D002C14  00000000   NOP
560:                         result = i2c_write (bus_id, (adr_chip<<1) & 0xFE);
9D002C18  93C20024   LBU V0, 36(S8)
9D002C1C  00021040   SLL V0, V0, 1
9D002C20  304200FF   ANDI V0, V0, 255
9D002C24  8FC40020   LW A0, 32(S8)
9D002C28  00402821   ADDU A1, V0, ZERO
9D002C2C  0F400961   JAL i2c_write
9D002C30  00000000   NOP
9D002C34  AFC20010   SW V0, 16(S8)
561:                 
562:                     // address of the register
563:                     if (result == SUCCESS)
9D002C38  8FC20010   LW V0, 16(S8)
9D002C3C  14400007   BNE V0, ZERO, 0x9D002C5C
9D002C40  00000000   NOP
564:                         result = i2c_write (bus_id, adr_reg);
9D002C44  93C20028   LBU V0, 40(S8)
9D002C48  8FC40020   LW A0, 32(S8)
9D002C4C  00402821   ADDU A1, V0, ZERO
9D002C50  0F400961   JAL i2c_write
9D002C54  00000000   NOP
9D002C58  AFC20010   SW V0, 16(S8)
565:                 
566:                     // data to write
567:                     if (result == SUCCESS)
9D002C5C  8FC20010   LW V0, 16(S8)
9D002C60  14400007   BNE V0, ZERO, 0x9D002C80
9D002C64  00000000   NOP
568:                         result = i2c_write (bus_id, data);
9D002C68  93C2002C   LBU V0, 44(S8)
9D002C6C  8FC40020   LW A0, 32(S8)
9D002C70  00402821   ADDU A1, V0, ZERO
9D002C74  0F400961   JAL i2c_write
9D002C78  00000000   NOP
9D002C7C  AFC20010   SW V0, 16(S8)
569:                 
570:                     // stop condition
571:                     if (result == SUCCESS)
9D002C80  8FC20010   LW V0, 16(S8)
9D002C84  14400005   BNE V0, ZERO, 0x9D002C9C
9D002C88  00000000   NOP
572:                         result = i2c_stop (bus_id);
9D002C8C  8FC40020   LW A0, 32(S8)
9D002C90  0F40075A   JAL i2c_stop
9D002C94  00000000   NOP
9D002C98  AFC20010   SW V0, 16(S8)
573:                 
574:                     return result;
9D002C9C  8FC20010   LW V0, 16(S8)
575:                 }
9D002CA0  03C0E821   ADDU SP, S8, ZERO
9D002CA4  8FBF001C   LW RA, 28(SP)
9D002CA8  8FBE0018   LW S8, 24(SP)
9D002CAC  27BD0020   ADDIU SP, SP, 32
9D002CB0  03E00008   JR RA
9D002CB4  00000000   NOP
9D002CB8  27BDFF98   ADDIU SP, SP, -104
9D002CBC  AFBF0064   SW RA, 100(SP)
9D002CC0  AFBE0060   SW S8, 96(SP)
9D002CC4  03A0F021   ADDU S8, SP, ZERO
---  d:/svn/mgw-ace-enc/trunk/pic32/delays.c  -----------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Project     :   MGW-ACE                                             &&&
3:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
4:                   //&&&   Company     :   VITEC                                               &&&
5:                   //&&&   Date        :   04 November 2013                                    &&&
6:                   //&&&   Version     :   v1.0                                                &&&
7:                   //&&&   File        :   delays.c                                            &&&
8:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9:                   //&&&   Description :   - µs & ms delays                                    &&&
10:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:                  
12:                  #include "delays.h"
13:                  #include "hardware_profile.h"
14:                  
15:                  
16:                  void delay_us (unsigned int usec)
17:                  {
9D0085D4  27BDFFF0   ADDIU SP, SP, -16
9D0085D8  AFBE000C   SW S8, 12(SP)
9D0085DC  03A0F021   ADDU S8, SP, ZERO
9D0085E0  AFC40010   SW A0, 16(S8)
18:                      unsigned int i;
19:                      for (i=(usec*3); i!=0; i--);        // @ 80 MHz
9D0085E4  8FC30010   LW V1, 16(S8)
9D0085E8  00601021   ADDU V0, V1, ZERO
9D0085EC  00021040   SLL V0, V0, 1
9D0085F0  00431021   ADDU V0, V0, V1
9D0085F4  AFC20000   SW V0, 0(S8)
9D0085F8  0B402183   J 0x9D00860C
9D0085FC  00000000   NOP
9D008600  8FC20000   LW V0, 0(S8)
9D008604  2442FFFF   ADDIU V0, V0, -1
9D008608  AFC20000   SW V0, 0(S8)
9D00860C  8FC20000   LW V0, 0(S8)
9D008610  1440FFFB   BNE V0, ZERO, 0x9D008600
9D008614  00000000   NOP
20:                  }
9D008618  03C0E821   ADDU SP, S8, ZERO
9D00861C  8FBE000C   LW S8, 12(SP)
9D008620  27BD0010   ADDIU SP, SP, 16
9D008624  03E00008   JR RA
9D008628  00000000   NOP
21:                  
22:                  void delay_ms (unsigned int msec)
23:                  {
9D00862C  27BDFFE0   ADDIU SP, SP, -32
9D008630  AFBF001C   SW RA, 28(SP)
9D008634  AFBE0018   SW S8, 24(SP)
9D008638  03A0F021   ADDU S8, SP, ZERO
9D00863C  AFC40020   SW A0, 32(S8)
24:                      unsigned int tWait, tStart;
25:                      tWait = (GetSystemClock()/2000)*msec;
9D008640  8FC40020   LW A0, 32(S8)
9D008644  00801821   ADDU V1, A0, ZERO
9D008648  00031080   SLL V0, V1, 2
9D00864C  00401821   ADDU V1, V0, ZERO
9D008650  00031140   SLL V0, V1, 5
9D008654  00431023   SUBU V0, V0, V1
9D008658  00441021   ADDU V0, V0, A0
9D00865C  00021880   SLL V1, V0, 2
9D008660  00431021   ADDU V0, V0, V1
9D008664  00021100   SLL V0, V0, 4
9D008668  AFC20010   SW V0, 16(S8)
26:                      tStart = ReadCoreTimer();
9D00866C  0F402375   JAL ReadCoreTimer
9D008670  00000000   NOP
9D008674  AFC20014   SW V0, 20(S8)
27:                      while((ReadCoreTimer()-tStart)<tWait);  // wait for the time to pass
9D008678  00000000   NOP
9D00867C  0F402375   JAL ReadCoreTimer
9D008680  00000000   NOP
9D008684  00401821   ADDU V1, V0, ZERO
9D008688  8FC20014   LW V0, 20(S8)
9D00868C  00621823   SUBU V1, V1, V0
9D008690  8FC20010   LW V0, 16(S8)
9D008694  0062102B   SLTU V0, V1, V0
9D008698  1440FFF8   BNE V0, ZERO, 0x9D00867C
9D00869C  00000000   NOP
28:                  }
9D0086A0  03C0E821   ADDU SP, S8, ZERO
9D0086A4  8FBF001C   LW RA, 28(SP)
9D0086A8  8FBE0018   LW S8, 24(SP)
9D0086AC  27BD0020   ADDIU SP, SP, 32
9D0086B0  03E00008   JR RA
9D0086B4  00000000   NOP
9D0086B8  27BDFFA8   ADDIU SP, SP, -88
29:                  
---  d:/svn/mgw-ace-enc/trunk/pic32/common.c  -----------------------------------------------------------
1:                   #include "hardware_profile.h"
2:                   
3:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
4:                   //------------------------------ Software Reset -------------------------------
5:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
6:                   void soft_reset(void)
7:                   {
9D008B34  27BDFFF0   ADDIU SP, SP, -16
9D008B38  AFBE000C   SW S8, 12(SP)
9D008B3C  03A0F021   ADDU S8, SP, ZERO
8:                       /* The following code illustrates a software Reset */
9:                       // assume interrupts are disabled
10:                      // assume the DMA controller is suspended
11:                      // assume the device is locked
12:                      /* perform a system unlock sequence */
13:                      // starting critical sequence
14:                      SYSKEY = 0x00000000; //write invalid key to force lock
9D008B40  3C02BF81   LUI V0, -16511
9D008B44  AC40F230   SW ZERO, -3536(V0)
15:                      SYSKEY = 0xAA996655; //write key1 to SYSKEY
9D008B48  3C02BF81   LUI V0, -16511
9D008B4C  3C03AA99   LUI V1, -21863
9D008B50  34636655   ORI V1, V1, 26197
9D008B54  AC43F230   SW V1, -3536(V0)
16:                      SYSKEY = 0x556699AA; //write key2 to SYSKEY
9D008B58  3C02BF81   LUI V0, -16511
9D008B5C  3C035566   LUI V1, 21862
9D008B60  346399AA   ORI V1, V1, -26198
9D008B64  AC43F230   SW V1, -3536(V0)
17:                  
18:                      // OSCCON is now unlocked
19:                      /* set SWRST bit to arm reset */
20:                      RSWRSTSET = 1;
9D008B68  3C02BF81   LUI V0, -16511
9D008B6C  24030001   ADDIU V1, ZERO, 1
9D008B70  AC43F618   SW V1, -2536(V0)
21:                  
22:                      /* read RSWRST register to trigger reset */
23:                      unsigned int dummy;
24:                      dummy = RSWRST;
9D008B74  3C02BF81   LUI V0, -16511
9D008B78  8C42F610   LW V0, -2544(V0)
9D008B7C  AFC20000   SW V0, 0(S8)
25:                  
26:                      /* prevent any unwanted code execution until reset occurs*/
27:                      while(1);
9D008B80  0B4022E0   J 0x9D008B80
9D008B84  00000000   NOP
9D008B88  27BDFFE8   ADDIU SP, SP, -24
28:                  }
---  d:/svn/mgw-ace-enc/trunk/pic32/adc.c  --------------------------------------------------------------
1:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
2:                   //&&&   Author      :   Pierre BLACHÉ                                       &&&
3:                   //&&&   Version     :   v1.1                                                &&&
4:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
5:                   //&&&   Description :   - 10 bits analogue to digital conversion            &&&
6:                   //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
7:                   //&&&   Versions    :                                                       &&&
8:                   //&&&   1.0 - 2014/06/14 - PBL - First release                              &&&
9:                   //&&&   1.1 - 2016/08/22 - PBL - Made module independant of Microchip's Lib &&&
10:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
11:                  
12:                  #include "adc.h"
13:                  
14:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
15:                  //-------------------------------- Init ADC -----------------------------------
16:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
17:                  RESULT adc_init ()
18:                  {
9D0071B4  27BDFFF8   ADDIU SP, SP, -8
19:                      // ensure the ADC is off before setting the configuration
20:                      AD1CON1bits.ON = 0;
9D0071C0  3C03BF81   LUI V1, -16511
9D0071C4  94629000   LHU V0, -28672(V1)
9D0071C8  7C027BC4   INS V0, ZERO, 15, 1
9D0071CC  A4629000   SH V0, -28672(V1)
21:                  
22:                      AD1CHSbits.CH0SA = 0;
9D0071D0  3C03BF81   LUI V1, -16511
9D0071D4  8C629040   LW V0, -28608(V1)
9D0071D8  7C029C04   INS V0, ZERO, 16, 4
9D0071DC  AC629040   SW V0, -28608(V1)
23:                      AD1CHSbits.CH0NA = 0;
9D0071E0  3C03BF81   LUI V1, -16511
9D0071E4  8C629040   LW V0, -28608(V1)
9D0071E8  7C02BDC4   INS V0, ZERO, 23, 1
9D0071EC  AC629040   SW V0, -28608(V1)
24:                      AD1CHSbits.CH0SB = 0;
9D0071F0  3C03BF81   LUI V1, -16511
9D0071F4  8C629040   LW V0, -28608(V1)
9D0071F8  7C02DE04   INS V0, ZERO, 24, 4
9D0071FC  AC629040   SW V0, -28608(V1)
25:                      AD1CHSbits.CH0NB = 0;
9D007200  3C03BF81   LUI V1, -16511
9D007204  8C629040   LW V0, -28608(V1)
9D007208  7C02FFC4   INS V0, ZERO, 31, 1
9D00720C  AC629040   SW V0, -28608(V1)
26:                  
27:                      // config scanning
28:                      #if defined (_PCB1_) || defined (_PCB2_)
29:                      AD1CSSL = ~(ADC_SKIP_SCAN_AN0 | ADC_SKIP_SCAN_AN1 | ADC_SKIP_SCAN_AN3 | ADC_SKIP_SCAN_AN4 | ADC_SKIP_SCAN_AN5 | ADC_SKIP_SCAN_AN6 | ADC_SKIP_SCAN_AN7 | ADC_SKIP_SCAN_AN8 |ADC_SKIP_SCAN_AN9 | ADC_SKIP_SCAN_AN10 | ADC_SKIP_SCAN_AN11 | ADC_SKIP_SCAN_AN12 | ADC_SKIP_SCAN_AN13 | ADC_SKIP_SCAN_AN14 | ADC_SKIP_SCAN_AN15);
30:                      #elif  defined (_PCB3_) || defined (_PCB4_)
31:                      AD1CSSL = ~(ADC_SKIP_SCAN_AN0 | ADC_SKIP_SCAN_AN1 | ADC_SKIP_SCAN_AN3 | ADC_SKIP_SCAN_AN4 | ADC_SKIP_SCAN_AN6 | ADC_SKIP_SCAN_AN7 | ADC_SKIP_SCAN_AN9 | ADC_SKIP_SCAN_AN10 | ADC_SKIP_SCAN_AN11 | ADC_SKIP_SCAN_AN12 | ADC_SKIP_SCAN_AN13 | ADC_SKIP_SCAN_AN14 | ADC_SKIP_SCAN_AN15);
32:                      #elif  defined (_PCB5_)
33:                      AD1CSSL = ~(ADC_SKIP_SCAN_AN0 | ADC_SKIP_SCAN_AN1 | ADC_SKIP_SCAN_AN11 | ADC_SKIP_SCAN_AN12 | ADC_SKIP_SCAN_AN13 | ADC_SKIP_SCAN_AN14 | ADC_SKIP_SCAN_AN15);
9D007210  3C02BF81   LUI V0, -16511
9D007214  3C03FFFF   LUI V1, -1
9D007218  346307FC   ORI V1, V1, 2044
9D00721C  AC439050   SW V1, -28592(V0)
34:                      #endif
35:                  
36:                      // config conversion clock
37:                      AD1CON3bits.ADRC = MY_ADC_CONV_CLK_INTERNAL_RC;
9D007220  3C03BF81   LUI V1, -16511
9D007224  94629020   LHU V0, -28640(V1)
9D007228  24040001   ADDIU A0, ZERO, 1
9D00722C  7C827BC4   INS V0, A0, 15, 1
9D007230  A4629020   SH V0, -28640(V1)
38:                  
39:                      // config Auto-sample time
40:                      AD1CON3bits.SAMC = 15;  // TaD
9D007234  3C03BF81   LUI V1, -16511
9D007238  94629020   LHU V0, -28640(V1)
9D00723C  2404000F   ADDIU A0, ZERO, 15
9D007240  7C826204   INS V0, A0, 8, 5
9D007244  A4629020   SH V0, -28640(V1)
41:                  
42:                      // Alternate Input Sample Mode Select bit
43:                      AD1CON2bits.ALTS = 0;
9D007248  3C03BF81   LUI V1, -16511
9D00724C  94629010   LHU V0, -28656(V1)
9D007250  7C020004   INS V0, ZERO, 0, 1
9D007254  A4629010   SH V0, -28656(V1)
44:                  
45:                      // ADC Result Buffer Mode Select bit
46:                      AD1CON2bits.BUFM = 0;
9D007258  3C03BF81   LUI V1, -16511
9D00725C  94629010   LHU V0, -28656(V1)
9D007260  7C020844   INS V0, ZERO, 1, 1
9D007264  A4629010   SH V0, -28656(V1)
47:                  
48:                      // Sample/Convert Sequences Per Interrupt Selection bits
49:                      AD1CON2bits.SMPI = ADC_NB_USED - 1;
9D007268  3C03BF81   LUI V1, -16511
9D00726C  94629010   LHU V0, -28656(V1)
9D007270  24040008   ADDIU A0, ZERO, 8
9D007274  7C822884   INS V0, A0, 2, 4
9D007278  A4629010   SH V0, -28656(V1)
50:                  
51:                      // Buffer Fill Status bit
52:                      AD1CON2bits.BUFS = 0;
9D00727C  3C03BF81   LUI V1, -16511
9D007280  94629010   LHU V0, -28656(V1)
9D007284  7C0239C4   INS V0, ZERO, 7, 1
9D007288  A4629010   SH V0, -28656(V1)
53:                  
54:                      // Scan Input Selections for CH0+ SHA Input for MUX A Input Multiplexer Setting bit
55:                      AD1CON2bits.CSCNA = 1;
9D00728C  3C03BF81   LUI V1, -16511
9D007290  94629010   LHU V0, -28656(V1)
9D007294  24040001   ADDIU A0, ZERO, 1
9D007298  7C825284   INS V0, A0, 10, 1
9D00729C  A4629010   SH V0, -28656(V1)
56:                  
57:                      // Voltage Reference Configuration bits
58:                      AD1CON2bits.VCFG = 0;   // AVDD & AVSS
9D0072A0  3C03BF81   LUI V1, -16511
9D0072A4  94629010   LHU V0, -28656(V1)
9D0072A8  7C027B44   INS V0, ZERO, 13, 3
9D0072AC  A4629010   SH V0, -28656(V1)
59:                  
60:                      // Data Output Format bits
61:                      AD1CON1bits.FORM = MY_ADC_FORMAT_INTG16;
9D0072B0  3C03BF81   LUI V1, -16511
9D0072B4  94629000   LHU V0, -28672(V1)
9D0072B8  7C025204   INS V0, ZERO, 8, 3
9D0072BC  A4629000   SH V0, -28672(V1)
62:                  
63:                      // ADC Sample Auto-Start bit
64:                      AD1CON1bits.ASAM = 1;
9D0072C0  3C03BF81   LUI V1, -16511
9D0072C4  94629000   LHU V0, -28672(V1)
9D0072C8  24040001   ADDIU A0, ZERO, 1
9D0072CC  7C821084   INS V0, A0, 2, 1
9D0072D0  A4629000   SH V0, -28672(V1)
65:                  
66:                      // Conversion Trigger Source Select bits
67:                      AD1CON1bits.SSRC = MY_ADC_CLK_AUTO;
9D0072D4  3C03BF81   LUI V1, -16511
9D0072D8  94629000   LHU V0, -28672(V1)
9D0072DC  24040007   ADDIU A0, ZERO, 7
9D0072E0  7C823944   INS V0, A0, 5, 3
9D0072E4  A4629000   SH V0, -28672(V1)
68:                  
69:                      // Now enable the ADC logic
70:                      AD1CON1bits.ON = 1;
9D0072E8  3C03BF81   LUI V1, -16511
9D0072EC  94629000   LHU V0, -28672(V1)
9D0072F0  24040001   ADDIU A0, ZERO, 1
9D0072F4  7C827BC4   INS V0, A0, 15, 1
9D0072F8  A4629000   SH V0, -28672(V1)
71:                  
72:                      return SUCCESS;
9D0072FC  00001021   ADDU V0, ZERO, ZERO
73:                  }
9D007300  03C0E821   ADDU SP, S8, ZERO
9D007304  8FBE0004   LW S8, 4(SP)
9D007308  27BD0008   ADDIU SP, SP, 8
9D00730C  03E00008   JR RA
9D007310  00000000   NOP
74:                  
75:                  
76:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
77:                  //---------------------------- Start AD Conversion ----------------------------
78:                  //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
79:                  RESULT adc_conversion(u32 *data, ADC_CH ch)
80:                  {
9D007314  27BDFFF8   ADDIU SP, SP, -8
9D007318  AFBE0004   SW S8, 4(SP)
9D00731C  03A0F021   ADDU S8, SP, ZERO
9D007320  AFC40008   SW A0, 8(S8)
9D007324  AFC5000C   SW A1, 12(S8)
81:                      // read power in voltage
82:                      while ( !IFS1bits.AD1IF );    // wait for ad conversion to be complete
9D007328  00000000   NOP
9D00732C  3C02BF88   LUI V0, -16504
9D007330  8C421040   LW V0, 4160(V0)
9D007334  30420002   ANDI V0, V0, 2
9D007338  1040FFFC   BEQ V0, ZERO, 0x9D00732C
9D00733C  00000000   NOP
83:                  
84:                  
85:                  #if defined (_PCB1_) || defined (_PCB2_)
86:                      if       (ch == ADC_CH2){
87:                          *data = READ_ADC10(0);
88:                      }else{
89:                          return ERROR;
90:                      }
91:                  
92:                  #elif  defined (_PCB3_) || defined (_PCB4_)
93:                      if       (ch == ADC_CH2){
94:                          *data = READ_ADC10(0);
95:                      }else if (ch == ADC_CH5){
96:                          *data = READ_ADC10(1);
97:                      }else if (ch == ADC_CH8){
98:                          *data = READ_ADC10(2);
99:                      }else{
100:                         return ERROR;
101:                     }
102:                 
103:                 #elif  defined (_PCB5_)
104:                     if       (ch == ADC_CH2){
9D007340  8FC3000C   LW V1, 12(S8)
9D007344  24020002   ADDIU V0, ZERO, 2
9D007348  14620007   BNE V1, V0, 0x9D007368
9D00734C  00000000   NOP
105:                         *data = READ_ADC10(0);
9D007350  3C02BF81   LUI V0, -16511
9D007354  8C439070   LW V1, -28560(V0)
9D007358  8FC20008   LW V0, 8(S8)
9D00735C  AC430000   SW V1, 0(V0)
9D007360  0B401D35   J 0x9D0074D4
9D007364  00000000   NOP
106:                     }else if (ch == ADC_CH3){
9D007368  8FC3000C   LW V1, 12(S8)
9D00736C  24020003   ADDIU V0, ZERO, 3
9D007370  14620008   BNE V1, V0, 0x9D007394
9D007374  00000000   NOP
107:                         *data = READ_ADC10(1);
9D007378  3C02BF81   LUI V0, -16511
9D00737C  24429080   ADDIU V0, V0, -28544
9D007380  8C430000   LW V1, 0(V0)
9D007384  8FC20008   LW V0, 8(S8)
9D007388  AC430000   SW V1, 0(V0)
9D00738C  0B401D35   J 0x9D0074D4
9D007390  00000000   NOP
108:                     }else if (ch == ADC_CH4){
9D007394  8FC3000C   LW V1, 12(S8)
9D007398  24020004   ADDIU V0, ZERO, 4
9D00739C  14620008   BNE V1, V0, 0x9D0073C0
9D0073A0  00000000   NOP
109:                         *data = READ_ADC10(2);
9D0073A4  3C02BF81   LUI V0, -16511
9D0073A8  24429090   ADDIU V0, V0, -28528
9D0073AC  8C430000   LW V1, 0(V0)
9D0073B0  8FC20008   LW V0, 8(S8)
9D0073B4  AC430000   SW V1, 0(V0)
9D0073B8  0B401D35   J 0x9D0074D4
9D0073BC  00000000   NOP
110:                     }else if (ch == ADC_CH5){
9D0073C0  8FC3000C   LW V1, 12(S8)
9D0073C4  24020005   ADDIU V0, ZERO, 5
9D0073C8  14620008   BNE V1, V0, 0x9D0073EC
9D0073CC  00000000   NOP
111:                         *data = READ_ADC10(3);
9D0073D0  3C02BF81   LUI V0, -16511
9D0073D4  244290A0   ADDIU V0, V0, -28512
9D0073D8  8C430000   LW V1, 0(V0)
9D0073DC  8FC20008   LW V0, 8(S8)
9D0073E0  AC430000   SW V1, 0(V0)
9D0073E4  0B401D35   J 0x9D0074D4
9D0073E8  00000000   NOP
112:                     }else if (ch == ADC_CH6){
9D0073EC  8FC3000C   LW V1, 12(S8)
9D0073F0  24020006   ADDIU V0, ZERO, 6
9D0073F4  14620008   BNE V1, V0, 0x9D007418
9D0073F8  00000000   NOP
113:                         *data = READ_ADC10(4);
9D0073FC  3C02BF81   LUI V0, -16511
9D007400  244290B0   ADDIU V0, V0, -28496
9D007404  8C430000   LW V1, 0(V0)
9D007408  8FC20008   LW V0, 8(S8)
9D00740C  AC430000   SW V1, 0(V0)
9D007410  0B401D35   J 0x9D0074D4
9D007414  00000000   NOP
114:                     }else if (ch == ADC_CH7){
9D007418  8FC3000C   LW V1, 12(S8)
9D00741C  24020007   ADDIU V0, ZERO, 7
9D007420  14620008   BNE V1, V0, 0x9D007444
9D007424  00000000   NOP
115:                         *data = READ_ADC10(5);
9D007428  3C02BF81   LUI V0, -16511
9D00742C  244290C0   ADDIU V0, V0, -28480
9D007430  8C430000   LW V1, 0(V0)
9D007434  8FC20008   LW V0, 8(S8)
9D007438  AC430000   SW V1, 0(V0)
9D00743C  0B401D35   J 0x9D0074D4
9D007440  00000000   NOP
116:                     }else if (ch == ADC_CH8){
9D007444  8FC3000C   LW V1, 12(S8)
9D007448  24020008   ADDIU V0, ZERO, 8
9D00744C  14620008   BNE V1, V0, 0x9D007470
9D007450  00000000   NOP
117:                         *data = READ_ADC10(6);
9D007454  3C02BF81   LUI V0, -16511
9D007458  244290D0   ADDIU V0, V0, -28464
9D00745C  8C430000   LW V1, 0(V0)
9D007460  8FC20008   LW V0, 8(S8)
9D007464  AC430000   SW V1, 0(V0)
9D007468  0B401D35   J 0x9D0074D4
9D00746C  00000000   NOP
118:                     }else if (ch == ADC_CH9){
9D007470  8FC3000C   LW V1, 12(S8)
9D007474  24020009   ADDIU V0, ZERO, 9
9D007478  14620008   BNE V1, V0, 0x9D00749C
9D00747C  00000000   NOP
119:                         *data = READ_ADC10(7);
9D007480  3C02BF81   LUI V0, -16511
9D007484  244290E0   ADDIU V0, V0, -28448
9D007488  8C430000   LW V1, 0(V0)
9D00748C  8FC20008   LW V0, 8(S8)
9D007490  AC430000   SW V1, 0(V0)
9D007494  0B401D35   J 0x9D0074D4
9D007498  00000000   NOP
120:                     }else if (ch == ADC_CH10){
9D00749C  8FC3000C   LW V1, 12(S8)
9D0074A0  2402000A   ADDIU V0, ZERO, 10
9D0074A4  14620008   BNE V1, V0, 0x9D0074C8
9D0074A8  00000000   NOP
121:                         *data = READ_ADC10(8);
9D0074AC  3C02BF81   LUI V0, -16511
9D0074B0  244290F0   ADDIU V0, V0, -28432
9D0074B4  8C430000   LW V1, 0(V0)
9D0074B8  8FC20008   LW V0, 8(S8)
9D0074BC  AC430000   SW V1, 0(V0)
9D0074C0  0B401D35   J 0x9D0074D4
9D0074C4  00000000   NOP
122:                     }else{
123:                         return ERROR;
9D0074C8  24020001   ADDIU V0, ZERO, 1
9D0074CC  0B401D36   J 0x9D0074D8
9D0074D0  00000000   NOP
124:                     }
125:                 #endif
126:                 
127:                 
128:                     return SUCCESS;
9D0074D4  00001021   ADDU V0, ZERO, ZERO
129:                 }
9D0074D8  03C0E821   ADDU SP, S8, ZERO
9D0074DC  8FBE0004   LW S8, 4(SP)
9D0074E0  27BD0008   ADDIU SP, SP, 8
9D0074E4  03E00008   JR RA
9D0074E8  00000000   NOP
130:                 
131:                 
132:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
133:                 //------------------------- Get Power-in at Start-up --------------------------
134:                 //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
135:                 RESULT get_power_in_at_startup(u32 *power)
136:                 {
9D0074EC  27BDFFD8   ADDIU SP, SP, -40
9D0074F0  AFBF0024   SW RA, 36(SP)
9D0074F4  AFBE0020   SW S8, 32(SP)
9D0074F8  03A0F021   ADDU S8, SP, ZERO
9D0074FC  AFC40028   SW A0, 40(S8)
137:                     u32 tab[4];
138:                 
139:                     // get voltage
140:                     adc_conversion(&tab[0], ADC_CH2);
9D007500  27C20010   ADDIU V0, S8, 16
9D007504  00402021   ADDU A0, V0, ZERO
9D007508  24050002   ADDIU A1, ZERO, 2
9D00750C  0F401CC5   JAL adc_conversion
9D007510  00000000   NOP
141:                     delay_ms (2);
9D007514  24040002   ADDIU A0, ZERO, 2
9D007518  0F40218B   JAL delay_ms
9D00751C  00000000   NOP
142:                     adc_conversion(&tab[1], ADC_CH2);
9D007520  27C20014   ADDIU V0, S8, 20
9D007524  00402021   ADDU A0, V0, ZERO
9D007528  24050002   ADDIU A1, ZERO, 2
9D00752C  0F401CC5   JAL adc_conversion
9D007530  00000000   NOP
143:                     delay_ms (2);
9D007534  24040002   ADDIU A0, ZERO, 2
9D007538  0F40218B   JAL delay_ms
9D00753C  00000000   NOP
144:                     adc_conversion(&tab[2], ADC_CH2);
9D007540  27C20018   ADDIU V0, S8, 24
9D007544  00402021   ADDU A0, V0, ZERO
9D007548  24050002   ADDIU A1, ZERO, 2
9D00754C  0F401CC5   JAL adc_conversion
9D007550  00000000   NOP
145:                     delay_ms (2);
9D007554  24040002   ADDIU A0, ZERO, 2
9D007558  0F40218B   JAL delay_ms
9D00755C  00000000   NOP
146:                     adc_conversion(&tab[3], ADC_CH2);
9D007560  27C2001C   ADDIU V0, S8, 28
9D007564  00402021   ADDU A0, V0, ZERO
9D007568  24050002   ADDIU A1, ZERO, 2
9D00756C  0F401CC5   JAL adc_conversion
9D007570  00000000   NOP
147:                     delay_ms (2);
9D007574  24040002   ADDIU A0, ZERO, 2
9D007578  0F40218B   JAL delay_ms
9D00757C  00000000   NOP
148:                 
149:                     // mean
150:                     *power = (tab[0] + tab[1] + tab[2] + tab[3]) / 4;
9D007580  8FC30010   LW V1, 16(S8)
9D007584  8FC20014   LW V0, 20(S8)
9D007588  00621821   ADDU V1, V1, V0
9D00758C  8FC20018   LW V0, 24(S8)
9D007590  00621821   ADDU V1, V1, V0
9D007594  8FC2001C   LW V0, 28(S8)
9D007598  00621021   ADDU V0, V1, V0
9D00759C  00021882   SRL V1, V0, 2
9D0075A0  8FC20028   LW V0, 40(S8)
9D0075A4  AC430000   SW V1, 0(V0)
151:                 
152:                     return SUCCESS;
9D0075A8  00001021   ADDU V0, ZERO, ZERO
153:                 }
9D0075AC  03C0E821   ADDU SP, S8, ZERO
9D0075B0  8FBF0024   LW RA, 36(SP)
9D0075B4  8FBE0020   LW S8, 32(SP)
9D0075B8  27BD0028   ADDIU SP, SP, 40
9D0075BC  03E00008   JR RA
9D0075C0  00000000   NOP
9D0075C4  27BDFFF8   ADDIU SP, SP, -8
---  c:/microchip/xc32/v1.40/pic32mx/include/peripheral/system.h  ---------------------------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D003018  8FC2002C   LW V0, 44(S8)
9D00301C  AFC20030   SW V0, 48(S8)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D003020  8FC3002C   LW V1, 44(S8)
9D003024  3C0204C4   LUI V0, 1220
9D003028  3442B401   ORI V0, V0, -19455
9D00302C  0062102B   SLTU V0, V1, V0
9D003030  14400008   BNE V0, ZERO, 0x9D003054
9D003034  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D003038  3C020008   LUI V0, 8
9D00303C  AFC20034   SW V0, 52(S8)
131:                         pb_clock >>= 1;
9D003040  8FC20030   LW V0, 48(S8)
9D003044  00021042   SRL V0, V0, 1
9D003048  AFC20030   SW V0, 48(S8)
9D00304C  0B400C16   J 0x9D003058
9D003050  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D003054  AFC00034   SW ZERO, 52(S8)
9D003058  8FC20034   LW V0, 52(S8)
9D00305C  AFC20038   SW V0, 56(S8)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
9D002F98  AFC00024   SW ZERO, 36(S8)
9D002F9C  0B400BF1   J 0x9D002FC4
9D002FA0  00000000   NOP
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
9D002FC4  8FC30020   LW V1, 32(S8)
9D002FC8  3C0201C9   LUI V0, 457
9D002FCC  3442C381   ORI V0, V0, -15487
9D002FD0  0062102B   SLTU V0, V1, V0
9D002FD4  1040FFF3   BEQ V0, ZERO, 0x9D002FA4
9D002FD8  00000000   NOP
183:                     {
184:                         wait_states++;
9D002FA4  8FC20024   LW V0, 36(S8)
9D002FA8  24420001   ADDIU V0, V0, 1
9D002FAC  AFC20024   SW V0, 36(S8)
185:                         sys_clock -= FLASH_SPEED_HZ;
9D002FB0  8FC30020   LW V1, 32(S8)
9D002FB4  3C02FE36   LUI V0, -458
9D002FB8  34423C80   ORI V0, V0, 15488
9D002FBC  00621021   ADDU V0, V1, V0
9D002FC0  AFC20020   SW V0, 32(S8)
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
9D002FDC  0F402379   JAL INTDisableInterrupts
9D002FE0  00000000   NOP
9D002FE4  AFC20028   SW V0, 40(S8)
189:                     mCheConfigure(wait_states);
9D002FE8  3C02BF88   LUI V0, -16504
9D002FEC  8FC30024   LW V1, 36(S8)
9D002FF0  AC434000   SW V1, 16384(V0)
190:                     INTRestoreInterrupts(int_status);
9D002FF4  8FC40028   LW A0, 40(S8)
9D002FF8  0F402358   JAL INTRestoreInterrupts
9D002FFC  00000000   NOP
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D002F68  0F402379   JAL INTDisableInterrupts
9D002F6C  00000000   NOP
9D002F70  AFC2001C   SW V0, 28(S8)
355:                 
356:                     mBMXDisableDRMWaitState();
9D002F74  3C02BF88   LUI V0, -16504
9D002F78  24030040   ADDIU V1, ZERO, 64
9D002F7C  AC432004   SW V1, 8196(V0)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
9D002F80  8FC20018   LW V0, 24(S8)
9D002F84  30420001   ANDI V0, V0, 1
9D002F88  1040001D   BEQ V0, ZERO, 0x9D003000
9D002F8C  00000000   NOP
9D002F90  8FC20014   LW V0, 20(S8)
9D002F94  AFC20020   SW V0, 32(S8)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
9D003000  8FC20018   LW V0, 24(S8)
9D003004  30420002   ANDI V0, V0, 2
9D003008  10400065   BEQ V0, ZERO, 0x9D0031A0
9D00300C  00000000   NOP
9D003010  8FC20014   LW V0, 20(S8)
9D003014  AFC2002C   SW V0, 44(S8)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
9D0031A0  8FC20018   LW V0, 24(S8)
9D0031A4  30420004   ANDI V0, V0, 4
9D0031A8  1040000C   BEQ V0, ZERO, 0x9D0031DC
9D0031AC  00000000   NOP
371:                     {
372:                         cache_status = mCheGetCon();
9D0031B0  3C02BF88   LUI V0, -16504
9D0031B4  8C424000   LW V0, 16384(V0)
9D0031B8  AFC20050   SW V0, 80(S8)
373:                         cache_status |= CHE_CONF_PF_ALL;
9D0031BC  8FC20050   LW V0, 80(S8)
9D0031C0  34420030   ORI V0, V0, 48
9D0031C4  AFC20050   SW V0, 80(S8)
374:                         mCheConfigure(cache_status);
9D0031C8  3C02BF88   LUI V0, -16504
9D0031CC  8FC30050   LW V1, 80(S8)
9D0031D0  AC434000   SW V1, 16384(V0)
375:                         CheKseg0CacheOn();
9D0031D4  0F402365   JAL CheKseg0CacheOn
9D0031D8  00000000   NOP
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
9D0031DC  8FC20014   LW V0, 20(S8)
9D0031E0  AFC20054   SW V0, 84(S8)
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D0031E4  3C02BF81   LUI V0, -16511
9D0031E8  8C42F000   LW V0, -4096(V0)
9D0031EC  7C420CC0   EXT V0, V0, 19, 2
9D0031F0  304200FF   ANDI V0, V0, 255
9D0031F4  8FC30054   LW V1, 84(S8)
9D0031F8  00431006   SRLV V0, V1, V0
9D0031FC  AFC20054   SW V0, 84(S8)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D003200  8FC4001C   LW A0, 28(S8)
9D003204  0F402358   JAL INTRestoreInterrupts
9D003208  00000000   NOP
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/microchip/xc32/v1.40/pic32mx/include/peripheral/osc.h  ------------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                     // Reference Oscillator Source Select bits - values are mutually exclusive
169:                     #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                     #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                     #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                     #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                     #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                     #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                     #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                     #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                     #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                     typedef enum
180:                     {
181:                             OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                             OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                             OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                             OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                     } OSCREFConfigFlags;
186:                 
187:                     void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                 
190:                     #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
191:                 
192:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
193:                 
194:                 #undef  NEED_OSCREFCONFIG_FLAGS
195:                 
196:                 
197:                 /*********************************************************************
198:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
199:                  *
200:                  * Description: Configures peripheral bus divisor
201:                  *
202:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
203:                  *
204:                  * Inputs:    oscPbDiv - desired PB divider
205:                  *
206:                  * Output:      None
207:                  *
208:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
209:                  *
210:                  ********************************************************************/
211:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
212:                 {
213:                     unsigned int dma_status;
214:                     unsigned int int_status;
215:                     __OSCCONbits_t oscBits;
216:                 
217:                     mSYSTEMUnlock(int_status, dma_status);
9D003060  0F402379   JAL INTDisableInterrupts
9D003064  00000000   NOP
9D003068  AFC2003C   SW V0, 60(S8)
9D0030B0  AFC20044   SW V0, 68(S8)
9D0030B4  3C02BF81   LUI V0, -16511
9D0030B8  AC40F230   SW ZERO, -3536(V0)
9D0030BC  3C02BF81   LUI V0, -16511
9D0030C0  3C03AA99   LUI V1, -21863
9D0030C4  34636655   ORI V1, V1, 26197
9D0030C8  AC43F230   SW V1, -3536(V0)
9D0030CC  3C02BF81   LUI V0, -16511
9D0030D0  3C035566   LUI V1, 21862
9D0030D4  346399AA   ORI V1, V1, -26198
9D0030D8  AC43F230   SW V1, -3536(V0)
218:                 
219:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D0030DC  3C02BF81   LUI V0, -16511
9D0030E0  8C42F000   LW V0, -4096(V0)
9D0030E4  AFC20058   SW V0, 88(S8)
220:                     oscBits.PBDIV=0;
9D0030E8  8FC20058   LW V0, 88(S8)
9D0030EC  7C02A4C4   INS V0, ZERO, 19, 2
9D0030F0  AFC20058   SW V0, 88(S8)
221:                     oscBits.w|=oscPbDiv;
9D0030F4  8FC30058   LW V1, 88(S8)
9D0030F8  8FC20038   LW V0, 56(S8)
9D0030FC  00621025   OR V0, V1, V0
9D003100  AFC20058   SW V0, 88(S8)
222:                     OSCCON=oscBits.w;       // write back
9D003104  8FC30058   LW V1, 88(S8)
9D003108  3C02BF81   LUI V0, -16511
9D00310C  AC43F000   SW V1, -4096(V0)
223:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D003110  3C02BF81   LUI V0, -16511
9D003114  8C42F000   LW V0, -4096(V0)
9D003118  AFC20058   SW V0, 88(S8)
224:                 
225:                     mSYSTEMLock(int_status, dma_status);
9D00311C  3C02BF81   LUI V0, -16511
9D003120  3C033333   LUI V1, 13107
9D003124  34633333   ORI V1, V1, 13107
9D003128  AC43F230   SW V1, -3536(V0)
9D00312C  8FC20044   LW V0, 68(S8)
9D003130  AFC20048   SW V0, 72(S8)
9D003194  8FC4003C   LW A0, 60(S8)
9D003198  0F402358   JAL INTRestoreInterrupts
9D00319C  00000000   NOP
226:                 }
227:                 
228:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
229:                 
230:                 
231:                 
232:                     /******************************************************************************
233:                      * Available options for config parameter
234:                      *****************************************************************************/
235:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
236:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
239:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
240:                     /***********************************
241:                      * End config parameter values
242:                      ************************************/
243:                 
244:                 
245:                 /*********************************************************************
246:                  * Function:    mOSCGetPBDIV()
247:                  *
248:                  * Description: Reads peripheral bus divisor
249:                  *
250:                  * PreCondition:None
251:                  *
252:                  * Inputs:      None
253:                  *
254:                  * Output:      None
255:                  *
256:                  * Example:     mOSCGetPBDIV()
257:                  *
258:                  ********************************************************************/
259:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
260:                 
261:                 
262:                 /*********************************************************************
263:                  * Function:    mOSCClockFailStatus()
264:                  *
265:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
266:                  *
267:                  * PreCondition: None
268:                  *
269:                  * Inputs:      None
270:                  *
271:                  * Output:      None
272:                  *
273:                  * Example:     mOSCClockFailStatus()
274:                  *
275:                  ********************************************************************/
276:                 #define mOSCClockFailStatus (OSCCONbits.CF)
277:                 
278:                 
279:                 /*********************************************************************
280:                  * Function:        mOSCEnableSOSC()
281:                  *
282:                  * Description:     Enables the LPRC
283:                  *
284:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
285:                  *
286:                  * Inputs:          None
287:                  *
288:                  * Output:          None
289:                  *
290:                  * Example:         mOSCEnableSOSC()
291:                  *
292:                  ********************************************************************/
293:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
294:                 
295:                 
296:                 /*********************************************************************
297:                  * Function:        mOSCDisableSOSC(config)
298:                  *
299:                  * Description:     Disables SOSC
300:                  *
301:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
302:                  *
303:                  * Inputs:          None
304:                  *
305:                  * Output:          None
306:                  *
307:                  * Example:         mOSCDisableSOSC()
308:                  *
309:                  ********************************************************************/
310:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
311:                 
312:                 
313:                 
314:                 #endif
---  c:/microchip/xc32/v1.40/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_5XX_6XX__7XX_H_
43:                  #define _DMA_5XX_6XX__7XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      #ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #ifdef _DMAC4
75:                          DMA_CHANNEL4,
76:                      #ifdef _DMAC5
77:                          DMA_CHANNEL5,
78:                      #ifdef _DMAC6
79:                          DMA_CHANNEL6,
80:                      #ifdef _DMAC7
81:                          DMA_CHANNEL7,
82:                      #endif  // _DMAC7
83:                      #endif  // _DMAC6
84:                      #endif  // _DMAC5
85:                      #endif  // _DMAC4
86:                      #endif  // _DMAC3
87:                      #endif  // _DMAC2
88:                      #endif  // _DMAC1
89:                          //  add/remove DMA channel as needed here
90:                  
91:                          DMA_CHANNELS    // number of current available channels
92:                      }DmaChannel;
93:                  
94:                  
95:                      // Relative Dma channels priority, between each other
96:                      typedef enum
97:                      {
98:                          DMA_CHN_PRI0,
99:                          DMA_CHN_PRI1,
100:                         DMA_CHN_PRI2,
101:                         DMA_CHN_PRI3
102:                     }DmaChannelPri;
103:                 
104:                 
105:                 
106:                     // high level definitions for the API functions
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
111:                         DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
112:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
113:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
114:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
115:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
116:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
117:                     }DmaOpenFlags;  // flags for the channel open
118:                 
119:                 
120:                     typedef enum
121:                     {
122:                         DMA_EV_ERR =            0x1,        // address error event
123:                         DMA_EV_ABORT =          0x2,        // transfer abort event
124:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
125:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
126:                         DMA_EV_DST_HALF =       0x10,       // destination half event
127:                         DMA_EV_DST_FULL =       0x20,       // destination full event
128:                         DMA_EV_SRC_HALF =       0x40,       // source half event
129:                         DMA_EV_SRC_FULL =       0x80,       // source full event
130:                 
131:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
133:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                     typedef enum
137:                     {
138:                         DMA_TXFER_OK,           // the transfer was performed successfully
139:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
140:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
141:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
142:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
143:                         DMA_TXFER_TMO           // DMA transfer timeout
144:                     }DmaTxferRes;       // DMA transfer result
145:                 
146:                     typedef enum
147:                     {
148:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
149:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
150:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
151:                     }DmaWaitMode;       // DMA transfer wait mode
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_CHKSUM_CRC,     // LFSR CRC
156:                         DMA_CHKSUM_IP,      // IP Checksum
157:                     }DmaChksumType;     // DMA SFM supported checksum types
158:                 
159:                     typedef enum
160:                     {
161:                         DMA_BITO_MSb,       // MSb first (not reflected)
162:                         DMA_BITO_LSb,       // LSb first (reflected)
163:                     }DmaBitOrder;       // DMA SFM supported bit ordering
164:                 
165:                     typedef enum
166:                     {
167:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
168:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
169:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
170:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
171:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
172:                 
173:                 
174:                     /*********************************************************************
175:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
176:                      *
177:                      * PreCondition:    chPri  - valid channel priority, 0-3
178:                      *
179:                      * Input:           chn    - channel to be configured in the DMA controller
180:                      *                  chPri  - the priority given to the channel, 0-3
181:                      *                  oFlags - orred flags specifying the open mode:
182:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
183:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
184:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
185:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
186:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
187:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
188:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
189:                      *
190:                      *
191:                      *
192:                      * Output:          None
193:                      *
194:                      * Side Effects:    None
195:                      *
196:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
197:                      *
198:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
199:                      *                  Use the low level functions to address special settings.
200:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
201:                      *                  After that the channel is configured.
202:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
203:                      *                  if DMA_OPEN_ENABLE flag was not specified.
204:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
205:                      *                  This way, the transfer will occur correctly together with CRC calculation.
206:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
207:                      *                  User has to call event channel functions to enable the event flags if needed.
208:                      *
209:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
210:                      ********************************************************************/
211:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
212:                 
213:                     /*********************************************************************
214:                      * Function:        void DmaChnEnable(DmaChannel chn)
215:                      *
216:                      * PreCondition:    None
217:                      *
218:                      * Input:           chn     - channel to be enabled
219:                      *
220:                      * Output:          None
221:                      *
222:                      * Side Effects:    None
223:                      *
224:                      * Overview:        The function enables a previously configured DMA channel.
225:                      *
226:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
227:                      *
228:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
229:                      ********************************************************************/
230:                      void           DmaChnEnable(DmaChannel chn);
231:                 
232:                     /*********************************************************************
233:                      * Function:        void DmaChnDisable(DmaChannel chn)
234:                      *
235:                      * PreCondition:    None
236:                      *
237:                      * Input:           chn     - selected channel in the DMA controller
238:                      *
239:                      * Output:          None
240:                      *
241:                      * Side Effects:    None
242:                      *
243:                      * Overview:        The function disables a DMA channel. The channel operation stops.
244:                      *
245:                      * Note:            None.
246:                      *
247:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
248:                      ********************************************************************/
249:                      void           DmaChnDisable(DmaChannel chn);
250:                 
251:                     /*********************************************************************
252:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
253:                      *
254:                      * PreCondition:    chn     - valid DMA channel
255:                      *              - vSrcAdd, vDstAdd  - valid pointers
256:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
257:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
258:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
259:                      *
260:                      * Input:           chn         - DMA channel number
261:                      *                              - vSrcAdd: source of the DMA transfer
262:                      *                              - vDstAdd: destination of the DMA transfer
263:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
264:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
265:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
266:                      *
267:                      * Output:          None
268:                      *
269:                      * Side Effects:    None
270:                      *
271:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
272:                      *                  the source and the destination addresses.
273:                      *                  the source and destination lengths
274:                      *                  and the number of bytes transferred per event.
275:                      *
276:                      * Note:            The function clears the existing DMA channel event flags.
277:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
278:                      *
279:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
280:                      ********************************************************************/
281:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
282:                 
283:                 
284:                     /*********************************************************************
285:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
286:                      *
287:                      * PreCondition:    chn     - valid DMA channel
288:                      *
289:                      * Input:           chn     - DMA channel number
290:                      *              - vSrcAdd: source (virtual) of the DMA transfer
291:                      * Output:          None
292:                      *
293:                      * Side Effects:    None
294:                      *
295:                      * Overview:        The function is a helper to set directly the transfer source address.
296:                      *
297:                      * Note:            None.
298:                      *
299:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
300:                      ********************************************************************/
301:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
302:                 
303:                     /*********************************************************************
304:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
305:                      *
306:                      * PreCondition:    chn     - valid DMA channel
307:                      *
308:                      * Input:           chn         - DMA channel number
309:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
310:                      * Output:          None
311:                      *
312:                      * Side Effects:    None
313:                      *
314:                      * Overview:        The function is a helper to set directly the transfer destination address.
315:                      *
316:                      * Note:            None
317:                      *
318:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
319:                      ********************************************************************/
320:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
321:                 
322:                     /*********************************************************************
323:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
324:                      *
325:                      * PreCondition:    chn - valid DMA channel
326:                      *
327:                      * Input:           chn     - DMA channel number
328:                      *                  pattern -  the match pattern
329:                      *
330:                      * Output:          None
331:                      *
332:                      * Side Effects:    None
333:                      *
334:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
335:                      *
336:                      * Note:            None.
337:                      *
338:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
339:                      ********************************************************************/
340:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
341:                 
342:                     /*********************************************************************
343:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
344:                      *
345:                      * PreCondition:    chn - valid DMA channel
346:                      *
347:                      * Input:           chn     - DMA channel number
348:                      *
349:                      * Output:          The channel match pattern.
350:                      *
351:                      * Side Effects:    None
352:                      *
353:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
354:                      *
355:                      * Note:            None.
356:                      *
357:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
358:                      ********************************************************************/
359:                      int            DmaChnGetMatchPattern(DmaChannel chn);
360:                 
361:                     /*********************************************************************
362:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
363:                      *
364:                      * PreCondition:    chn - valid DMA channel
365:                      *
366:                      * Input:           chn     - DMA channel number
367:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
368:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
369:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
370:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
371:                      *                              If 0, wait forever.
372:                      *
373:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
374:                      *                  an DmaTxferRes error code  otherwise
375:                      *
376:                      * Side Effects:    None
377:                      *
378:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
379:                      *                  The DMA channel is enabled.
380:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
381:                      *                  this event) the function will periodically query the DMA controller for the
382:                      *                  transfer completion status.
383:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
384:                      *                  the block transfer than the function will re-force the transfer for each cell.
385:                      *
386:                      * Note:            This function can not ne used when the DMA channel is triggerred
387:                      *                  by hardware interrupt requests.
388:                      *                  This is because the transfers are software forced, theere is no
389:                      *                  wait for the occurrence of the hardware trigger.
390:                      *
391:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
392:                      ********************************************************************/
393:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
394:                 
395:                     /*********************************************************************
396:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
397:                      *
398:                      * PreCondition:    chn - valid DMA channel
399:                      *
400:                      * Input:           chn     - DMA channel number
401:                      *
402:                      * Output:          None
403:                      *
404:                      * Side Effects:    None
405:                      *
406:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
407:                      *
408:                      * Note:            None.
409:                      *
410:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
411:                      ********************************************************************/
412:                      void           DmaChnForceTxfer(DmaChannel chn);
413:                 
414:                     /*********************************************************************
415:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
416:                      *
417:                      * PreCondition:    chn - valid DMA channel
418:                      *
419:                      * Input:           chn     - DMA channel number
420:                      *
421:                      * Output:          None
422:                      *
423:                      * Side Effects:    None
424:                      *
425:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
426:                      *
427:                      * Note:            None.
428:                      *
429:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
430:                      ********************************************************************/
431:                      void           DmaChnAbortTxfer(DmaChannel chn);
432:                 
433:                     // High level channel event and interrupt control functions
434:                 
435:                     /*********************************************************************
436:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                      *
438:                      * PreCondition:    chn - valid DMA channel
439:                      *
440:                      * Input:           chn     - DMA channel number
441:                      *                  eFlags  - event flags with the following significance:
442:                      *                              - DMA_EV_ERR: address error event
443:                      *                              - DMA_EV_ABORT: transfer abort event
444:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
445:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
446:                      *                              - DMA_EV_DST_HALF: destination half event
447:                      *                              - DMA_EV_DST_FULL: destination full event
448:                      *                              - DMA_EV_SRC_HALF: source half event
449:                      *                              - DMA_EV_SRC_FULL: source full event
450:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
451:                      *
452:                      * Output:          None
453:                      *
454:                      * Side Effects:    None
455:                      *
456:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
457:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
459:                      *
460:                      * Note:            None.
461:                      *
462:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                      ********************************************************************/
464:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                     /*********************************************************************
467:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                      *
469:                      * PreCondition:    chn - valid DMA channel
470:                      *
471:                      * Input:           chn     - DMA channel number
472:                      *                  eFlags  - event flags with the following significance:
473:                      *                              - DMA_EV_ERR: address error event
474:                      *                              - DMA_EV_ABORT: transfer abort event
475:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
476:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
477:                      *                              - DMA_EV_DST_HALF: destination half event
478:                      *                              - DMA_EV_DST_FULL: destination full event
479:                      *                              - DMA_EV_SRC_HALF: source half event
480:                      *                              - DMA_EV_SRC_FULL: source full event
481:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
482:                      *
483:                      * Output:          None
484:                      *
485:                      * Side Effects:    None
486:                      *
487:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
488:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
489:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
490:                      *
491:                      * Note:            None.
492:                      *
493:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
494:                      ********************************************************************/
495:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
496:                 
497:                     /*********************************************************************
498:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
499:                      *
500:                      * PreCondition:    chn - valid DMA channel
501:                      *
502:                      * Input:           chn     - DMA channel number
503:                      *                  eFlags  - event flags with the following significance:
504:                      *                              - DMA_EV_ERR: address error event
505:                      *                              - DMA_EV_ABORT: transfer abort event
506:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
507:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
508:                      *                              - DMA_EV_DST_HALF: destination half event
509:                      *                              - DMA_EV_DST_FULL: destination full event
510:                      *                              - DMA_EV_SRC_HALF: source half event
511:                      *                              - DMA_EV_SRC_FULL: source full event
512:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
513:                      *
514:                      * Output:          None
515:                      *
516:                      * Side Effects:    None
517:                      *
518:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
519:                      *                  The channel event flags are forced to the eFlags value.
520:                      *
521:                      * Note:            None.
522:                      *
523:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
524:                      ********************************************************************/
525:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
526:                 
527:                     /*********************************************************************
528:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
529:                      *
530:                      * PreCondition:    chn - valid DMA channel
531:                      *
532:                      * Input:           chn     - DMA channel number
533:                      *
534:                      * Output:          - event flags with the following significance:
535:                      *                      - DMA_EV_ERR: address error event
536:                      *                      - DMA_EV_ABORT: transfer abort event
537:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
538:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
539:                      *                      - DMA_EV_DST_HALF: destination half event
540:                      *                      - DMA_EV_DST_FULL: destination full event
541:                      *                      - DMA_EV_SRC_HALF: source half event
542:                      *                      - DMA_EV_SRC_FULL: source full event
543:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
544:                      *
545:                      * Side Effects:    None
546:                      *
547:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
548:                      *
549:                      * Note:            None.
550:                      *
551:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
552:                      ********************************************************************/
553:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
554:                 
555:                     /*********************************************************************
556:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
557:                      *
558:                      * PreCondition:    chn - valid DMA channel
559:                      *
560:                      * Input:           chn     - DMA channel number
561:                      *                  eFlags  - event flags with the following significance:
562:                      *                              - DMA_EV_ERR: address error event
563:                      *                              - DMA_EV_ABORT: transfer abort event
564:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
565:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
566:                      *                              - DMA_EV_DST_HALF: destination half event
567:                      *                              - DMA_EV_DST_FULL: destination full event
568:                      *                              - DMA_EV_SRC_HALF: source half event
569:                      *                              - DMA_EV_SRC_FULL: source full event
570:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
571:                      *
572:                      * Output:          None
573:                      *
574:                      * Side Effects:    None
575:                      *
576:                      * Overview:        The function clears the event flags for the selected DMA channel.
577:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
578:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
579:                      *
580:                      * Note:            None.
581:                      *
582:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
583:                      ********************************************************************/
584:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
585:                 
586:                     /*********************************************************************
587:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
588:                      *
589:                      * PreCondition:    chn - valid DMA channel
590:                      *
591:                      * Input:           chn     - DMA channel number
592:                      *
593:                      * Output:          event flags with the following significance:
594:                      *                      - DMA_EV_ERR: address error event
595:                      *                      - DMA_EV_ABORT: transfer abort event
596:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
597:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
598:                      *                      - DMA_EV_DST_HALF: destination half event
599:                      *                      - DMA_EV_DST_FULL: destination full event
600:                      *                      - DMA_EV_SRC_HALF: source half event
601:                      *                      - DMA_EV_SRC_FULL: source full event
602:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
603:                      *
604:                      * Side Effects:    None
605:                      *
606:                      * Overview:        The function returns the event flags for the selected DMA channel.
607:                      *
608:                      * Note:            None.
609:                      *
610:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
611:                      ********************************************************************/
612:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
613:                 
614:                 
615:                     // high level helpers for fast strcpy/memcpy transfers
616:                 
617:                     /*********************************************************************
618:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
619:                      *
620:                      * PreCondition:    chn     - a valid DMA channel
621:                      *                  s1, s2  - valid memory pointers
622:                      *                  n>0, n<=DmaGetMaxTxferSize()
623:                      *
624:                      * Input:           s1      - destination pointer
625:                      *                  s2      - source pointer
626:                      *                  n       - number of bytes to transfer
627:                      *                  chn     - the DMA channel to perform the transfer
628:                      *                  chPri   - the desired channel priority
629:                      *
630:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
631:                      *                  an DmaTxferRes error code  otherwise
632:                      *
633:                      * Side Effects:    None
634:                      *
635:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
636:                      *          Then it copies one block of memory from source to destination.
637:                      *
638:                      *
639:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
640:                      *                    This way, the transfer will occur correctly together with checksum calculation.
641:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
642:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
643:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
644:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
645:                      *
646:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
647:                      ********************************************************************/
648:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
649:                 
650:                     /*********************************************************************
651:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
652:                      *
653:                      * PreCondition:    chn     - a valid DMA channel
654:                      *                  s1, s2  - valid memory pointers
655:                      *
656:                      * Input:           s1      - destination pointer
657:                      *                  s2      - source pointer
658:                      *                  chn     - the DMA channel to perform the transfer
659:                      *                  chPri   - the desired channel priority
660:                      *
661:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
662:                      *                  an DmaTxferRes error code  otherwise
663:                      *
664:                      * Side Effects:    None
665:                      *
666:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
667:                      *          Then it copies one zero terminated string from source to destination.
668:                      *
669:                      *
670:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
671:                      *                    This way, the transfer will occur correctly together with checksum calculation.
672:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
673:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
674:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
675:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
676:                      *
677:                      *
678:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
679:                      *********************************************************************/
680:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
681:                 
682:                     /*********************************************************************
683:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
684:                      *
685:                      * PreCondition:    chn     - a valid DMA channel
686:                      *              - s1, s2    - valid memory pointers
687:                      *                              - 0 < n <= DmaGetMaxTxferSize()
688:                      *
689:                      * Input:           s1      - destination pointer
690:                      *                  s2      - source pointer
691:                      *                  n   - max number of bytes to transfer
692:                      *                  chn     - the DMA channel to perform the transfer
693:                      *                  chPri   - the desired channel priority
694:                      *
695:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
696:                      *                  an DmaTxferRes error code  otherwise
697:                      *
698:                      * Side Effects:    None
699:                      *
700:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
701:                      *          Then it copies one zero terminated string from source to destination.
702:                      *          It copies no more than n characters from s2.
703:                      *
704:                      *
705:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
706:                      *                    This way, the transfer will occur correctly together with checksum calculation.
707:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
709:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
710:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
711:                      *
712:                      *
713:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
714:                      ********************************************************************/
715:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
716:                 
717:                     /*********************************************************************
718:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
719:                      *
720:                      * PreCondition:    chn    - a valid DMA channel
721:                      *                  d, s   - valid memory pointer
722:                      *                  n>0, n<=DmaGetMaxTxferSize()
723:                      *
724:                      * Input:           d     - address where to deposit the result
725:                      *                  s     - source buffer pointer
726:                      *                  n     - number of bytes in the pointer
727:                      *                  chn   - the DMA channel to use
728:                      *                  chPri - the desired channel priority
729:                      *
730:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
731:                      *                  an DmaTxferRes error code  otherwise
732:                      *
733:                      * Side Effects:    None
734:                      *
735:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
736:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
737:                      *
738:                      *
739:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
740:                      *                  - No transfer is done, just the CRC is calculated.
741:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
742:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
743:                      *                  - The checksum type is switched to CRC.
744:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
745:                      *
746:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
747:                      ********************************************************************/
748:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
749:                 
750:                     /*********************************************************************
751:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
752:                      *
753:                      * PreCondition:    chn    - a valid DMA channel
754:                      *                  d, s   - valid memory pointer
755:                      *                  n>0, n<=DmaGetMaxTxferSize()
756:                      *
757:                      * Input:           d     - address where to deposit the result
758:                      *                  s     - source buffer pointer
759:                      *                  n     - number of bytes in the pointer
760:                      *                  chn   - the DMA channel to use
761:                      *                  chPri - the desired channel priority
762:                      *
763:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
764:                      *                  an DmaTxferRes error code  otherwise
765:                      *
766:                      * Side Effects:    None
767:                      *
768:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
769:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
770:                      *
771:                      *
772:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
773:                      *                  - No transfer is done, just the checksum is calculated.
774:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
775:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
776:                      *                  - The checksum type is switched to IP checksum.
777:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
778:                      *
779:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
780:                      ********************************************************************/
781:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
782:                 
783:                     // High level Special Function Module (SFM) functions
784:                 
785:                     /*********************************************************************
786:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                      *
788:                      * PreCondition:    cType, bitO, rMode - valid values
789:                      *
790:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
791:                      *                  bitO  - the bit order to be used MSb or LSb first
792:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
793:                      *
794:                      * Output:          None
795:                      *
796:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
797:                      *
798:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
799:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
800:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
801:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
802:                      *                      All these values affect the way the checksum is calculated.
803:                      *
804:                      * Note:            None
805:                      *
806:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
807:                      ********************************************************************/
808:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
809:                     {
810:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
811:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
812:                     }
813:                 
814:                     /*********************************************************************
815:                      * Function:        void DmaSfmTxferReorder(int enable)
816:                      *
817:                      * PreCondition:    None
818:                      *
819:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
820:                      *
821:                      * Output:          None
822:                      *
823:                      * Side Effects:    None
824:                      *
825:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
826:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
827:                      *                  Otherwise the data is written to the destination un-modified.
828:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
829:                      *
830:                      *
831:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
832:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
833:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
834:                      *                    Un-aligned transfers are not supported (undefined behavior)!
835:                      *
836:                      * Example:         DmaSfmTxferReorder();
837:                      ********************************************************************/
838:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
839:                     {
840:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
841:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
842:                     }
843:                 
844:                 
845:                      /*********************************************************************
846:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
847:                      *
848:                      * PreCondition:    pLen   - valid polynomial length within 1-32
849:                      *
850:                      * Input:           polynomial  - the layout of the CRC generator
851:                      *                  pLen        - the length of the CRC generator polynomial
852:                      *                  seed        - the initial seed of the CRC generator
853:                      *
854:                      * Output:          None
855:                      *
856:                      * Side Effects:    None
857:                      *
858:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
859:                      *                  - the length of the CRC generator polynomial, pLen;
860:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
861:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
862:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
863:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
864:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
865:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
866:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
867:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
868:                      *
869:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
870:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
871:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
872:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
873:                      *                    the CrcResult() function.
874:                      *                  - The CRC module should be configured before enabled.
875:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
876:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
877:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
878:                      *
879:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
880:                      ********************************************************************/
881:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
882:                     {
883:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
884:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
885:                         DCRCDATA=seed;
886:                         DCRCXOR=polynomial;
887:                     }
888:                 
889:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
890:                 
891:                 
892:                     /*********************************************************************
893:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
894:                      *
895:                      * PreCondition:    chn    - valid DMA channel
896:                      *
897:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
898:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
899:                      *                                but it's written to the destination address when the block transfer is complete.
900:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
901:                      *                                The checksum will be available using the DmaSfmChecksum function.
902:                      *
903:                      * Output:          None
904:                      *
905:                      * Side Effects:    None
906:                      *
907:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
908:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
909:                      *                  is complete, the checksum result is available in the checksum data register.
910:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
911:                 
912:                      *
913:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
914:                      *
915:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
916:                      ********************************************************************/
917:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
918:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
919:                 
920:                     /*********************************************************************
921:                      * Function:        unsigned int DmaSfmChecksum(void)
922:                      *
923:                      * PreCondition:    None
924:                      *
925:                      * Input:           None
926:                      *
927:                      * Output:          the current value of the checksum generator.
928:                      *
929:                      * Side Effects:    None
930:                      *
931:                      * Overview:        The function returns the calculated checksum value.
932:                      *
933:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
934:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
935:                      *
936:                      * Example:         unsigned int myChk=DmaSfmChecksum();
937:                      ********************************************************************/
938:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
939:                     {
940:                         return DCRCDATA;
941:                     }
942:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
943:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
944:                 
945:                 
946:                     /*********************************************************************
947:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
948:                      *
949:                      * PreCondition:    None
950:                      *
951:                      * Input:           seed    - the initial seed of the checksum generator
952:                      *
953:                      * Output:          None
954:                      *
955:                      * Side Effects:    None
956:                      *
957:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
958:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
959:                      *
960:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
961:                      *
962:                      * Example:         DmaSfmSetSeed(0xffffffff);
963:                      ********************************************************************/
964:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
965:                     {
966:                         DCRCDATA=seed;
967:                     }
968:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
969:                 
970:                 
971:                 /*********************  end of high level functions ****************************************/
972:                 
973:                     // low level definitions for the API functions
974:                 
975:                 
976:                     typedef struct
977:                     {
978:                         union
979:                         {
980:                             struct
981:                             {
982:                                 unsigned int chn:   3;      // last active DMA channel
983:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
984:                             };
985:                             unsigned int    w;                      // word access
986:                         }lastAccess;
987:                         void*   lastAddress;        // most recent DMA address
988:                     }DmaStatus;         // DMA controller status
989:                 
990:                     typedef enum
991:                     {
992:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
993:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
994:                         //
995:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
996:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
997:                 
998:                 
999:                 
1000:                
1001:                    typedef enum
1002:                    {
1003:                        DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
1004:                        DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
1005:                        // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
1006:                        // the start and abort IRQ signals
1007:                        DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
1008:                
1009:                
1010:                        // compiler use only field
1011:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1012:                    }DmaEvCtrlFlags;    /*DMA channel event control fields accessible as flags also
1013:                                          part of DmaEvCtrlFlags:
1014:                                        */
1015:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1016:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1017:                
1018:                    // DMA channel event control as a structure:
1019:                    #define DmaEvCtrl   __DCH0ECONbits_t
1020:                
1021:                
1022:                
1023:                
1024:                    typedef enum
1025:                    {
1026:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1027:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1028:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1029:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1030:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1031:                        // use the DMA_CTL_PRI() below for selecting the DMA
1032:                        // channel priority
1033:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1034:                    // also part of DmaChnCtrlFlags:
1035:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1036:                
1037:                    // DMA channel control as a structure:
1038:                    #define DmaChnCtrl      __DCH0CONbits_t
1039:                
1040:                    typedef struct
1041:                    {
1042:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1043:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1044:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1045:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1046:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1047:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1048:                
1049:                
1050:                    /********************** low level DMA channel functions *******************************/
1051:                
1052:                
1053:                
1054:                    // Global DMA controller functions
1055:                
1056:                    /*********************************************************************
1057:                     * Function:        void DmaEnable(int enable)
1058:                     *
1059:                     * PreCondition:    None
1060:                     *
1061:                     * Input:           enable - boolean to enable/disable the DMA controller
1062:                     *
1063:                     * Output:          None
1064:                     *
1065:                     * Side Effects:    None
1066:                     *
1067:                     * Overview:       The function enables/disables the DMA controller.
1068:                     *
1069:                     * Note:           None.
1070:                     *
1071:                     * Example:        DmaEnable(1);
1072:                     ********************************************************************/
1073:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1074:                    {
1075:                        if(enable)
1076:                        {
1077:                            DMACONSET=_DMACON_ON_MASK;
1078:                        }
1079:                        else
1080:                        {
1081:                            DMACONCLR=_DMACON_ON_MASK;
1082:                            while(DMACONbits.ON);       // wait to take effect
1083:                        }
1084:                    }
1085:                
1086:                    /*********************************************************************
1087:                     * Function:        void DmaReset(void)
1088:                     *
1089:                     * PreCondition:    None
1090:                     *
1091:                     * Input:       None
1092:                     *
1093:                     * Output:          None
1094:                     *
1095:                     * Side Effects:    None
1096:                     *
1097:                     * Overview:        The function resets the DMA controller.
1098:                     *
1099:                     * Note:            None.
1100:                     *
1101:                     * Example:        DmaReset();
1102:                     ********************************************************************/
1103:                    #define            DmaReset()   DmaEnable(0)
1104:                
1105:                
1106:                    /*********************************************************************
1107:                     * Function:        int DmaSuspend(void)
1108:                     *
1109:                     * PreCondition:    None
1110:                     *
1111:                     * Input:       None
1112:                     *
1113:                     * Output:          true if the DMA was previously suspended, false otherwise
1114:                     *
1115:                     *
1116:                     * Side Effects:    None
1117:                     *
1118:                     * Overview:        The function suspends the DMA controller.
1119:                     *
1120:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1121:                     *                  I.e. the function has to wait for the suspension to take place!
1122:                     *
1123:                     * Example:         int susp=DmaSuspend();
1124:                     ********************************************************************/
1125:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1126:                    {
1127:                        int suspSt;
1128:                        if(!(suspSt=DMACONbits.SUSPEND))
9D00306C  3C02BF88   LUI V0, -16504
9D003070  8C423000   LW V0, 12288(V0)
9D003074  7C420300   EXT V0, V0, 12, 1
9D003078  304200FF   ANDI V0, V0, 255
9D00307C  AFC20040   SW V0, 64(S8)
9D003080  8FC20040   LW V0, 64(S8)
9D003084  14400009   BNE V0, ZERO, 0x9D0030AC
9D003088  00000000   NOP
9D003140  3C02BF88   LUI V0, -16504
9D003144  8C423000   LW V0, 12288(V0)
9D003148  7C420300   EXT V0, V0, 12, 1
9D00314C  304200FF   ANDI V0, V0, 255
9D003150  AFC2004C   SW V0, 76(S8)
9D003154  8FC2004C   LW V0, 76(S8)
9D003158  1440000E   BNE V0, ZERO, 0x9D003194
9D00315C  00000000   NOP
1129:                        {
1130:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D00308C  3C02BF88   LUI V0, -16504
9D003090  24031000   ADDIU V1, ZERO, 4096
9D003094  AC433008   SW V1, 12296(V0)
9D003160  3C02BF88   LUI V0, -16504
9D003164  24031000   ADDIU V1, ZERO, 4096
9D003168  AC433008   SW V1, 12296(V0)
1131:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D003098  3C02BF88   LUI V0, -16504
9D00309C  8C423000   LW V0, 12288(V0)
9D0030A0  30420800   ANDI V0, V0, 2048
9D0030A4  1440FFFC   BNE V0, ZERO, 0x9D003098
9D0030A8  00000000   NOP
9D00316C  3C02BF88   LUI V0, -16504
9D003170  8C423000   LW V0, 12288(V0)
9D003174  30420800   ANDI V0, V0, 2048
9D003178  1440FFFC   BNE V0, ZERO, 0x9D00316C
9D00317C  00000000   NOP
9D003180  0B400C65   J 0x9D003194
9D003184  00000000   NOP
1132:                        }
1133:                        return suspSt;
9D0030AC  8FC20040   LW V0, 64(S8)
1134:                    }
1135:                
1136:                
1137:                
1138:                    /*********************************************************************
1139:                     * Function:        void DmaResume(int susp)
1140:                     *
1141:                     * PreCondition:    None
1142:                     *
1143:                     * Input:       the desired DMA suspended state.
1144:                     *
1145:                     * Output:          None
1146:                     *
1147:                     * Side Effects:    None
1148:                     *
1149:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1150:                     *
1151:                     * Note:            None.
1152:                     *
1153:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1154:                     ********************************************************************/
1155:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1156:                    {
1157:                        if(susp)
9D003134  8FC20048   LW V0, 72(S8)
9D003138  10400013   BEQ V0, ZERO, 0x9D003188
9D00313C  00000000   NOP
1158:                        {
1159:                            DmaSuspend();
1160:                        }
1161:                        else
1162:                        {
1163:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D003188  3C02BF88   LUI V0, -16504
9D00318C  24031000   ADDIU V1, ZERO, 4096
9D003190  AC433004   SW V1, 12292(V0)
1164:                        }
1165:                    }
1166:                
1167:                    /*********************************************************************
1168:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1169:                     *
1170:                     * PreCondition:    pStat   - valid pointer
1171:                     *
1172:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1173:                     *                          status, carrying the following info:
1174:                     *                              - chn:  the last active DMA channel
1175:                     *                              - rdOp: the last DMA operation, read/write
1176:                     *                              - lastAddress: the most recent DMA address
1177:                     *
1178:                     * Output:          None
1179:                     *
1180:                     * Side Effects:    None
1181:                     *
1182:                     * Overview:        The function updates the info for the current DMA controller status.
1183:                     *                  It updates the last DMA: operation, channel used and address.
1184:                     *
1185:                     * Note:            None.
1186:                     *
1187:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1188:                     ********************************************************************/
1189:                     void           DmaGetStatus(DmaStatus* pStat);
1190:                
1191:                    /*********************************************************************
1192:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1193:                     *
1194:                     * PreCondition:    None
1195:                     *
1196:                     * Input:           gFlags - flags to be set, having the following fields:
1197:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1198:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1199:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1200:                     *
1201:                     * Output:          None
1202:                     *
1203:                     * Side Effects:    None
1204:                     *
1205:                     * Overview:        The function affects the global behavior of the DMA controller.
1206:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1207:                     *                  enabled, the other flags won't be touched.
1208:                     *
1209:                     * Note:            None.
1210:                     *
1211:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1212:                     ********************************************************************/
1213:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1214:                    {
1215:                        DMACONSET=gFlags;
1216:                    }
1217:                
1218:                    /*********************************************************************
1219:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1220:                     *
1221:                     * PreCondition:    None
1222:                     *
1223:                     * Input:           gFlags - flags to be cleared, having the following fields:
1224:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1225:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1226:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1227:                     *
1228:                     * Output:          None
1229:                     *
1230:                     * Side Effects:    None
1231:                     *
1232:                     * Overview:        The function affects the global behavior of the DMA controller.
1233:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1234:                     *                  cleared, the other flags won't be touched.
1235:                     *
1236:                     * Note:            None.
1237:                     *
1238:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1239:                     ********************************************************************/
1240:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1241:                    {
1242:                        DMACONCLR=gFlags;
1243:                    }
1244:                
1245:                
1246:                    /*********************************************************************
1247:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1248:                     *
1249:                     * PreCondition:    None
1250:                     *
1251:                     * Input:           gFlags - flags to be set, having the following fields:
1252:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1253:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1254:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1255:                     *
1256:                     * Output:          None
1257:                     *
1258:                     * Side Effects:    None
1259:                     *
1260:                     * Overview:        The function affects the global behavior of the DMA controller.
1261:                     *                  It forces the flags to have the specified gFlags value.
1262:                     *
1263:                     * Note:            None.
1264:                     *
1265:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1266:                     ********************************************************************/
1267:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1268:                    {
1269:                        DMACON=gFlags;
1270:                    }
1271:                
1272:                    /*********************************************************************
1273:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1274:                     *
1275:                     * PreCondition:    None
1276:                     *
1277:                     * Input:           None
1278:                     *
1279:                     * Output:          The current DMA controller flags settings.
1280:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1281:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1282:                     *
1283:                     * Side Effects:    None
1284:                     *
1285:                     * Overview:        The function returns the global flags of the DMA controller.
1286:                     *
1287:                     * Note:            None.
1288:                     *
1289:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1290:                     ********************************************************************/
1291:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1292:                    {
1293:                        return (DmaGlblFlags)DMACON;
1294:                    }
1295:                
1296:                
1297:                    /*********************************************************************
1298:                     * Function:        int DmaGetMaxTxferSize(void)
1299:                     *
1300:                     * PreCondition:    None
1301:                     *
1302:                     * Input:           None
1303:                     *
1304:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1305:                     *
1306:                     * Side Effects:    None
1307:                     *
1308:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1309:                     *
1310:                     * Note:            Revision dependant.
1311:                     *
1312:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1313:                     ********************************************************************/
1314:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1315:                    {
1316:                        return 65536;
1317:                    }
1318:                
1319:                    // Direct Channel control functions
1320:                
1321:                    typedef enum
1322:                    {
1323:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1324:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1325:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1326:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1327:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1328:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1329:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1330:                    }DmaConfigFlags;    // flags for the channel configuration
1331:                
1332:                
1333:                
1334:                    /*********************************************************************
1335:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1336:                     *
1337:                     * PreCondition:    chPri  - valid channel priority, 0-3
1338:                     *
1339:                     * Input:           chn    - channel to be configured in the DMA controller
1340:                     *                  chPri  - the priority given to the channel, 0-3
1341:                     *                  cFlags - orred flags specifying the configuration:
1342:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1343:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1344:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1345:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1346:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1347:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1348:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1349:                     *
1350:                     *
1351:                     *
1352:                     * Output:          None
1353:                     *
1354:                     * Side Effects:    None
1355:                     *
1356:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1357:                     *
1358:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1359:                     *                  The channel is just configured.
1360:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1361:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1362:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1363:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1364:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1365:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1366:                     *
1367:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1368:                     ********************************************************************/
1369:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1370:                
1371:                
1372:                    /*********************************************************************
1373:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1374:                     *
1375:                     * PreCondition:    chn - valid DMA channel
1376:                     *
1377:                     * Input:           chn     - DMA channel number
1378:                     *
1379:                     * Output:          Current channel source pointer.
1380:                     *
1381:                     * Side Effects:    None
1382:                     *
1383:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1384:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1385:                     *
1386:                     * Note:            None
1387:                     *
1388:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1389:                     ********************************************************************/
1390:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1391:                
1392:                    /*********************************************************************
1393:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1394:                     *
1395:                     * PreCondition:    chn - valid DMA channel
1396:                     *
1397:                     * Input:           chn     - DMA channel number
1398:                     *
1399:                     * Output:          Current channel destination pointer.
1400:                     *
1401:                     * Side Effects:    None
1402:                     *
1403:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1404:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1405:                     *
1406:                     * Note:            None
1407:                     *
1408:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1409:                     ********************************************************************/
1410:                     int            DmaChnGetDstPnt(DmaChannel chn);
1411:                
1412:                    /*********************************************************************
1413:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1414:                     *
1415:                     * PreCondition:    chn - valid DMA channel
1416:                     *
1417:                     * Input:           chn     - DMA channel number
1418:                     *
1419:                     * Output:          Current channel transfer pointer.
1420:                     *
1421:                     * Side Effects:    None
1422:                     *
1423:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1424:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1425:                     *
1426:                     * Note:            None
1427:                     *
1428:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1429:                     ********************************************************************/
1430:                     int            DmaChnGetCellPnt(DmaChannel chn);
1431:                
1432:                
1433:                
1434:                    /*********************************************************************
1435:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1436:                     *
1437:                     * PreCondition:    chn - valid DMA channel
1438:                     *
1439:                     * Input:           chn         - DMA channel number
1440:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1441:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1442:                     *                                      - SIRQEN: enable/disable the start IRQ action
1443:                     *                                      - PATEN: enable/disable the pattern match and abort
1444:                     *                                  or any of the DmaEvCtrlFlags:
1445:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1446:                     *
1447:                     *
1448:                     * Output:          None
1449:                     *
1450:                     * Side Effects:    None
1451:                     *
1452:                     * Overview:        The function sets the events that start and abort the transfer
1453:                     *                  for the selected DMA channel.
1454:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1455:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1456:                     *
1457:                     * Note:            None.
1458:                     *
1459:                     * Example:         either:
1460:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1461:                     *                  or:
1462:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1463:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1464:                     *
1465:                     ********************************************************************/
1466:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1467:                
1468:                
1469:                    /*********************************************************************
1470:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1471:                     *
1472:                     * PreCondition:    chn - valid DMA channel
1473:                     *
1474:                     * Input:           chn         - DMA channel number
1475:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1476:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1477:                     *                                      - SIRQEN: enable/disable the start IRQ action
1478:                     *                                      - PATEN: enable/disable the pattern match and abort
1479:                     *                                  or any of the DmaEvCtrlFlags:
1480:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1481:                     *
1482:                     *
1483:                     * Output:          None
1484:                     *
1485:                     * Side Effects:    None
1486:                     *
1487:                     * Overview:        The function clears the events that start and abort the transfer
1488:                     *                  for the selected DMA channel.
1489:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1490:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1491:                     *
1492:                     * Note:            None.
1493:                     *
1494:                     * Example:         either:
1495:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1496:                     *                  or:
1497:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1498:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1499:                     *
1500:                     ********************************************************************/
1501:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1502:                
1503:                
1504:                
1505:                    /*********************************************************************
1506:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1507:                     *
1508:                     * PreCondition:    chn - valid DMA channel
1509:                     *
1510:                     * Input:           chn         - DMA channel number
1511:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1512:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1513:                     *                                      - SIRQEN: enable/disable the start IRQ action
1514:                     *                                      - PATEN: enable/disable the pattern match and abort
1515:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1516:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1517:                     *                                  or any of the DmaEvCtrlFlags:
1518:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1519:                     *
1520:                     *
1521:                     * Output:          None
1522:                     *
1523:                     * Side Effects:    None
1524:                     *
1525:                     * Overview:        The function writes the events that start and abort the transfer
1526:                     *                  for the selected DMA channel.
1527:                     *
1528:                     * Note:            None.
1529:                     *
1530:                     * Example:         either:
1531:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1532:                     *                  or:
1533:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1534:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1535:                     *
1536:                     ********************************************************************/
1537:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1538:                
1539:                
1540:                
1541:                    /*********************************************************************
1542:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1543:                     *
1544:                     * PreCondition:    chn - valid DMA channel
1545:                     *
1546:                     * Input:           chn         - DMA channel number
1547:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1548:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1549:                     *                                      - SIRQEN: enable/disable the start IRQ action
1550:                     *                                      - PATEN: enable/disable the pattern match and abort
1551:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1552:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1553:                     *                                  or any of the DmaEvCtrlFlags:
1554:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1555:                     *
1556:                     *
1557:                     * Output:          None
1558:                     *
1559:                     * Side Effects:    None
1560:                     *
1561:                     * Overview:        The function sets the events that start and abort the transfer
1562:                     *                  for the selected DMA channel.
1563:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1564:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1565:                     *
1566:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1567:                     *
1568:                     * Example:         either:
1569:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1570:                     *                  or:
1571:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1572:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1573:                     *
1574:                     ********************************************************************/
1575:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1576:                
1577:                
1578:                    /*********************************************************************
1579:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1580:                     *
1581:                     * PreCondition:    chn - valid DMA channel
1582:                     *
1583:                     * Input:           chn     - DMA channel number
1584:                     *
1585:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1586:                     *                          - AIRQEN: enable/disable the abort IRQ action
1587:                     *                          - SIRQEN: enable/disable the start IRQ action
1588:                     *                          - PATEN: enable/disable the pattern match and abort
1589:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1590:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1591:                     *                      or any of the DmaEvCtrlFlags:
1592:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1593:                     *
1594:                     *
1595:                     * Side Effects:    None
1596:                     *
1597:                     * Overview:        The function retrieves the events that start and abort the transfer
1598:                     *                  for the selected DMA channel.
1599:                     *
1600:                     * Note:            None.
1601:                     *
1602:                     * Example:         either:
1603:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1604:                     *                  or:
1605:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1606:                     *
1607:                     ********************************************************************/
1608:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1609:                
1610:                
1611:                    /*********************************************************************
1612:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1613:                     *
1614:                     * PreCondition:    chn - valid DMA channel
1615:                     *
1616:                     * Input:           chn         - DMA channel number
1617:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1618:                     *                                      - autoEn: enable/disable the automatic mode
1619:                     *                                      - chainEn: enable/disable channel chaining
1620:                     *                                      - detectEn: enable/disable events detection when channel disabled
1621:                     *                                      - chEn: enable/disable channel functionality
1622:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1623:                     *                                  or any of the DmaChnCtrlFlags flags:
1624:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1625:                     *
1626:                     * Output:          None
1627:                     *
1628:                     * Side Effects:    None
1629:                     *
1630:                     * Overview:        The function sets the selected DMA channel control flags:
1631:                     *                  the chaining or auto mode, and events detection.
1632:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1633:                     *                  set for the selected channel, the other channel control flags won't be touched.
1634:                     *
1635:                     * Note:            None.
1636:                     *
1637:                     * Example:         either:
1638:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1639:                     *                  or:
1640:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1641:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1642:                     *
1643:                     ********************************************************************/
1644:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1645:                
1646:                    /*********************************************************************
1647:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1648:                     *
1649:                     * PreCondition:    chn - valid DMA channel
1650:                     *
1651:                     * Input:           chn         - DMA channel number
1652:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1653:                     *                                      - autoEn: enable/disable the automatic mode
1654:                     *                                      - chainEn: enable/disable channel chaining
1655:                     *                                      - detectEn: enable/disable events detection when channel disabled
1656:                     *                                      - chEn: enable/disable channel functionality
1657:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1658:                     *                                  or any of the DmaChnCtrlFlags flags:
1659:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1660:                     *
1661:                     * Output:          None
1662:                     *
1663:                     * Side Effects:    None
1664:                     *
1665:                     * Overview:        The function clears the selected DMA channel control flags:
1666:                     *                  the chaining or auto mode and events detection.
1667:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1668:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1669:                     *
1670:                     * Note:            None.
1671:                     *
1672:                     * Example:         either:
1673:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1674:                     *                  or:
1675:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1676:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1677:                     *
1678:                     ********************************************************************/
1679:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1680:                
1681:                    /*********************************************************************
1682:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1683:                     *
1684:                     * PreCondition:    chn - valid DMA channel
1685:                     *
1686:                     * Input:           chn         - DMA channel number
1687:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1688:                     *                                      - chPri: channel priority 0-3
1689:                     *                                      - autoEn: enable/disable the automatic mode
1690:                     *                                      - chainEn: enable/disable channel chaining
1691:                     *                                      - detectEn: enable/disable events detection when channel disabled
1692:                     *                                      - chEn: enable/disable channel functionality
1693:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1694:                     *                                  or any of the DmaChnCtrlFlags flags:
1695:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1696:                     *
1697:                     * Output:          None
1698:                     *
1699:                     * Side Effects:    None
1700:                     *
1701:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1702:                     *                  the channel priority, chaining mode or auto and events detection.
1703:                     *
1704:                     * Note:            None.
1705:                     *
1706:                     * Example:         either:
1707:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1708:                     *                  or:
1709:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1710:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1711:                     *
1712:                     ********************************************************************/
1713:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1714:                
1715:                    /*********************************************************************
1716:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1717:                     *
1718:                     * PreCondition:    chn - valid DMA channel
1719:                     *
1720:                     * Input:       chn     - DMA channel number
1721:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1722:                     *                      - chPri: channel priority 0-3
1723:                     *                      - autoEn: enable/disable the automatic mode
1724:                     *                      - chainEn: enable/disable channel chaining
1725:                     *                      - detectEn: enable/disable events detection when channel disabled
1726:                     *                      - chEn: enable/disable channel functionality
1727:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1728:                     *                  or any of the DmaChnCtrlFlags flags:
1729:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1730:                     *
1731:                     * Output:          None
1732:                     *
1733:                     * Side Effects:    None
1734:                     *
1735:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1736:                     *                  the channel priority, chaining mode or auto and events detection.
1737:                     *
1738:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1739:                     *
1740:                     * Example:         either:
1741:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1742:                     *                  or:
1743:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1744:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1745:                     *
1746:                     ********************************************************************/
1747:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1748:                
1749:                    /*********************************************************************
1750:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1751:                     *
1752:                     * PreCondition:    chn - valid DMA channel
1753:                     *
1754:                     * Input:           chn         - DMA channel number
1755:                     *
1756:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1757:                     *                          - chPri: channel priority 0-3
1758:                     *                          - autoEn: enable/disable the automatic mode
1759:                     *                          - chainEn: enable/disable channel chaining
1760:                     *                          - detectEn: enable/disable events detection when channel disabled
1761:                     *                          - chEn: enable/disable channel functionality
1762:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1763:                     *                      or any of the DmaChnCtrlFlags flags:
1764:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1765:                     *
1766:                     * Side Effects:    None
1767:                     *
1768:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1769:                     *                  including the channel enable/disable status, the channel priority,
1770:                     *                  chaining mode, auto mode and events detection.
1771:                     *
1772:                     * Note:            None.
1773:                     *
1774:                     * Example:         either:
1775:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1776:                     *                  or:
1777:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1778:                     *
1779:                     ********************************************************************/
1780:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1781:                
1782:                
1783:                    /*********************************************************************
1784:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1785:                     *
1786:                     * PreCondition:    chn - valid DMA channel
1787:                     *
1788:                     * Input:           chn     - DMA channel number
1789:                     *
1790:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1791:                     *
1792:                     * Side Effects:    None
1793:                     *
1794:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1795:                     *
1796:                     * Note:            None.
1797:                     *
1798:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1799:                     *
1800:                     ********************************************************************/
1801:                     int            DmaChnGetEvDetect(DmaChannel chn);
1802:                
1803:                    /*********************************************************************
1804:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1805:                     *
1806:                     * PreCondition:    chn     - valid DMA channel
1807:                     *                  pTxCtrl - valid pointer
1808:                     *
1809:                     * Input:           chn         - DMA channel number
1810:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1811:                     *                              - vSrcAdd: source of the DMA transfer
1812:                     *                              - vDstAdd: destination of the DMA transfer
1813:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1814:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1815:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1816:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1817:                     *
1818:                     * Output:          None
1819:                     *
1820:                     * Side Effects:    None
1821:                     *
1822:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1823:                     *                  the source and the destination addresses.
1824:                     *                  It also retrieves the source and destination lengths
1825:                     *                  and the number of bytes transferred per event.
1826:                     *
1827:                     * Note:            None
1828:                     *
1829:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1830:                     ********************************************************************/
1831:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1832:                
1833:                    // Low level checksum functions
1834:                
1835:                    /*********************************************************************
1836:                     * Function:        void DmaSfmEnable(int enable)
1837:                     *
1838:                     * PreCondition:    None
1839:                     *
1840:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1841:                     *
1842:                     * Output:          None
1843:                     *
1844:                     * Side Effects:    None
1845:                     *
1846:                     * Overview:        The function enables/diables the checksum module functionality.
1847:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1848:                     *
1849:                     * Note:            The SFM module should be properly configured before enabled.
1850:                     *
1851:                     * Example:         DmaSfmEnable(1);
1852:                     ********************************************************************/
1853:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1854:                    {
1855:                        if(enable)
1856:                        {
1857:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1858:                        }
1859:                        else
1860:                        {
1861:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1862:                        }
1863:                    }
1864:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1865:                
1866:                
1867:                    /*********************************************************************
1868:                     * Function:        int DmaSfmGetEnable(void)
1869:                     *
1870:                     * PreCondition:    None
1871:                     *
1872:                     * Input:           None
1873:                     *
1874:                     * Output:          TRUE, if the SFM module is enabled
1875:                     *          FALSE otherwise
1876:                     *
1877:                     * Side Effects:    None
1878:                     *
1879:                     * Overview:        The function returns the SFM module enabling status.
1880:                     *
1881:                     * Note:            None
1882:                     *
1883:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1884:                     ********************************************************************/
1885:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1886:                    {
1887:                        return DCRCCONbits.CRCEN!=0;
1888:                    }
1889:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1890:                
1891:                
1892:                    /*********************************************************************
1893:                     * Function:        void DmaSfmAppendEnable(int enable)
1894:                     *
1895:                     * PreCondition:    None
1896:                     *
1897:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1898:                     *
1899:                     * Output:          None
1900:                     *
1901:                     * Side Effects:    None
1902:                     *
1903:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1904:                     *                  the source data but does not write it to the destination address. The data it's just passed
1905:                     *                  to the checksum generator for CRC/IP checksum calculation.
1906:                     *                  When the block transfer is completed, the checksum result is written to the
1907:                     *                  DMA channel destination address.
1908:                     *
1909:                     * Note:            The SFM module should be properly configured before enabled.
1910:                     *
1911:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1912:                     ********************************************************************/
1913:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1914:                    {
1915:                        if(enable)
1916:                        {
1917:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1918:                        }
1919:                        else
1920:                        {
1921:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1922:                        }
1923:                    }
1924:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1925:                
1926:                
1927:                    /*********************************************************************
1928:                     * Function:        int DmaSfmGetAppendMode(void)
1929:                     *
1930:                     * PreCondition:    None
1931:                     *
1932:                     * Input:           None
1933:                     *
1934:                     * Output:          TRUE, if the SFM append mode is enabled
1935:                     *                  FALSE otherwise
1936:                     *
1937:                     * Side Effects:    None
1938:                     *
1939:                     * Overview:        The function returns the SFM module enabling status.
1940:                     *
1941:                     * Note:            None
1942:                     *
1943:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1944:                     ********************************************************************/
1945:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1946:                    {
1947:                        return DCRCCONbits.CRCAPP!=0;
1948:                    }
1949:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1950:                
1951:                
1952:                    /*********************************************************************
1953:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1954:                     *
1955:                     * PreCondition:    chn     - valid DMA channel
1956:                     *
1957:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1958:                     *
1959:                     * Output:          None
1960:                     *
1961:                     * Side Effects:    None
1962:                     *
1963:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1964:                     *
1965:                     * Note:            None
1966:                     *
1967:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1968:                     ********************************************************************/
1969:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1970:                    {
1971:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1972:                        DCRCCONSET=chn;
1973:                    }
1974:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1975:                
1976:                
1977:                    /*********************************************************************
1978:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1979:                     *
1980:                     * PreCondition:    None
1981:                     *
1982:                     * Input:           None
1983:                     *
1984:                     * Output:          the DMA channel that is currently attached to the CRC module
1985:                     *
1986:                     * Side Effects:    None
1987:                     *
1988:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1989:                     *
1990:                     * Note:            None
1991:                     *
1992:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1993:                     ********************************************************************/
1994:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1995:                    {
1996:                        return (DmaChannel)DCRCCONbits.CRCCH;
1997:                    }
1998:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1999:                
2000:                    /*********************************************************************
2001:                     * Function:        void DmaCrcSetPLen(int pLen)
2002:                     *
2003:                     * PreCondition:    pLen - valid polynomial length within 1-32
2004:                     *
2005:                     * Input:           pLen    - the length of the CRC generator polynomial
2006:                     *
2007:                     * Output:          None
2008:                     *
2009:                     * Side Effects:    None
2010:                     *
2011:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
2012:                     *
2013:                     * Note:            None
2014:                     *
2015:                     * Example:         DmaCrcSetPLen(32);
2016:                     ********************************************************************/
2017:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2018:                    {
2019:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2020:                        DCRCCONSET=(pLen)-1;
2021:                    }
2022:                
2023:                    /*********************************************************************
2024:                     * Function:        int DmaCrcGetPLen(void)
2025:                     *
2026:                     * PreCondition:    None
2027:                     *
2028:                     * Input:           None
2029:                     *
2030:                     * Output:          the length of the CRC generator polynomial
2031:                     *
2032:                     * Side Effects:    None
2033:                     *
2034:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2035:                     *                  It's always a number between 1 and 32.
2036:                     *
2037:                     * Note:            None
2038:                     *
2039:                     * Example:         int polyLen=DmaCrcGetPLen();
2040:                     ********************************************************************/
2041:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2042:                    {
2043:                        return  DCRCCONbits.PLEN+1;
2044:                    }
2045:                
2046:                    /*********************************************************************
2047:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2048:                     *
2049:                     * PreCondition:    None
2050:                     *
2051:                     * Input:           feedback - the layout of the CRC generator
2052:                     *
2053:                     * Output:          None
2054:                     *
2055:                     * Side Effects:    None
2056:                     *
2057:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2058:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2059:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2060:                     *
2061:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2062:                     *
2063:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2064:                     ********************************************************************/
2065:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2066:                    {
2067:                        DCRCXOR=feedback;
2068:                    }
2069:                
2070:                
2071:                    /*********************************************************************
2072:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2073:                     *
2074:                     * PreCondition:    None
2075:                     *
2076:                     * Input:           None
2077:                     *
2078:                     * Output:          the current layout of the CRC generator
2079:                     *
2080:                     * Side Effects:    None
2081:                     *
2082:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2083:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2084:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2085:                     *
2086:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2087:                     *
2088:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2089:                     ********************************************************************/
2090:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2091:                    {
2092:                        return DCRCXOR;
2093:                    }
2094:                
2095:                
2096:                
2097:                    // Channel test/debug and special functions
2098:                
2099:                    /*********************************************************************
2100:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2101:                     *
2102:                     * PreCondition:    chn - valid DMA channel
2103:                     *
2104:                     * Input:           chn     - DMA channel number
2105:                     *                  eFlags  - event flags with the following significance:
2106:                     *                              - DMA_EV_ERR: address error event
2107:                     *                              - DMA_EV_ABORT: transfer abort event
2108:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2109:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2110:                     *                              - DMA_EV_DST_HALF: destination half event
2111:                     *                              - DMA_EV_DST_FULL: destination full event
2112:                     *                              - DMA_EV_SRC_HALF: source half event
2113:                     *                              - DMA_EV_SRC_FULL: source full event
2114:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2115:                     *
2116:                     * Output:          None
2117:                     *
2118:                     * Side Effects:    None
2119:                     *
2120:                     * Overview:        The function sets the event flags for the selected DMA channel.
2121:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2122:                     *                  set for the selected channel, the other channel event flags won't be touched.
2123:                     *
2124:                     * Note:            This is intended as a channel test function.
2125:                     *
2126:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2127:                     ********************************************************************/
2128:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2129:                
2130:                    /*********************************************************************
2131:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2132:                     *
2133:                     * PreCondition:    chn - valid DMA channel
2134:                     *
2135:                     * Input:           chn     - DMA channel number
2136:                     *                  eFlags  - event flags with the following significance:
2137:                     *                              - DMA_EV_ERR: address error event
2138:                     *                              - DMA_EV_ABORT: transfer abort event
2139:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2140:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2141:                     *                              - DMA_EV_DST_HALF: destination half event
2142:                     *                              - DMA_EV_DST_FULL: destination full event
2143:                     *                              - DMA_EV_SRC_HALF: source half event
2144:                     *                              - DMA_EV_SRC_FULL: source full event
2145:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2146:                     *
2147:                     * Output:          None
2148:                     *
2149:                     * Side Effects:    None
2150:                     *
2151:                     * Overview:        The function writes the event flags for the selected DMA channel.
2152:                     *                  The channel event flags are forced to the eFlags value.
2153:                     *
2154:                     * Note:            This is intended as a channel test function.
2155:                     *
2156:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2157:                     ********************************************************************/
2158:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2159:                
2160:                
2161:                    /********************************************************************
2162:                     * Include legacy DMA functions
2163:                     * New projects should not use them!
2164:                     * Note that interrupt functions are no longer provided.
2165:                     * The functions in the int.h should be used instead.
2166:                     ********************************************************************/
2167:                    #ifndef _PLIB_DISABLE_LEGACY
2168:                        #include <peripheral/legacy/dma_legacy.h>
2169:                    #endif
2170:                
2171:                
2172:                #else
2173:                    #undef _DMA_CHANNELS        // no DMA channels
2174:                #endif  // _DMAC0
2175:                
2176:                #endif /*_DMA_5XX_6XX__7XX_H_*/
2177:                
2178:                
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/floatunsisf.c  ------------
9D008B88  27BDFFE8   ADDIU SP, SP, -24
9D008B8C  AFBF0014   SW RA, 20(SP)
9D008B90  04800006   BLTZ A0, 0x9D008BAC
9D008B94  00801021   ADDU V0, A0, ZERO
9D008BAC  00042042   SRL A0, A0, 1
9D008BB0  30420001   ANDI V0, V0, 1
9D008BB4  0F4022A0   JAL __floatsisf
9D008BB8  00822025   OR A0, A0, V0
9D008BBC  00402021   ADDU A0, V0, ZERO
9D008BC0  0F401EF9   JAL fpadd
9D008BC4  00402821   ADDU A1, V0, ZERO
9D008B98  0F4022A0   JAL __floatsisf
9D008B9C  00000000   NOP
9D008BA0  8FBF0014   LW RA, 20(SP)
9D008BA4  03E00008   JR RA
9D008BA8  27BD0018   ADDIU SP, SP, 24
9D008BC8  8FBF0014   LW RA, 20(SP)
9D008BCC  03E00008   JR RA
9D008BD0  27BD0018   ADDIU SP, SP, 24
9D008BD4  3C020000   LUI V0, 0
